[
  {
    "id":1,
    "response":"```python\ndef max_chain_length(lst, n):\n    \"\"\"\n    Find the length of the longest chain that can be formed from pairs in lst.\n    \n    Args:\n        lst: List of tuples (or pairs) representing the pairs\n        n: Number of pairs available\n    \n    Returns:\n        Length of the longest chain\n    \"\"\"\n    if not lst:\n        return 0\n    \n    # Sort pairs by their first element\n    sorted_pairs = sorted(lst, key=lambda x: x[0])\n    \n    # Use dynamic programming to find the longest chain\n    # dp[i] represents the length of the longest chain ending at pair i\n    dp = [1] * len(sorted_pairs)\n    \n    for i in range(1, len(sorted_pairs)):\n        for j in range(i):\n            # If current pair can follow the previous pair (end of previous < start of current)\n            if sorted_pairs[j][1] <= sorted_pairs[i][0]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp) if dp else 0\n```"
  },
  {
    "id":2,
    "response":"```python\ndef first_repeated_char(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিং-এ প্রথম পুনরাবৃত্ত অক্ষর খুঁজে পায়।\n    \n    Args:\n        s (str): প্রদত্ত স্ট্রিং\n        \n    Returns:\n        str: প্রথম পুনরাবৃত্ত অক্ষর, যদি কোনো পুনরাবৃত্ত অক্ষর না থাকে তবে None রিটার্ন করে\n    \"\"\"\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None\n```"
  },
  {
    "id":3,
    "response":"```python\ndef get_ludic(n):\n    \"\"\"\n    Returns a list of ludic numbers less than or equal to n.\n    \n    Ludic numbers are generated by a sieve-like process:\n    1. Start with the sequence of natural numbers: 1, 2, 3, 4, 5, ...\n    2. Remove every k-th number where k is the current position in the sequence.\n    3. Continue this process until no more numbers can be removed.\n    \n    For example:\n    - Start: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]\n    - Remove every 2nd number: remove 2, 4, 6, 8, 10, ... → [1, 3, 5, 7, 9, ...]\n    - Remove every 3rd number: remove 3, 6, 9, ... → [1, 5, 7, 11, ...]\n    - Continue until the sequence is complete.\n    \n    Note: The function returns all ludic numbers ≤ n.\n    \"\"\"\n    if n < 1:\n        return []\n    \n    # Initialize the list of ludic numbers\n    ludic = list(range(1, n + 1))\n    \n    # Process the sequence to generate ludic numbers\n    k = 1\n    while k < len(ludic):\n        # Remove every (k+1)th number from the current list\n        # The first number to remove is at index k\n        if k < len(ludic):\n            # Remove every k-th element starting from index k\n            remove_index = k\n            while remove_index < len(ludic):\n                ludic.pop(remove_index)\n                # Adjust the index for the next removal\n                remove_index = remove_index + k\n                # But we need to adjust k as well because the list shrinks\n                # Actually, we need to recompute the next k\n        k += 1\n    \n    # Correct implementation of ludic numbers\n    # Reinitialize with proper algorithm\n    ludic = list(range(1, n + 1))\n    i = 1\n    while i < len(ludic):\n        # Remove every (i+1)th number starting from index i\n        # But we need to remove every (i+1"
  },
  {
    "id":4,
    "response":"```python\ndef reverse_words(s):\n    \"\"\"\n    একটি প্রদত্ত স্ট্রিং এর শব্দগুলোকে বিপরীত করে ফেরত দেয়।\n    \n    Args:\n        s (str): প্রদত্ত স্ট্রিং\n        \n    Returns:\n        str: শব্দগুলো বিপরীত করা স্ট্রিং\n    \"\"\"\n    # শব্দগুলো বিভক্ত করে এবং বিপরীত করে\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words\n```"
  },
  {
    "id":5,
    "response":"```python\ndef prime_num(n):\n    \"\"\"\n    Check if a given number is a prime number.\n    \n    Args:\n        n (int): The number to check for primality.\n    \n    Returns:\n        bool: True if n is a prime number, False otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    # Check odd divisors up to sqrt(n)\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    \n    return True\n```"
  },
  {
    "id":6,
    "response":"```python\ndef radian_degree(n):\n    \"\"\"\n    ডিগ্রিকে রেডিয়ান রূপান্তর করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    n (float): ডিগ্রি মান\n    \n    রিটার্ন:\n    float: রেডিয়ান মান\n    \"\"\"\n    return n * (3.141592653589793 \/ 180)\n```"
  },
  {
    "id":7,
    "response":"```python\nimport re\n\ndef find_literals(s, s2):\n    \"\"\"\n    রেজেক্স ব্যবহার করে মূল স্ট্রিং s-এ প্যাটার্ন s2-এর অবস্থান খুঁজে বের করে।\n    \n    Parameters:\n    s (str): মূল স্ট্রিং\n    s2 (str): অনুসন্ধানের প্যাটার্ন স্ট্রিং\n    \n    Returns:\n    list: প্যাটার্নের প্রতিটি অবস্থানের সূচি (ইনডেক্স) একটি লিস্ট রূপে।\n          অবস্থান স্থানান্তর না হলে একটি খালি লিস্ট রেটার্ন করে।\n    \"\"\"\n    pattern = re.compile(s2)\n    matches = pattern.finditer(s)\n    positions = [match.start() for match in matches]\n    return positions\n```"
  },
  {
    "id":8,
    "response":"```python\ndef bell_number(n):\n    \"\"\"\n    Calculate the nth Bell number.\n    \n    The Bell number B(n) counts the number of ways to partition a set of n elements.\n    \n    Args:\n        n (int): The index of the Bell number to compute (non-negative integer)\n    \n    Returns:\n        int: The nth Bell number\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    # Create a triangle to store Bell numbers\n    # bell[i][j] represents the number of ways to partition i elements into j non-empty subsets\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    # Base case: there's one way to partition 0 elements\n    bell[0][0] = 1\n    \n    # Fill the bell triangle\n    for i in range(1, n + 1):\n        # Bell numbers can be computed using the recurrence relation\n        # bell[i][j] = bell[i-1][j-1] + bell[i-1][j] + bell[i-1][j+1]\n        # But we can also use the simpler recurrence:\n        # bell[i][j] = sum of bell[i-1][k] for k from 0 to j-1\n        for j in range(i + 1):\n            if j == 0:\n                bell[i][j] = 1\n            else:\n                bell[i][j] = bell[i-1][j-1]\n                for k in range(j):\n                    bell[i][j] += bell[i-1][k]\n    \n    # The nth Bell number is the sum of all entries in the nth row\n    result = 0\n    for j in range(n + 1):\n        result += bell[n][j]\n    \n    return result\n```"
  },
  {
    "id":9,
    "response":"```python\ndef floor_Min(n, n2, n3):\n    \"\"\"\n    প্রদত্ত তিনটি সংখ্যার মধ্যে সর্বনিম্ন মান খুঁজে পায়।\n    \n    প্যারামিটার:\n    n: প্রথম সংখ্যা\n    n2: দ্বিতীয় সংখ্যা\n    n3: তৃতীয় সংখ্যা\n    \n    রিটার্ন:\n    সর্বনিম্ন মানের মান\n    \"\"\"\n    return min(n, n2, n3)\n```"
  },
  {
    "id":10,
    "response":"```python\ndef remove_kth_element(lst, n):\n    \"\"\"\n    Remove the n-th element (1-indexed) from the list and return the modified list.\n    \n    Args:\n        lst: List from which the element will be removed\n        n: The position of the element to remove (1-indexed)\n    \n    Returns:\n        List with the n-th element removed\n    \n    Raises:\n        IndexError: If n is out of bounds (less than 1 or greater than len(lst))\n    \"\"\"\n    if n < 1 or n > len(lst):\n        raise IndexError(\"Index out of bounds\")\n    \n    # Remove the n-th element (convert to 0-indexed)\n    lst.pop(n - 1)\n    return lst\n```"
  },
  {
    "id":11,
    "response":"```python\ndef max_of_nth(lst, n):\n    \"\"\"\n    প্রদত্ত টিপল তালিকা থেকে n-তম কলামের সর্বোচ্চ সংখ্যা খুঁজে বের করে।\n    \n    প্যারামিটার:\n    lst: টিপল তালিকা (প্রতিটি টিপল একটি কলামের ডেটা বহন করে)\n    n: n-তম কলামের স্থান (0 থেকে শুরু)\n    \n    রিটার্ন:\n    n-তম কলামের সর্বোচ্চ সংখ্যা। যদি কোন কলাম না থাকে তবে None রিটার্ন করে।\n    \"\"\"\n    if not lst or n < 0:\n        return None\n    \n    values = []\n    for item in lst:\n        if n < len(item):\n            values.append(item[n])\n    \n    return max(values) if values else None\n```"
  },
  {
    "id":12,
    "response":"```python\ndef merge(lst):\n    \"\"\"\n    Takes a list and returns a new list with the first and last elements separated.\n    If the list has only one element, it returns a list containing that element twice.\n    If the list is empty, it returns an empty list.\n    \"\"\"\n    if len(lst) == 0:\n        return []\n    elif len(lst) == 1:\n        return [lst[0], lst[0]]\n    else:\n        return [lst[0], lst[-1]]\n```"
  },
  {
    "id":13,
    "response":"```python\ndef maximum_value(lst):\n    \"\"\"\n    Find the maximum value in a list of tuples where each tuple represents a record.\n    \n    Args:\n        lst: A list of tuples, where each tuple contains values (assumed to be numeric).\n    \n    Returns:\n        The maximum value among all elements in the tuples.\n    \n    Example:\n        >>> maximum_value([(1, 2), (3, 4), (5, 6)])\n        6\n    \"\"\"\n    if not lst:\n        return None\n    \n    # Flatten the list of tuples and find the maximum value\n    flattened_values = [value for tuple_item in lst for value in tuple_item]\n    \n    return max(flattened_values)\n```"
  },
  {
    "id":14,
    "response":"```python\ndef cumulative_sum(lst):\n    \"\"\"\n    Return a list of cumulative sums of the input list.\n    \n    Args:\n        lst: A list of numbers\n        \n    Returns:\n        A list where each element is the sum of all previous elements including itself\n    \"\"\"\n    if not lst:\n        return []\n    \n    result = []\n    total = 0\n    \n    for num in lst:\n        total += num\n        result.append(total)\n    \n    return result\n```"
  },
  {
    "id":15,
    "response":"```python\ndef average_tuple(tup):\n    \"\"\"\n    Calculate the average of all numbers in a tuple of tuples.\n    \n    Args:\n        tup: A tuple of tuples, where each inner tuple contains numbers.\n    \n    Returns:\n        float: The average of all numbers in the nested tuples.\n    \n    Example:\n        >>> average_tuple(((1, 2), (3, 4), (5, 6)))\n        3.5\n    \"\"\"\n    # Flatten the tuple of tuples and sum all numbers\n    total = 0\n    count = 0\n    \n    for inner_tuple in tup:\n        for num in inner_tuple:\n            total += num\n            count += 1\n    \n    # Return average (total \/ count)\n    return total \/ count if count > 0 else 0\n```"
  },
  {
    "id":16,
    "response":"```python\ndef tuple_modulo(tup, tup2):\n    \"\"\"\n    দুটি টুপলের উপাদানগুলির মডুলো সম্পাদন করে একটি নতুন টুপল রেটার্ন করে।\n    \n    Args:\n        tup: প্রথম টুপল\n        tup2: দ্বিতীয় টুপল\n    \n    Returns:\n        একটি নতুন টুপল যেখানে i-তম উপাদান হল (tup[i] % tup2[i])\n    \n    Raises:\n        ValueError: যদি টুপলগুলির দৈর্ঘ্য মিলে না থাকে বা দ্বিতীয় টুপলের কোনও উপাদান শূন্য হয়\n    \"\"\"\n    if len(tup) != len(tup2):\n        raise ValueError(\"টুপলগুলির দৈর্ঘ্য মিলে না থাকলে অসম্ভব।\")\n    \n    result = []\n    for i in range(len(tup)):\n        if tup2[i] == 0:\n            raise ValueError(f\"দ্বিতীয় টুপলের {i}-তম উপাদান শূন্য হলে মডুলো করা সম্ভব না।\")\n        result.append(tup[i] % tup2[i])\n    \n    return tuple(result)\n```"
  },
  {
    "id":17,
    "response":"```python\ndef min_Jumps(n, n2, n3):\n    \"\"\"\n    Calculate the minimum number of jumps needed to reach a point (d, 0) \n    from the origin (0, 0) in a 2D plane, where each jump has a fixed length.\n    \n    Parameters:\n    n (int): The length of the first jump\n    n2 (int): The length of the second jump\n    n3 (int): The length of the third jump\n    \n    Returns:\n    int: Minimum number of jumps required to reach (d, 0)\n    \"\"\"\n    # Since the target is (d, 0), we need to reach exactly d units along x-axis\n    # and 0 units along y-axis.\n    # We can only move in jumps of length n, n2, or n3.\n    # We need to find the minimum number of jumps to reach distance d on x-axis.\n    \n    # If d is 0, no jumps needed\n    if d == 0:\n        return 0\n    \n    # We'll use BFS to find the minimum jumps\n    from collections import deque\n    \n    # We're only tracking the x-coordinate since y will always be 0\n    # and we're only interested in reaching exactly d\n    queue = deque([(0, 0)])  # (current_x, jumps_count)\n    visited = {0}\n    \n    while queue:\n        x, jumps = queue.popleft()\n        \n        # Try all three jump types\n        for jump in [n, n2, n3]:\n            new_x = x + jump\n            if new_x == d:\n                return jumps + 1\n            elif new_x > d:\n                continue\n            elif new_x not in visited:\n                visited.add(new_x)\n                queue.append((new_x, jumps + 1))\n    \n    # If we can't reach d, return -1 (impossible)\n    return -1\n```"
  },
  {
    "id":18,
    "response":"```python\ndef div_list(lst, lst2):\n    \"\"\"\n    দুটি তালিকা ভাগ করে দেয় এবং প্রতিটি পৃথক তালিকা তৈরি করে।\n    একটি ল্যাম্বদা ফাংশন ব্যবহার করে যেখানে প্রতিটি তালিকার উপাদান পরস্পরের সাথে ভাগ করা হয়।\n    \n    Args:\n        lst: প্রথম তালিকা\n        lst2: দ্বিতীয় তালিকা\n    \n    Returns:\n        দুটি তালিকা যা প্রতিটি উপাদানের ভাগ ফলাফল দেয়\n    \"\"\"\n    # ল্যাম্বদা ফাংশন ব্যবহার করে ভাগ করা হয়\n    result1 = list(map(lambda x, y: x \/ y if y != 0 else 0, lst, lst2))\n    result2 = list(map(lambda x, y: x \/\/ y if y != 0 else 0, lst, lst2))\n    \n    return result1, result2\n```"
  },
  {
    "id":19,
    "response":"```python\ndef move_num(s):\n    \"\"\"\n    একটি স্ট্রিংয়ে সংখ্যাগুলোকে স্থানান্তর করে ফেরত দেয়।\n    যদি স্ট্রিংয়ে সংখ্যা থাকে, তবে সেগুলোকে স্থানান্তর করে ফেরত দেয়।\n    \n    Args:\n        s (str): সংখ্যা বিশিষ্ট স্ট্রিং\n        \n    Returns:\n        str: সংখ্যাগুলোকে স্থানান্তর করে ফেরত দেওয়া স্ট্রিং\n    \"\"\"\n    # স্ট্রিংয়ে সংখ্যা বিশিষ্ট অংশগুলো স্থানান্তর করে\n    result = \"\"\n    for char in s:\n        if char.isdigit():\n            result += char\n    return result\n```"
  },
  {
    "id":20,
    "response":"```python\ndef largest_subset(lst, n):\n    \"\"\"\n    Find the largest subset of pairs where each pair is divisible.\n    \n    Args:\n        lst: List of integers\n        n: Integer threshold for divisibility\n    \n    Returns:\n        Integer representing the size of the largest subset where each pair is divisible\n    \"\"\"\n    if not lst or n <= 0:\n        return 0\n    \n    # Create pairs from the list\n    pairs = []\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] % lst[j] == 0 or lst[j] % lst[i] == 0:\n                pairs.append((lst[i], lst[j]))\n    \n    # Remove duplicates and return the count\n    unique_pairs = set(pairs)\n    return len(unique_pairs)\n```"
  },
  {
    "id":21,
    "response":"```python\ndef increment_numerics(lst, n):\n    \"\"\"\n    প্রদত্ত স্ট্রিং লিস্টের প্রতিটি স্ট্রিংয়ে সংখ্যার মানগুলি k দ্বারা বৃদ্ধি করে।\n    \n    Args:\n        lst: স্ট্রিং এর লিস্ট\n        n: সংখ্যার মান বৃদ্ধি করার জন্য প্রয়োজনীয় সংখ্যা\n    \n    Returns:\n        সংখ্যা বৃদ্ধি করা স্ট্রিং এর লিস্ট\n    \"\"\"\n    result = []\n    for string in lst:\n        # স্ট্রিংয়ের সংখ্যাগুলি খুঁজে পায় এবং তাদের মান k দ্বারা বৃদ্ধি করে\n        new_string = \"\"\n        i = 0\n        while i < len(string):\n            char = string[i]\n            if char.isdigit():\n                # সংখ্যা বৃদ্ধি করা\n                num = int(char)\n                new_num = num + n\n                new_string += str(new_num)\n            else:\n                # অসংখ্যাগুলি অপরিবর্তিত রাখা\n                new_string += char\n            i += 1\n        result.append(new_string)\n    return result\n```"
  },
  {
    "id":22,
    "response":"```python\ndef get_median(lst, lst2, n):\n    \"\"\"\n    Find the median of two sorted arrays of equal size.\n    \n    Args:\n        lst: First sorted array\n        lst2: Second sorted array\n        n: Size of each array (assumed to be equal)\n    \n    Returns:\n        The median of the two arrays\n    \"\"\"\n    # Combine both arrays\n    combined = lst + lst2\n    \n    # Since arrays are sorted, we can find median directly\n    # For even number of elements, median is average of two middle elements\n    if n == 0:\n        return 0\n    \n    # Total elements\n    total = 2 * n\n    \n    # Find middle positions\n    mid1 = n - 1  # first middle element\n    mid2 = n     # second middle element\n    \n    # Get the two middle elements\n    median1 = combined[mid1]\n    median2 = combined[mid2]\n    \n    # For even total length, median is average of two middle elements\n    if total % 2 == 0:\n        return (median1 + median2) \/ 2\n    else:\n        # For odd total length, median is the middle element\n        return combined[n]\n```"
  },
  {
    "id":23,
    "response":"```python\ndef nth_nums(lst, n):\n    \"\"\"\n    ল্যাম্বদা ফাংশন ব্যবহার করে তালিকার প্রতিটি উপাদানের n-তম শক্তি খুঁজে পায়।\n    \n    Args:\n        lst: একটি সংখ্যা বিশিষ্ট তালিকা\n        n: শক্তির মান (পূর্ণসংখ্যা)\n    \n    Returns:\n        প্রতিটি উপাদানের n-তম শক্তি বিশিষ্ট একটি তালিকা\n    \"\"\"\n    return list(map(lambda x: x ** n, lst))\n```"
  },
  {
    "id":24,
    "response":"```python\ndef is_upper(s):\n    \"\"\"\n    Check if all characters in the string are uppercase.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if all characters are uppercase, False otherwise.\n    \"\"\"\n    return s.isupper()\n```"
  },
  {
    "id":25,
    "response":"```python\ndef swap_List(lst):\n    \"\"\"\n    প্রদত্ত তালিকার প্রথম এবং শেষ উপাদান বিনিময় করে।\n    \n    Args:\n        lst: একটি তালিকা (list)\n    \n    Returns:\n        প্রথম এবং শেষ উপাদান বিনিময় করা তালিকা\n    \"\"\"\n    # তালিকা খালি অথবা একটি উপাদান বিশিষ্ট হলে কিছু করা হবে না\n    if len(lst) <= 1:\n        return lst[:]\n    \n    # প্রথম এবং শেষ উপাদান বিনিময় করা\n    lst[0], lst[-1] = lst[-1], lst[0]\n    \n    return lst[:]\n```"
  },
  {
    "id":26,
    "response":"```python\ndef triangle_area(n):\n    \"\"\"\n    Find the area of the largest triangle that can be inscribed in a semicircle of diameter n.\n    \n    The largest triangle inscribed in a semicircle is a right triangle with the hypotenuse\n    as the diameter of the semicircle and the right angle at the circumference.\n    \n    For a semicircle of diameter n, the radius is n\/2.\n    The height of the triangle is equal to the radius (n\/2).\n    The base of the triangle is the diameter (n).\n    \n    Area = (1\/2) * base * height = (1\/2) * n * (n\/2) = n^2 \/ 4\n    \n    Args:\n        n (int or float): Diameter of the semicircle\n        \n    Returns:\n        float: Area of the largest inscribed triangle\n    \"\"\"\n    return (n * n) \/ 4\n```"
  },
  {
    "id":27,
    "response":"```python\ndef find_First_Missing(lst, n, n2):\n    \"\"\"\n    Find the smallest missing positive integer from the given list.\n    \n    Args:\n        lst: List of integers\n        n: First parameter (not used in the function)\n        n2: Second parameter (not used in the function)\n    \n    Returns:\n        The smallest missing positive integer\n    \"\"\"\n    # Remove duplicates and filter positive integers\n    positive_integers = set()\n    for num in lst:\n        if num > 0:\n            positive_integers.add(num)\n    \n    # Start checking from 1\n    missing = 1\n    while missing in positive_integers:\n        missing += 1\n    \n    return missing\n```"
  },
  {
    "id":28,
    "response":"```python\ndef replace_spaces(s):\n    \"\"\"\n    Replace all spaces in the given string with '%20'.\n    \n    Args:\n        s (str): Input string containing spaces\n        \n    Returns:\n        str: String with all spaces replaced by '%20'\n    \"\"\"\n    return s.replace(' ', '%20')\n```"
  },
  {
    "id":29,
    "response":"```python\ndef split(lst):\n    \"\"\"\n    একটি মিশ্র তালিকা থেকে সংখ্যা খুঁজে পাবে।\n    \n    Parameters:\n    lst: মিশ্র তালিকা (যা সংখ্যা এবং অন্যান্য ধরনের ডাটা বিশিষ্ট হতে পারে)\n    \n    Returns:\n    সংখ্যা এর একটি তালিকা\n    \"\"\"\n    result = []\n    for item in lst:\n        if isinstance(item, (int, float)):\n            result.append(item)\n    return result\n```"
  },
  {
    "id":30,
    "response":"```python\ndef get_coordinates(tup):\n    \"\"\"\n    প্রদত্ত সমন্বয় টুপলের সমস্ত সংলগ্ন সমন্বয়গুলি বের করে।\n    \n    সংলগ্ন সমন্বয় মানে হল যে কোন সমন্বয়ের মধ্যে দুটি পৃথক সমন্বয় যারা পরস্পর সংলগ্ন হয়েছে।\n    এখানে সংলগ্ন মানে হল যে দুটি সমন্বয়ের মধ্যে সংখ্যা সমান বা পরস্পর প্রান্তে থাকে।\n    \n    Parameters:\n    tup (tuple): সমন্বয় টুপল।\n    \n    Returns:\n    list: সংলগ্ন সমন্বয়গুলির একটি লিস্ট।\n    \"\"\"\n    if len(tup) <= 1:\n        return []\n    \n    coordinates = []\n    for i in range(len(tup) - 1):\n        # সংলগ্ন সমন্বয় হল প্রতিটি দুটি পরস্পর প্রান্তের মধ্যে সংলগ্ন সমন্বয়\n        # এখানে সংলগ্ন মানে হল যে দুটি সমন্বয়ের মধ্যে সংখ্যা সমান বা �"
  },
  {
    "id":31,
    "response":"```python\nimport re\n\ndef replace_spaces(s):\n    \"\"\"\n    Replace all whitespace characters in a string with an underscore.\n    \n    Args:\n        s (str): The input string\n        \n    Returns:\n        str: String with all whitespace replaced by underscore\n    \"\"\"\n    return re.sub(r'\\s', '_', s)\n```"
  },
  {
    "id":32,
    "response":"```python\ndef move_zero(lst):\n    \"\"\"\n    একটি তালিকা দেওয়া হলে সব শূন্যকে তালিকার শেষে সরায়।\n    \n    Args:\n        lst: একটি সংখ্যা বিশিষ্ট তালিকা (list)\n    \n    Returns:\n        শূন্যগুলি শেষে সরে গেছে তালিকা\n    \"\"\"\n    # শূন্যগুলি সংরক্ষণ করা হবে\n    zeros = []\n    non_zeros = []\n    \n    # তালিকার প্রতিটি উপাদান চেক করা হবে\n    for item in lst:\n        if item == 0:\n            zeros.append(item)\n        else:\n            non_zeros.append(item)\n    \n    # শূন্যগুলি শেষে যোগ করা হবে\n    return non_zeros + zeros\n```"
  },
  {
    "id":33,
    "response":"```python\ndef pair_OR_Sum(lst, n):\n    \"\"\"\n    Find the sum of XOR of all pairs in the given list.\n    \n    Args:\n        lst: List of integers\n        n: Number of elements in the list\n    \n    Returns:\n        Sum of XOR of all pairs\n    \"\"\"\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += lst[i] ^ lst[j]\n    return total_xor_sum\n```"
  },
  {
    "id":34,
    "response":"```python\ndef even_Power_Sum(n):\n    \"\"\"\n    Calculate the sum of the fourth power of the first n even numbers.\n    \n    Args:\n        n (int): The number of even numbers to consider.\n    \n    Returns:\n        int: The sum of the fourth powers of the first n even numbers.\n    \"\"\"\n    total = 0\n    for i in range(n):\n        even_number = 2 * i\n        total += even_number ** 4\n    return total\n```"
  },
  {
    "id":35,
    "response":"```python\nimport heapq\n\ndef heap_sort(lst):\n    \"\"\"\n    Sorts a list in ascending order using heap sort algorithm.\n    The function first converts the list into a min-heap and then\n    repeatedly extracts the smallest element (root) and places it\n    at the end of the list.\n    \n    Args:\n        lst: List of comparable elements\n        \n    Returns:\n        A new list containing the elements in sorted order\n    \"\"\"\n    # Create a min-heap from the list\n    heap = lst[:]\n    heapq.heapify(heap)\n    \n    # Extract elements one by one from the heap\n    sorted_list = []\n    while heap:\n        sorted_list.append(heapq.heappop(heap))\n    \n    return sorted_list\n```"
  },
  {
    "id":36,
    "response":"```python\ndef Check_Solution(n, n2, n3):\n    \"\"\"\n    Check if the roots of a quadrilateral equation are mutually exclusive.\n    \n    Parameters:\n    n, n2, n3: The roots of the quadratic equation.\n    \n    Returns:\n    True if the roots are mutually exclusive (distinct), False otherwise.\n    \"\"\"\n    # Check if any two roots are equal\n    if n == n2 or n == n3 or n2 == n3:\n        return False\n    return True\n```"
  },
  {
    "id":37,
    "response":"```python\ndef noprofit_noloss(n, n2):\n    \"\"\"\n    Check if the given two values are equal, meaning there is no profit and no loss.\n    \n    Args:\n        n: First value (e.g., cost price or selling price)\n        n2: Second value (e.g., selling price or cost price)\n    \n    Returns:\n        True if n equals n2, otherwise False\n    \"\"\"\n    return n == n2\n```"
  },
  {
    "id":38,
    "response":"```python\ndef wind_chill(v, t):\n    \"\"\"\n    বায়ু শীতলতা সূচক (Wind Chill) গণনা করে।\n    \n    সূত্র: \n    W = 35.74 + 0.6215*t - 35.75*(v^0.16) + 0.4275*t*(v^0.16)\n    \n    যেখানে:\n    - v = বায়ুর গতি (mph)\n    - t = তাপমাত্রা (ফারেনহাইট)\n    \n    প্রতিবার প্রয়োজন হলে এই ফাংশনটি ব্যবহার করা যায়।\n    \n    Parameters:\n    v (float): বায়ুর গতি (mph)\n    t (float): তাপমাত্রা (ফারেনহাইট)\n    \n    Returns:\n    float: বায়ু শীতলতা সূচক\n    \"\"\"\n    if v < 3:\n        return t  # বায়ুর গতি 3 mph এর নিচে হলে শীতলতা সূচক তাপমাত্রা হিসেবে নেওয়া হয়\n    \n    wind_chill_value = 35.74 + 0.6215 * t - 35.75 * (v ** 0.16) + 0.4275 * t * (v ** 0.16)\n    return wind_chill_value\n```"
  },
  {
    "id":39,
    "response":"```python\ndef sample_nam(lst):\n    \"\"\"\n    একটি নামের তালিকা থেকে ছোট অক্ষর দিয়ে শুরু হওয়া নামগুলি সরিয়ে দেয় এবং বাকি নামগুলির দৈর্ঘ্যের যোগফল দেয়।\n    \n    Args:\n        lst (list): নামের তালিকা\n        \n    Returns:\n        int: ছোট অক্ষর দিয়ে শুরু হয়নি নামগুলির দৈর্ঘ্যের যোগফল\n    \"\"\"\n    total_length = 0\n    for name in lst:\n        if name and name[0].isupper():  # ছোট অক্ষর দিয়ে শুরু হয়নি (উপরের অক্ষর দিয়ে শুরু হয়)\n            total_length += len(name)\n    return total_length\n```"
  },
  {
    "id":40,
    "response":"```python\ndef remove_parenthesis(s):\n    \"\"\"\n    একটি স্ট্রিংয়ে বন্ধনী এলাকা অপসারণ করে ফেরত দেয়।\n    \n    Args:\n        s (str): বন্ধনী বিশিষ্ট স্ট্রিং\n        \n    Returns:\n        str: বন্ধনী এলাকা অপসারিত স্ট্রিং\n    \"\"\"\n    result = []\n    in_parentheses = False\n    \n    for char in s:\n        if char == '(':\n            in_parentheses = True\n        elif char == ')':\n            in_parentheses = False\n        elif not in_parentheses:\n            result.append(char)\n    \n    return ''.join(result)\n```"
  },
  {
    "id":41,
    "response":"```python\ndef is_nonagonal(n):\n    \"\"\"\n    Check if a number n is a nonagonal number.\n    \n    A nonagonal number is a number that can be represented in the form:\n    N_k = k(7k - 5) \/ 2 for k = 1, 2, 3, ...\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is a nonagonal number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Solve the quadratic equation: k(7k - 5) \/ 2 = n\n    # 7k^2 - 5k - 2n = 0\n    # Using quadratic formula: k = (5 + sqrt(25 + 56n)) \/ 14\n    \n    discriminant = 25 + 56 * n\n    if discriminant < 0:\n        return False\n    \n    sqrt_discriminant = int(discriminant ** 0.5)\n    if sqrt_discriminant * sqrt_discriminant != discriminant:\n        return False\n    \n    # Check if (5 + sqrt(25 + 56n)) is divisible by 14\n    k = (5 + sqrt_discriminant) \/ 14\n    return k > 0 and k == int(k)\n```"
  },
  {
    "id":42,
    "response":"```python\ndef remove_similar_row(lst):\n    \"\"\"\n    Remove duplicate rows from a list of tuples (matrix).\n    \n    Args:\n        lst: List of tuples representing rows of a matrix\n        \n    Returns:\n        List of tuples with duplicate rows removed (preserving first occurrence)\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for row in lst:\n        # Convert tuple to hashable form for set operations\n        row_tuple = tuple(row)\n        if row_tuple not in seen:\n            seen.add(row_tuple)\n            result.append(row)\n    \n    return result\n```"
  },
  {
    "id":43,
    "response":"```python\ndef text_match_wordz_middle(s):\n    \"\"\"\n    Check if any word in the string has 'z' in the middle (not at the beginning or end).\n    \n    Args:\n        s (str): Input string to check\n        \n    Returns:\n        bool: True if there's a word with 'z' in the middle, False otherwise\n    \"\"\"\n    # Split the string into words\n    words = s.split()\n    \n    for word in words:\n        # Remove punctuation and convert to lowercase for consistent checking\n        cleaned_word = ''.join(char for char in word if char.isalnum()).lower()\n        \n        # Check if word has at least 3 characters and 'z' is not at start or end\n        if len(cleaned_word) >= 3:\n            if 'z' in cleaned_word:\n                z_index = cleaned_word.index('z')\n                # Check if 'z' is not at the beginning (index 0) or end (index -1)\n                if not (z_index == 0 or z_index == len(cleaned_word) - 1):\n                    return True\n    \n    return False\n```"
  },
  {
    "id":44,
    "response":"```python\ndef reverse_Array_Upto_K(lst, n):\n    \"\"\"\n    Reverse the array up to index n (inclusive).\n    \n    Args:\n        lst: List of elements to be reversed up to index n\n        n: The index up to which the array should be reversed (inclusive)\n    \n    Returns:\n        A new list with elements reversed up to index n\n    \"\"\"\n    # Create a copy of the list to avoid modifying the original\n    result = lst.copy()\n    \n    # Reverse the elements from start to index n (inclusive)\n    left = 0\n    right = n\n    \n    while left < right:\n        result[left], result[right] = result[right], result[left]\n        left += 1\n        right -= 1\n    \n    return result\n```"
  },
  {
    "id":45,
    "response":"```python\ndef find_k_product(lst, k):\n    \"\"\"\n    Find the product of the kth element from each tuple in the list.\n    \n    Args:\n        lst: A list of tuples\n        k: The index (0-based) of the element to extract from each tuple\n    \n    Returns:\n        The product of the kth elements from each tuple\n    \n    Raises:\n        IndexError: If k is out of range for any tuple\n    \"\"\"\n    product = 1\n    for tup in lst:\n        if k < len(tup):\n            product *= tup[k]\n        else:\n            raise IndexError(f\"Index {k} is out of range for tuple {tup}\")\n    return product\n```"
  },
  {
    "id":46,
    "response":"```python\ndef no_of_cubes(n, k):\n    \"\"\"\n    Calculate the number of k-sized cubes that can fit inside an n-sized cube.\n    \n    Args:\n        n (int): The side length of the larger cube\n        k (int): The side length of the smaller cube\n    \n    Returns:\n        int: The number of k-sized cubes that can fit inside the n-sized cube\n    \n    Example:\n        no_of_cubes(5, 2) returns 125 (5\/\/2 = 2, so 2^3 = 8, but actually it's (n\/\/k)^3)\n    \"\"\"\n    if k > n:\n        return 0\n    \n    # Number of k-sized cubes that fit along one edge\n    fit_per_edge = n \/\/ k\n    \n    # Total number of k-sized cubes that fit in the n-sized cube\n    return fit_per_edge ** 3\n```"
  },
  {
    "id":47,
    "response":"```python\ndef split_upperstring(s):\n    \"\"\"\n    একটি স্ট্রিংকে বড় অক্ষরে বিভক্ত করে ফেরত দেয়।\n    \n    Args:\n        s (str): বিভক্ত করার জন্য দেয়া স্ট্রিং\n        \n    Returns:\n        list: বড় অক্ষরে বিভক্ত করা স্ট্রিং এর তালিকা\n    \"\"\"\n    result = []\n    current_word = \"\"\n    \n    for char in s:\n        if char.isupper():\n            if current_word:\n                result.append(current_word)\n                current_word = \"\"\n            current_word += char\n        else:\n            current_word += char\n    \n    if current_word:\n        result.append(current_word)\n    \n    return result\n```"
  },
  {
    "id":48,
    "response":"```python\ndef exchange_elements(lst):\n    \"\"\"\n    Exchange elements at positions n and n+1 in a list.\n    For each n, swap the element at index n with the element at index n+1.\n    \n    Args:\n        lst: List of elements\n        \n    Returns:\n        Modified list with elements swapped in pairs\n    \"\"\"\n    # Create a copy to avoid modifying the original list\n    result = lst.copy()\n    \n    # Iterate through the list, swapping elements at positions n and n+1\n    for i in range(len(result) - 1):\n        result[i], result[i + 1] = result[i + 1], result[i]\n    \n    return result\n```"
  },
  {
    "id":49,
    "response":"```python\ndef sum_range_list(lst, n, n2):\n    \"\"\"\n    একটি তালিকার নির্দিষ্ট পরিসরের সূচকের মধ্যে সংখ্যার যোগফল গণনা করে।\n    \n    Parameters:\n    lst (list): তালিকা\n    n (int): প্রারম্ভিক সূচক (0 থেকে শুরু)\n    n2 (int): শেষ সূচক (শেষ সূচক অন্তর্ভুক্ত)\n    \n    Returns:\n    int: পরিসরের মধ্যে সংখ্যার যোগফল\n    \"\"\"\n    # সূচকগুলি পরিশোধিত করা হয়েছে (নেগেটিভ সূচক বা অসম্ভব সূচক হলে কাজ করে না)\n    if n < 0 or n2 < 0 or n > len(lst) or n2 > len(lst):\n        return 0\n    \n    # পরিসরের মধ্যে সংখ্যার যোগফল গণনা করা হয়\n    total = 0\n    for i in range(n, n2 + 1):\n        total += lst[i]\n    \n    return total\n```"
  },
  {
    "id":50,
    "response":"```python\ndef are_equal(lst, lst2, n, n2):\n    \"\"\"\n    Check if two lists are equal.\n    \n    Args:\n        lst: First list to compare\n        lst2: Second list to compare\n        n: Length of first list\n        n2: Length of second list\n    \n    Returns:\n        True if both lists are equal in length and contain the same elements,\n        False otherwise\n    \"\"\"\n    # Check if lengths are equal\n    if n != n2:\n        return False\n    \n    # Check if elements are the same\n    for i in range(n):\n        if lst[i] != lst2[i]:\n            return False\n    \n    return True\n```"
  },
  {
    "id":51,
    "response":"```python\ndef check_subset(tup, tup2):\n    \"\"\"\n    Check if the first tuple is a subset of the second tuple.\n    \n    Args:\n        tup: The tuple to check if it's a subset.\n        tup2: The tuple to check against.\n    \n    Returns:\n        bool: True if tup is a subset of tup2, False otherwise.\n    \"\"\"\n    # Convert tuples to sets and check if the first set is a subset of the second\n    return set(tup).issubset(set(tup2))\n```"
  },
  {
    "id":52,
    "response":"```python\ndef matrix_to_list(matrix):\n    \"\"\"\n    Convert a tuple matrix (list of tuples) to a flat tuple list where each tuple\n    represents a column of the original matrix.\n    \n    Args:\n        matrix: A tuple of tuples, where each inner tuple represents a row.\n    \n    Returns:\n        A tuple of tuples, where each inner tuple represents a column of the original matrix.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return ()\n    \n    # Get the number of rows\n    num_rows = len(matrix)\n    # Get the number of columns\n    num_cols = len(matrix[0])\n    \n    # Create a list to hold the columns\n    columns = []\n    \n    # For each column index\n    for col in range(num_cols):\n        column = ()\n        # For each row, extract the element at the current column\n        for row in range(num_rows):\n            column += (matrix[row][col],)\n        columns.append(column)\n    \n    return tuple(columns)\n```"
  },
  {
    "id":53,
    "response":"```python\ndef grouping_dictionary(lst):\n    \"\"\"\n    একটি কী-মান জোড়ার ক্রমকে একটি তালিকার অভিধানে গোষ্ঠীভুক্ত করে।\n    \n    Parameters:\n    lst (list of tuples): কী-মান জোড়ার ক্রমে দেওয়া হয়েছে।\n    \n    Returns:\n    dict: কী হিসেবে তালিকা এবং মান হিসেবে মান সংরক্ষণ করা হয়।\n    \"\"\"\n    result = {}\n    for key, value in lst:\n        if key not in result:\n            result[key] = []\n        result[key].append(value)\n    return result\n```"
  },
  {
    "id":54,
    "response":"```python\ndef rectangle_perimeter(n, n2):\n    \"\"\"\n    একটি আয়তক্ষেত্রের পরিধি বের করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    n (int): আয়তক্ষেত্রের দৈর্ঘ্য\n    n2 (int): আয়তক্ষেত্রের প্রস্থ\n    \n    রিটার্ন:\n    int: আয়তক্ষেত্রের পরিধি (2 * (দৈর্ঘ্য + প্রস্থ))\n    \"\"\"\n    return 2 * (n + n2)\n```"
  },
  {
    "id":55,
    "response":"```python\ndef fifth_Power_Sum(n):\n    \"\"\"\n    Calculate the sum of the fifth powers of the first n natural numbers.\n    \n    Args:\n        n (int): The number of natural numbers to consider (1 to n).\n    \n    Returns:\n        int: The sum of 1^5 + 2^5 + 3^5 + ... + n^5.\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total += i ** 5\n    return total\n```"
  },
  {
    "id":56,
    "response":"```python\ndef find_Min_Sum(lst, lst2, n):\n    \"\"\"\n    Find the minimum sum of absolute differences between elements of two arrays.\n    \n    Args:\n        lst: First list of integers\n        lst2: Second list of integers\n        n: Length of each list\n    \n    Returns:\n        Minimum sum of absolute differences\n    \"\"\"\n    # Sort both arrays to minimize the sum of absolute differences\n    lst.sort()\n    lst2.sort()\n    \n    min_sum = 0\n    \n    # Pair elements from both arrays to minimize absolute differences\n    for i in range(n):\n        min_sum += abs(lst[i] - lst2[i])\n    \n    return min_sum\n```"
  },
  {
    "id":57,
    "response":"```python\ndef first_digit(n):\n    \"\"\"\n    Return the first digit of the factorial of n.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The first digit of n!\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    \n    if n == 0 or n == 1:\n        return 1\n    \n    # Calculate factorial\n    factorial = 1\n    for i in range(2, n + 1):\n        factorial *= i\n    \n    # Convert to string and return first digit\n    return int(str(factorial)[0])\n```"
  },
  {
    "id":58,
    "response":"```python\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item that appears most frequently in the list.\n    \n    Args:\n        lst: A list of items (can be integers, strings, etc.)\n    \n    Returns:\n        The item that occurs the maximum number of times.\n        If there are multiple items with the same maximum frequency,\n        returns the first one encountered.\n    \"\"\"\n    if not lst:\n        return None\n    \n    # Count frequency of each item\n    freq_map = {}\n    for item in lst:\n        freq_map[item] = freq_map.get(item, 0) + 1\n    \n    # Find the item with maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in freq_map.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item\n```"
  },
  {
    "id":59,
    "response":"```python\ndef repeat(lst):\n    \"\"\"\n    পূর্ণসংখ্যার তালিকা থেকে ডুপ্লিকেট মুদ্রণ করে।\n    \n    এই ফাংশনটি একটি তালিকার মধ্যে পুনরাবৃত্ত হওয়া পূর্ণসংখ্যাগুলি প্রদর্শন করে।\n    \n    উদাহরণ:\n    repeat([1, 2, 2, 3, 4, 4, 5]) -> [2, 4]\n    \"\"\"\n    seen = set()\n    duplicates = []\n    \n    for item in lst:\n        if item in seen:\n            if item not in duplicates:\n                duplicates.append(item)\n        else:\n            seen.add(item)\n    \n    return duplicates\n```"
  },
  {
    "id":60,
    "response":"```python\ndef find_Points(n, n2, n3, n4):\n    \"\"\"\n    দুটি রেঞ্জের মধ্যে থেকে পয়েন্ট নির্বাচন করে যাতে উভয় রেঞ্জের মধ্যে কোন পয়েন্ট থাকে না।\n    \n    Parameters:\n    n, n2: প্রথম রেঞ্জের শুরু ও শেষ মান (n থেকে n2 পর্যন্ত)\n    n3, n4: দ্বিতীয় রেঞ্জের শুরু ও শেষ মান (n3 থেকে n4 পর্যন্ত)\n    \n    Returns:\n    যে পয়েন্টগুলি উভয় রেঞ্জের মধ্যে থাকে না (যারা কোন রেঞ্জে নেই)\n    \"\"\"\n    # প্রথম রেঞ্জের মধ্যে থাকা পয়েন্টগুলি\n    range1 = set(range(n, n2 + 1))\n    \n    # দ্বিতীয় রেঞ্জের মধ্যে থাকা পয়েন্টগুলি\n    range2 = set(range(n3, n4 + 1))\n    \n    # উভয় রেঞ্জের মধ্যে থাকা পয়েন্টগুলি (সামান্য পয়েন্ট)\n    intersection = range1.intersection(range2)\n    \n    #"
  },
  {
    "id":61,
    "response":"```python\ndef max_sum_of_three_consecutive(lst, n):\n    \"\"\"\n    Find the maximum sum of three consecutive elements in the list.\n    \n    Args:\n        lst: List of integers\n        n: Length of the list\n    \n    Returns:\n        Maximum sum of three consecutive elements, or None if not possible\n    \"\"\"\n    if n < 3:\n        return None\n    \n    max_sum = float('-inf')\n    \n    # Check all possible triplets of consecutive elements\n    for i in range(n - 2):\n        current_sum = lst[i] + lst[i + 1] + lst[i + 2]\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum if max_sum != float('-inf') else None\n```"
  },
  {
    "id":62,
    "response":"```python\ndef sorted_dict(dct):\n    \"\"\"\n    একটি অভিধানের কী-ভারিয়েবলগুলি বাছাই করে একটি নতুন অভিধান তৈরি করে।\n    \n    Args:\n        dct (dict): বাছাই করার জন্য অভিধান\n        \n    Returns:\n        dict: কী বাছাই করে তৈরি করা অভিধান\n    \"\"\"\n    return dict(sorted(dct.items()))\n```"
  },
  {
    "id":63,
    "response":"```python\ndef find_max_val(n, n2, n3):\n    \"\"\"\n    Find the maximum possible value of k such that k mod x = y.\n    Here, x = n, y = n2, and we're looking for k such that k mod n = n2.\n    \n    Note: For k mod n = n2 to be valid, we must have 0 <= n2 < n.\n    If n2 >= n, then no such k exists, and we return None.\n    \n    However, based on the example, it seems like we're looking for the maximum k\n    such that k mod n = n2. The general solution is:\n    k = n2 + m*n for any integer m >= 0.\n    The maximum value of k is unbounded unless there's a constraint.\n    \n    Since the problem asks for the \"maximum possible value\" and no upper bound is given,\n    we interpret it as finding the maximum k that satisfies the condition within a reasonable\n    range, or if no such k exists due to invalid y, return None.\n    \n    But if the problem means to find the maximum k such that k mod n = n2 and k <= n3,\n    then we can find the maximum k in that range.\n    \n    Given the example: find_max_val(n, n2, n3), we assume:\n    Find the maximum k <= n3 such that k mod n = n2.\n    \n    If no such k exists (n2 >= n), return None.\n    Otherwise, the maximum k is the largest number <= n3 such that k ≡ n2 (mod n).\n    This is: k = n2 + n * floor((n3 - n2) \/ n) if (n3 - n2) >= 0, else None.\n    But if n2 >= n, no such k exists.\n    \n    So the algorithm:\n    1. If n2 >= n: return None\n    2. If n2 > n3: return None (no k <= n3 satisfies k mod n = n2)\n    3. Otherwise, the maximum k is: n2 + n * ((n3 - n2) \/\/ n)\n    \n    However, note that k mod n = n2 implies k = n2 + m*n for some integer m >= 0.\n    We want the largest such k <= n3.\n    So m = floor((n3 - n2)"
  },
  {
    "id":64,
    "response":"```python\ndef average_Even(n):\n    \"\"\"\n    নির্দিষ্ট সংখ্যার মধ্যবর্তী সংখ্যার গড় খুঁজে বের করে।\n    \n    এই ফাংশনটি 0 থেকে n এর মধ্যে সব জোড় সংখ্যার গড় বের করে।\n    \n    Parameters:\n    n (int): সংখ্যা (0 থেকে n এর মধ্যে)\n    \n    Returns:\n    float: জোড় সংখ্যার গড়\n    \"\"\"\n    if n < 0:\n        return 0.0\n    \n    even_numbers = []\n    for i in range(0, n + 1, 2):\n        even_numbers.append(i)\n    \n    if not even_numbers:\n        return 0.0\n    \n    return sum(even_numbers) \/ len(even_numbers)\n```"
  },
  {
    "id":65,
    "response":"```python\ndef move_last(lst):\n    \"\"\"\n    Move the last element of the list to the beginning.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A new list with the last element moved to the front\n    \"\"\"\n    if not lst:  # Handle empty list\n        return lst\n    \n    last_element = lst[-1]\n    return [last_element] + lst[:-1]\n```"
  },
  {
    "id":66,
    "response":"```python\ndef count_char(s, s2):\n    \"\"\"\n    একটি স্ট্রিংয়ে অক্ষরের উপস্থিতি গণনা করে।\n    \n    Parameters:\n    s (str): অক্ষরগুলি গণনা করার জন্য স্ট্রিং\n    s2 (str): যে অক্ষরগুলির উপস্থিতি গণনা করা হবে\n    \n    Returns:\n    dict: প্রতিটি অক্ষরের উপস্থিতি গণনা করে প্রদান করে\n    \"\"\"\n    char_count = {}\n    for char in s2:\n        if char in s:\n            char_count[char] = s.count(char)\n        else:\n            char_count[char] = 0\n    return char_count\n```"
  },
  {
    "id":67,
    "response":"```python\ndef count_vowels(s):\n    \"\"\"\n    স্ট্রিংয়ে স্বরবর্ণের সংখ্যা গণনা করে।\n    \n    Parameters:\n    s (str): স্ট্রিং যেখানে স্বরবর্ণ গণনা করা হবে\n    \n    Returns:\n    int: স্বরবর্ণের সংখ্যা\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count\n\n# নোট: আপনি যদি একটি ফাংশন বানাতে চান যা দুটি স্ট্রিং নিয়ে কাজ করে যেমন Check_Vow(s, s2)\n# তবে এখানে তা হিসাবে ব্যবহার করা হয়নি কারণ প্রদত্ত উদাহরণে এটি প্রয়োজনীয় না হয়েছে।\n# তাই সহজ স্ট্রিং এর জন্য একটি ফাংশন দেওয়া হয়েছে।\n```"
  },
  {
    "id":68,
    "response":"```python\ndef replace(s, s2):\n    \"\"\"\n    Replace each character in string s with the corresponding character in s2.\n    If s2 is shorter than s, the remaining characters in s are left unchanged.\n    If s2 is longer than s, only the first len(s) characters are used.\n    \n    Args:\n        s (str): The input string to be processed\n        s2 (str): The replacement string\n    \n    Returns:\n        str: The resulting string after replacement\n    \"\"\"\n    if not s:\n        return \"\"\n    \n    # Ensure s2 is at least as long as s\n    s2 = s2[:len(s)]\n    \n    result = \"\"\n    for i, char in enumerate(s):\n        if i < len(s2):\n            result += s2[i]\n        else:\n            result += char\n    \n    return result\n```"
  },
  {
    "id":69,
    "response":"```python\nimport re\n\ndef check_IP(s):\n    \"\"\"\n    রেজেক্স ব্যবহার করে প্রদত্ত আইপি ঠিকানাটি বৈধ কিনা তা পরীক্ষা করে।\n    \n    Args:\n        s (str): আইপি ঠিকানা স্ট্রিং\n        \n    Returns:\n        bool: যদি আইপি ঠিকানা বৈধ হয় তবে True, না হয় তবে False\n    \"\"\"\n    # একটি বৈধ আইপি ঠিকানা হওয়ার জন্য নিম্নলিখিত নিয়ম অনুসরণ করে:\n    # 1. চারটি সংখ্যা যা 0-255 এর মধ্যে হবে\n    # 2. সংখ্যাগুলি দ্বারা সেপারেট হবে দুটি বা তিনটি ডট (.) দ্বারা\n    # 3. প্রতিটি সংখ্যা শূন্য হতে শুরু করে এবং সব সংখ্যা 255 এর চেয়ে বড় হবে না\n    \n    pattern = r'^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$'\n    \n    # প্রথমে প্যাটার্ন ম্যাচ করা\n    if not re.match(pattern, s):\n        return False"
  },
  {
    "id":70,
    "response":"```python\ndef decreasing_trend(lst):\n    \"\"\"\n    Check if a list of numbers is in decreasing trend.\n    \n    Args:\n        lst: A list of numbers\n        \n    Returns:\n        True if the list is in decreasing trend, False otherwise\n    \"\"\"\n    # A list with less than 2 elements cannot have a decreasing trend\n    if len(lst) <= 1:\n        return True\n    \n    # Check if each element is greater than the next one\n    for i in range(len(lst) - 1):\n        if lst[i] <= lst[i + 1]:\n            return False\n    \n    return True\n```"
  },
  {
    "id":71,
    "response":"```python\ndef set_right_most_unset_bit(n):\n    \"\"\"\n    ডানদিকে সবচেয়ে বেশি বিট সেট না করার জন্য একটি পাইথন ফাংশন।\n    এই ফাংশনটি প্রদত্ত সংখ্যার ডানদিকে সবচেয়ে বেশি বিট সেট না করে সেট করে।\n    যদি সব বিট সেট থাকে (যেমন 7 = 111), তবে এটি পুনরায় সেট করে সব বিট সেট হওয়ার পরেও কাজ করে।\n    \n    উদাহরণ:\n    set_right_most_unset_bit(7) -> 111 -> 1111 (বা 15)\n    কিন্তু সঠীক অর্থ হল ডানদিকে সবচেয়ে বেশি বিট সেট না করা।\n    \n    সত্য হল, এই অর্থে আমাদের কাজ হল ডানদিকে সবচেয়ে বেশি বিট সেট না করা মানে যদি কোন বিট অসেট হয় তবে সেট করা।\n    \n    এটি প্রায় একটি বিট অপারেশনের মাধ্যমে করা হয়:\n    �"
  },
  {
    "id":72,
    "response":"```python\ndef max_of_three(n, n2, n3):\n    \"\"\"\n    তিনটি সংখ্যার মধ্যে সর্বোচ্চ সংখ্যা প্রদান করে।\n    \n    Parameters:\n    n, n2, n3: তিনটি সংখ্যা\n    \n    Returns:\n    সর্বোচ্চ সংখ্যা\n    \"\"\"\n    return max(n, n2, n3)\n```"
  },
  {
    "id":73,
    "response":"```python\ndef convert(lst):\n    \"\"\"\n    Convert a list of integers into a single integer by concatenating them.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        A single integer formed by concatenating the integers in the list\n    \"\"\"\n    result = \"\"\n    for num in lst:\n        result += str(num)\n    return int(result)\n```"
  },
  {
    "id":74,
    "response":"```python\ndef remove_duplicate(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিং থেকে ডুপ্লিকেট শব্দ অপসারণ করে।\n    এটি শব্দগুলি স্ট্রিং এর প্রতিটি শব্দের আকারে প্রতিটি শব্দ একবার মাত্র রাখে।\n    \n    Args:\n        s (str): প্রদত্ত স্ট্রিং\n        \n    Returns:\n        str: ডুপ্লিকেট শব্দ অপসারণ করা স্ট্রিং\n    \"\"\"\n    # শব্দগুলি সেটে রাখে যাতে ডুপ্লিকেট না হয়\n    words = s.split()\n    unique_words = list(set(words))\n    \n    # শব্দগুলি আবার স্ট্রিং এ ফেরত আসে এমন করে\n    return ' '.join(unique_words)\n```"
  },
  {
    "id":75,
    "response":"```python\ndef sum_nums(n, n2, n3, n4):\n    \"\"\"\n    দুটি পূর্ণসংখ্যার যোগ করে ফেরত দেয়।\n    যদি যোগফল প্রদত্ত পরিসরের মধ্যে থাকে তবে 20 প্রদান করে।\n    \n    Parameters:\n    n, n2, n3, n4: পূর্ণসংখ্যা মান\n    \n    Returns:\n    যোগফল বা 20 (যদি যোগফল পরিসরের মধ্যে থাকে)\n    \"\"\"\n    # দুটি পূর্ণসংখ্যা নির্বাচন করা হয়েছে তাই আমরা মান নিচ্ছি\n    # যদি প্রদত্ত পরিসর না দেওয়া হয়, তবে কোন পরিসর নেই তাই কোন নির্দেশ নেই\n    # তাই আমরা কেবল যোগ করব\n    total = n + n2\n    \n    # পরিসর না দেওয়া হয়েছে, তাই আমরা ধরব যে যোগফল কোন পরিসরে থাকে না\n    # তাই আমরা সরাসরি 20 প্রদান করব\n    return 20\n```"
  },
  {
    "id":76,
    "response":"```python\nimport re\n\ndef remove_extra_char(s):\n    \"\"\"\n    Remove all non-alphanumeric characters from the given string.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: String containing only alphanumeric characters\n    \"\"\"\n    return re.sub(r'[^a-zA-Z0-9]', '', s)\n```"
  },
  {
    "id":77,
    "response":"```python\ndef validity_triangle(n, n2, n3):\n    \"\"\"\n    ত্রিভুজের বৈধতা পরীক্ষা করে।\n    \n    ত্রিভুজের বৈধতা হল তিনটি বাহুর দৈর্ঘ্যের মধ্যে যে কোন দুটি বাহুর যোগফল তৃতীয় বাহুর দৈর্ঘ্যের চেয়ে বড় হতে হবে।\n    \n    Parameters:\n    n, n2, n3 (float): ত্রিভুজের তিনটি বাহুর দৈর্ঘ্য\n    \n    Returns:\n    bool: ত্রিভুজ বৈধ হলে True, না হলে False\n    \"\"\"\n    # বাহুর দৈর্ঘ্য নেতে হবে নেতে হবে সকল পজিটিভ হওয়া প্রয়োজন\n    if n <= 0 or n2 <= 0 or n3 <= 0:\n        return False\n    \n    # ত্রিভুজের বৈধতা নিয়ম: যেকোন দুটি বাহুর যোগফল তৃতীয় বাহুর চেয়ে বড় হতে হবে\n    return (n + n2 > n3) and (n + n3 > n2) and (n2 + n3 > n)\n```"
  },
  {
    "id":78,
    "response":"```python\ndef remove_spaces(s):\n    \"\"\"\n    একটি প্রদত্ত স্ট্রিং থেকে স্পেস অপসারণের জন্য একটি ফাংশন।\n    \n    Args:\n        s (str): স্পেস অপসারণের জন্য দেওয়া স্ট্রিং\n        \n    Returns:\n        str: স্পেস বিহীন স্ট্রিং\n    \"\"\"\n    return s.replace(\" \", \"\")\n```"
  },
  {
    "id":79,
    "response":"```python\ndef access_key(dct, n):\n    \"\"\"\n    ডিকশনারির কী এর উপাদানগুলিকে সূচক অনুসারে অ্যাক্সেস করে।\n    \n    প্যারামিটার:\n    dct (dict): ডিকশনারি যার কী এর উপাদানগুলি অ্যাক্সেস করা হবে\n    n (int): সূচক যা কী এর সূচক হিসেবে ব্যবহার হবে\n    \n    রিটার্ন:\n    কী এর মান যদি সূচক অনুসারে উপস্থিত থাকে, অন্যথায় None\n    \"\"\"\n    if n < 0 or n >= len(dct):\n        return None\n    keys = list(dct.keys())\n    if n < len(keys):\n        return dct[keys[n]]\n    return None\n```"
  },
  {
    "id":80,
    "response":"```python\ndef increasing_trend(lst):\n    \"\"\"\n    Check if a list of numbers is in an increasing trend.\n    \n    Args:\n        lst: A list of numbers\n        \n    Returns:\n        True if the list is in increasing trend (each element is strictly greater than the previous one),\n        False otherwise.\n    \"\"\"\n    if len(lst) <= 1:\n        return True\n    \n    for i in range(1, len(lst)):\n        if lst[i] <= lst[i-1]:\n            return False\n    \n    return True\n```"
  },
  {
    "id":81,
    "response":"```python\ndef smallest_divisor(n):\n    \"\"\"\n    একটি সংখ্যার ক্ষুদ্রতম অক্ষরের বিভাজক খুঁজে বের করে।\n    \n    Parameters:\n    n (int): বিভাজক খুঁজে বের করার জন্য সংখ্যা।\n    \n    Returns:\n    int: ক্ষুদ্রতম অক্ষরের বিভাজক।\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    # 2 থেকে শুরু করে প্রথম বিভাজক খুঁজে বের করা\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return i\n    \n    # যদি কোনো বিভাজক না পায়, তবে সংখ্যাটি প্রাইম\n    return n\n```"
  },
  {
    "id":82,
    "response":"```python\ndef mul_list(lst, lst2):\n    \"\"\"\n    দুটি তালিকা গুণ করে একটি নতুন তালিকা তৈরি করে।\n    এটি ল্যাম্বদা ফাংশন এবং মানচিত্র (map) ব্যবহার করে।\n    \n    Args:\n        lst: প্রথম তালিকা\n        lst2: দ্বিতীয় তালিকা\n    \n    Returns:\n        দুটি তালিকার সংশ্লিষ্ট উপাদানগুলির গুণফলের তালিকা\n    \"\"\"\n    return list(map(lambda x, y: x * y, lst, lst2))\n```"
  },
  {
    "id":83,
    "response":"```python\ndef sum_square(n):\n    \"\"\"\n    Check if a given number can be expressed as the sum of two squares.\n    \n    Args:\n        n (int): The number to check.\n    \n    Returns:\n        bool: True if n can be expressed as the sum of two squares, False otherwise.\n    \"\"\"\n    # Iterate through all possible values of i such that i^2 <= n\n    for i in range(int(n**0.5) + 1):\n        j_squared = n - i*i\n        j = int(j_squared**0.5)\n        # Check if j_squared is a perfect square\n        if j * j == j_squared:\n            return True\n    return False\n```"
  },
  {
    "id":84,
    "response":"```python\ndef count_Char(s, s2):\n    \"\"\"\n    একটি পুনরাবৃত্ত স্ট্রিংয়ে অক্ষরের উপস্থিতি গণনা করে।\n    \n    প্যারামিটার:\n    s (str): অক্ষর গণনা করার জন্য ব্যবহার করা হবে এই স্ট্রিং।\n    s2 (str): পুনরাবৃত্ত স্ট্রিং। যেখানে অক্ষরগুলি উপস্থিতি চেক হবে।\n    \n    রিটার্ন:\n    dict: প্রতিটি অক্ষরের উপস্থিতি গণনা করে প্রদান করে।\n    \"\"\"\n    char_count = {}\n    \n    # s2 এর প্রতিটি অক্ষর গণনা করা হবে\n    for char in s2:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # s এর অক্ষরগুলি যদি s2 এ উপস্থিত থাকে তবে তাদের গণনা করা হবে\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    return char_count\n```"
  },
  {
    "id":85,
    "response":"```python\ndef sum_of_primes(n):\n    \"\"\"\n    Calculate the sum of all prime numbers from 1 to n (inclusive).\n    \n    Args:\n        n (int): The upper limit (inclusive)\n    \n    Returns:\n        int: Sum of all prime numbers from 1 to n\n    \"\"\"\n    if n < 2:\n        return 0\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num ** 0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    prime_sum = 0\n    for num in range(2, n + 1):\n        if is_prime(num):\n            prime_sum += num\n    \n    return prime_sum\n```"
  },
  {
    "id":86,
    "response":"```python\ndef freq_element(tup):\n    \"\"\"\n    Calculate the frequency of each element in the given tuple.\n    \n    Args:\n        tup: A tuple containing elements (can be of any hashable type)\n    \n    Returns:\n        A dictionary where keys are the elements from the tuple and values are their frequencies\n    \"\"\"\n    freq = {}\n    for element in tup:\n        freq[element] = freq.get(element, 0) + 1\n    return freq\n```"
  },
  {
    "id":87,
    "response":"```python\ndef recur_gcd(n, n2):\n    \"\"\"\n    পুনরাবৃত্তি ব্যবহার করে দুটি পূর্ণসংখ্যার বৃহত্তম সাধারণ বিভাজক (GCD) খুঁজে বের করে।\n    \n    প্রয়োজনীয় সূত্র: gcd(a, b) = gcd(b, a % b)\n    যখন b == 0 হয় তখন gcd(a, 0) = a\n    \n    প্যারামিটার:\n    n: প্রথম পূর্ণসংখ্যা\n    n2: দ্বিতীয় পূর্ণসংখ্যা\n    \n    রিটার্ন:\n    দুটি সংখ্যার বৃহত্তম সাধারণ বিভাজক\n    \"\"\"\n    if n2 == 0:\n        return n\n    else:\n        return recur_gcd(n2, n % n2)\n```"
  },
  {
    "id":88,
    "response":"```python\ndef len_complex(n, n2):\n    \"\"\"\n    জটিল সংখ্যার দৈর্ঘ্য পেতে একটি ফাংশন।\n    এখানে n এবং n2 হল জটিল সংখ্যা যারা সাধারণত দুটি বাস্তব সংখ্যা (প্রকৃত এবং কাল্পনিক) দ্বারা প্রকাশ করা হয়।\n    জটিল সংখ্যার দৈর্ঘ্য হল এর মান অর্থাৎ sqrt(real^2 + imaginary^2)।\n    \n    এই ফাংশন দুটি জটিল সংখ্যা নেয় এবং তাদের দৈর্ঘ্য ক্যালকুলেট করে।\n    \"\"\"\n    # ধরা যাক n = a + bi এবং n2 = c + di\n    # জটিল সংখ্যার দৈর্ঘ্য = sqrt(a^2 + b^2)\n    \n    # ধরা যাক n এবং n2 হল জটিল সংখ্যা যারা প্রতিটি ক্ষেত্রে বাস্তব এবং কাল্পনিক অংশ বিশিষ্ট\n    # এখানে আমরা ধরে নিচ্ছি যে এগুলো বাস্তব এবং কাল্পনিক অংশ �"
  },
  {
    "id":89,
    "response":"```python\ndef min_jumps(lst, n):\n    \"\"\"\n    Find the minimum number of jumps needed to reach the end of the array.\n    \n    Args:\n        lst: List of integers representing the maximum jump length from each index.\n        n: Length of the array.\n    \n    Returns:\n        Minimum number of jumps required to reach the end, or -1 if impossible.\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    if lst[0] == 0:\n        return -1\n    \n    jumps = 1  # We need at least one jump to start\n    current_reach = lst[0]  # Maximum index we can reach with current number of jumps\n    next_reach = 0  # Maximum index we can reach with next jump\n    \n    # Start from index 1 to n-1\n    for i in range(1, n - 1):\n        # Update the maximum reach we can achieve with the current jump\n        next_reach = max(next_reach, i + lst[i])\n        \n        # If we've reached the end of the array\n        if i == current_reach:\n            # We need another jump\n            if next_reach <= i:\n                return -1  # Impossible to reach the end\n            jumps += 1\n            current_reach = next_reach\n    \n    # If we can reach the end\n    return jumps if current_reach >= n - 1 else -1\n```"
  },
  {
    "id":90,
    "response":"```python\ndef mul_consecutive_nums(lst):\n    \"\"\"\n    Multiply consecutive numbers in a list.\n    \n    Args:\n        lst: A list of numbers\n        \n    Returns:\n        The product of consecutive numbers in the list\n    \"\"\"\n    if not lst:\n        return 1\n    \n    result = 1\n    for num in lst:\n        result *= num\n    \n    return result\n```"
  },
  {
    "id":91,
    "response":"```python\ndef group_element(lst):\n    \"\"\"\n    Group the first elements of tuples based on the second elements.\n    \n    Args:\n        lst: A list of tuples where each tuple has at least two elements.\n    \n    Returns:\n        A dictionary where keys are the second elements of tuples and values are lists \n        of first elements from tuples that have the same second element.\n    \"\"\"\n    result = {}\n    for item in lst:\n        second_element = item[1]\n        first_element = item[0]\n        if second_element not in result:\n            result[second_element] = []\n        result[second_element].append(first_element)\n    return result\n```"
  },
  {
    "id":92,
    "response":"```python\ndef last_Two_Digits(n):\n    \"\"\"\n    Return the last two digits of n! (n factorial).\n    \n    If n is greater than or equal to 10, the factorial will have trailing zeros,\n    so we need to compute n! modulo 100 to get the last two digits.\n    \n    For n >= 10, n! will have at least two trailing zeros (due to factors of 2 and 5),\n    so we can compute the factorial while avoiding large intermediate values.\n    \n    For n < 10, we compute the factorial normally.\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    if n == 0 or n == 1:\n        return 1\n    \n    # For n >= 10, n! will have at least two trailing zeros\n    # So we can compute factorial modulo 100 to get last two digits\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % 100\n    \n    return result\n```"
  },
  {
    "id":93,
    "response":"```python\nimport re\n\ndef remove_multiple_spaces(s):\n    \"\"\"\n    রেজেক্স ব্যবহার করে স্ট্রিংয়ে একাধিক স্পেস অপসারণ করে।\n    \n    Args:\n        s (str): স্ট্রিং যেখানে একাধিক স্পেস থাকতে পারে\n        \n    Returns:\n        str: একাধিক স্পেস অপসারণ করে প্রাপ্ত স্ট্রিং\n    \"\"\"\n    return re.sub(r'\\s+', ' ', s.strip())\n```"
  },
  {
    "id":94,
    "response":"```python\ndef extract_unique(dct):\n    \"\"\"\n    প্রদত্ত অভিধানের মান থেকে অনন্য মান বের করে একটি সেট রিটার্ন করে।\n    \n    Args:\n        dct (dict): অভিধান\n        \n    Returns:\n        set: অনন্য মানগুলির সেট\n    \"\"\"\n    return set(dct.values())\n```"
  },
  {
    "id":95,
    "response":"```python\ndef check_greater(tup, tup2):\n    \"\"\"\n    Check if each element in the second tuple is greater than the corresponding element in the first tuple.\n    \n    Args:\n        tup: First tuple\n        tup2: Second tuple\n    \n    Returns:\n        A list of boolean values indicating whether each element in tup2 is greater than the corresponding element in tup.\n    \"\"\"\n    result = []\n    for i in range(len(tup)):\n        if i < len(tup2):\n            result.append(tup2[i] > tup[i])\n        else:\n            result.append(False)\n    return result\n```"
  },
  {
    "id":96,
    "response":"```python\ndef zip_list(lst, lst2):\n    \"\"\"\n    দুইটি তালিকাকে একসাথে সংযুক্ত করে এবং প্রতিটি জোড়া একটি করে তৈরি করে।\n    \n    Args:\n        lst: প্রথম তালিকা\n        lst2: দ্বিতীয় তালিকা\n    \n    Returns:\n        জোড়া গুলির একটি তালিকা (প্রতিটি জোড়া হবে একটি করে তালিকা অবস্থায়)\n    \n    Example:\n        zip_list([1, 2, 3], ['a', 'b', 'c']) -> [(1, 'a'), (2, 'b'), (3, 'c')]\n    \"\"\"\n    return list(zip(lst, lst2))\n```"
  },
  {
    "id":97,
    "response":"```python\ndef count_even(lst):\n    return len(list(filter(lambda x: x % 2 == 0, lst)))\n```"
  },
  {
    "id":98,
    "response":"```python\ndef sort_dict_item(dct):\n    \"\"\"\n    একটি অভিধানের জন্য টিপল কীগুলির টুপল পণ্য দ্বারা অভিধানের আইটেমগুলি বাছাই করে।\n    \n    Parameters:\n    dct (dict): অভিধান যার কীগুলি বাছাই করা হবে।\n    \n    Returns:\n    tuple: বাছাইকৃত কী-বের টুপল।\n    \"\"\"\n    return tuple(sorted(dct.keys()))\n```"
  },
  {
    "id":99,
    "response":"```python\ndef min_swaps(s, s2):\n    \"\"\"\n    Calculate the minimum number of swaps needed to convert binary string s to s2.\n    \n    Args:\n        s (str): Original binary string\n        s2 (str): Target binary string\n    \n    Returns:\n        int: Minimum number of swaps needed\n    \"\"\"\n    # Count the number of positions where s and s2 differ\n    diff_count = 0\n    for i in range(len(s)):\n        if s[i] != s2[i]:\n            diff_count += 1\n    \n    # If no differences, no swaps needed\n    if diff_count == 0:\n        return 0\n    \n    # For binary strings, each differing position requires a swap\n    # Since we can only swap adjacent elements, the minimum swaps\n    # is equal to the number of differing positions divided by 2\n    # (because each swap can fix two positions)\n    \n    # If the number of differences is odd, we need one more swap\n    # to fix the last mismatch (but actually, in binary string conversion,\n    # we can always pair up the differences)\n    \n    # Actually, in this context, we're looking for minimum swaps to make\n    # s equal to s2. Each swap can change two positions. So we need\n    # ceil(diff_count \/ 2) swaps.\n    \n    return (diff_count + 1) \/\/ 2\n```"
  },
  {
    "id":100,
    "response":"```python\ndef count_range_in_list(lst, n, n2):\n    \"\"\"\n    একটি তালিকার উপাদানগুলির সংখ্যা গণনা করে যা নির্দিষ্ট পরিসরের মধ্যে থাকে।\n    \n    Parameters:\n    lst (list): তালিকা\n    n (int\/float): পরিসরের নিচের সীমা\n    n2 (int\/float): পরিসরের উপরের সীমা\n    \n    Returns:\n    int: পরিসরের মধ্যে থাকা উপাদানগুলির সংখ্যা\n    \"\"\"\n    count = 0\n    for item in lst:\n        if n <= item <= n2:\n            count += 1\n    return count\n```"
  },
  {
    "id":101,
    "response":"```python\ndef equilibrium_index(lst):\n    \"\"\"\n    Find the equilibrium index of a list.\n    An equilibrium index is an index where the sum of elements at lower indices\n    is equal to the sum of elements at higher indices.\n    \n    Args:\n        lst: List of integers\n        \n    Returns:\n        int: The equilibrium index, or -1 if no such index exists\n    \"\"\"\n    if not lst:\n        return -1\n    \n    n = len(lst)\n    \n    # Calculate total sum of the array\n    total_sum = sum(lst)\n    \n    left_sum = 0\n    \n    for i in range(n):\n        # Right sum = total_sum - left_sum - current element\n        right_sum = total_sum - left_sum - lst[i]\n        \n        if left_sum == right_sum:\n            return i\n        \n        left_sum += lst[i]\n    \n    return -1\n```"
  },
  {
    "id":102,
    "response":"```python\ndef removals(lst, n, n2):\n    \"\"\"\n    এই ফাংশনটি অ্যামাক্স-অ্যামিন <= কে এর মতো সরিয়ে ফেলা উচিত এমন উপাদানগুলির সর্বনিম্ন সংখ্যা খুঁজে পায়।\n    \n    Parameters:\n    lst: একটি লিস্ট যেখানে উপাদানগুলি হবে।\n    n: একটি সংখ্যা যা অ্যামাক্স-অ্যামিন হিসাবে ব্যবহার হবে।\n    n2: একটি সংখ্যা যা অ্যামিন হিসাবে ব্যবহার হবে।\n    \n    Returns:\n    সরিয়ে ফেলার জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যা।\n    \"\"\"\n    # এখানে অ্যামাক্স-অ্যামিন <= কে এর মতো উপাদানগুলি হল যারা n <= কিছু এবং তা না হলে n2 এর মতো হবে।\n    # তবে প্রদত্ত উদাহরণে পরিভাষা খুব স্পষ্ট নয়। তাই আমরা সহজ বোঝার জন্য এক"
  },
  {
    "id":103,
    "response":"```python\ndef is_key_present(dct, n):\n    \"\"\"\n    Check if a key exists in the given dictionary.\n    \n    Args:\n        dct (dict): The dictionary to search in.\n        n: The key to check for existence.\n    \n    Returns:\n        bool: True if the key exists, False otherwise.\n    \"\"\"\n    return n in dct\n```"
  },
  {
    "id":104,
    "response":"```python\ndef harmonic_sum(n):\n    \"\"\"\n    Calculate the harmonic sum of n-1, which is the sum of reciprocals from 1 to n-1.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        float: The harmonic sum of n-1\n    \"\"\"\n    if n <= 1:\n        return 0.0\n    \n    harmonic = 0.0\n    for i in range(1, n):\n        harmonic += 1.0 \/ i\n    \n    return harmonic\n```"
  },
  {
    "id":105,
    "response":"```python\ndef sort_sublists(lst):\n    \"\"\"\n    Sorts a list of sublists based on the length of each sublist first,\n    and then by the sum of elements in each sublist as a secondary criterion.\n    \n    Args:\n        lst: A list of sublists (each sublist is a list of numbers)\n    \n    Returns:\n        A new list of sublists sorted by length first, then by sum of elements\n    \"\"\"\n    return sorted(lst, key=lambda x: (len(x), sum(x)))\n```"
  },
  {
    "id":106,
    "response":"```python\ndef is_subset(lst, n, lst2, n2):\n    \"\"\"\n    Check if the first array (lst) is a subset of the second array (lst2).\n    \n    Args:\n        lst: First list to check\n        n: Length of first list\n        lst2: Second list to check against\n        n2: Length of second list\n    \n    Returns:\n        True if lst is a subset of lst2, False otherwise\n    \"\"\"\n    # Convert both lists to sets for efficient subset checking\n    set1 = set(lst[:n])\n    set2 = set(lst2[:n2])\n    \n    # Check if set1 is a subset of set2\n    return set1.issubset(set2)\n```"
  },
  {
    "id":107,
    "response":"```python\ndef count_Set_Bits(n):\n    \"\"\"\n    Count the total number of set bits (1s) in binary representation\n    of all numbers from 1 to n (inclusive).\n    \n    Args:\n        n (int): The upper limit of the range (1 to n)\n    \n    Returns:\n        int: Total count of set bits in all numbers from 1 to n\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    total_bits = 0\n    for i in range(1, n + 1):\n        # Count set bits in the current number\n        bit_count = 0\n        num = i\n        while num:\n            bit_count += num & 1\n            num >>= 1\n        total_bits += bit_count\n    \n    return total_bits\n```"
  },
  {
    "id":108,
    "response":"```python\ndef convert(s):\n    \"\"\"\n    Convert a string to a list of characters.\n    \n    Args:\n        s (str): The input string\n        \n    Returns:\n        list: A list containing each character of the string\n    \"\"\"\n    return list(s)\n```"
  },
  {
    "id":109,
    "response":"```python\ndef get_unique(lst):\n    \"\"\"\n    টিপলের প্রতিটি মানের জন্য অনন্য কী গণনা করে একটি ডিকশনারি রিটার্ন করে।\n    যেখানে কোন মান অন্য কোন মানের সাথে দুবার বা বেশি দেখা যায় তার জন্য সেটের মান হবে 1 (অনন্য)।\n    \n    Args:\n        lst: একটি টিপল যেখানে মান উপস্থিত আছে।\n    \n    Returns:\n        dict: যেখানে কোন মানের জন্য অনন্য কী হয় তা দেখানো হয়।\n    \"\"\"\n    unique_count = {}\n    for item in lst:\n        if item not in unique_count:\n            unique_count[item] = 1\n        else:\n            unique_count[item] += 1\n    \n    # যদি কোন মানের গণনা 1 হয় তবে সেটা অনন্য মান\n    result = {key: value for key, value in unique_count.items() if value == 1}\n    return result\n```"
  },
  {
    "id":110,
    "response":"```python\ndef front_and_rear(tup):\n    \"\"\"\n    Return a tuple containing the first and last elements of the given tuple.\n    \n    Args:\n        tup: A tuple of elements\n        \n    Returns:\n        A tuple (first_element, last_element)\n    \"\"\"\n    if not tup:\n        return None, None\n    \n    return tup[0], tup[-1]\n```"
  },
  {
    "id":111,
    "response":"```python\ndef product_equal(n):\n    \"\"\"\n    Check if the product of digits at even positions equals the product of digits at odd positions.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        bool: True if product of even-positioned digits equals product of odd-positioned digits, False otherwise\n    \"\"\"\n    # Convert number to string to access individual digits\n    digits = str(n)\n    \n    # Initialize products\n    even_product = 1\n    odd_product = 1\n    \n    # Iterate through digits with position indexing\n    for i in range(len(digits)):\n        digit = int(digits[i])\n        if i % 2 == 0:  # Even position (0-indexed)\n            even_product *= digit\n        else:  # Odd position (0-indexed)\n            odd_product *= digit\n    \n    return even_product == odd_product\n```"
  },
  {
    "id":112,
    "response":"```python\ndef remove_duplicate(lst):\n    \"\"\"\n    Remove duplicate elements from a list while preserving the order of first occurrence.\n    \n    Args:\n        lst: Input list\n        \n    Returns:\n        A new list with duplicates removed\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    \n    return result\n```"
  },
  {
    "id":113,
    "response":"```python\ndef check_valid(tup):\n    \"\"\"\n    Check if all elements in the given tuple are valid.\n    Valid elements are defined as being of a valid type (e.g., int, float, str, bool)\n    and not None.\n    \n    Args:\n        tup: A tuple containing elements to be validated\n        \n    Returns:\n        bool: True if all elements are valid, False otherwise\n    \"\"\"\n    if not tup:\n        return True\n    \n    for element in tup:\n        if element is None:\n            return False\n        # Check if element is a valid type (primitive types)\n        if not isinstance(element, (int, float, str, bool)):\n            return False\n    \n    return True\n```"
  },
  {
    "id":114,
    "response":"```python\ndef count_Fac(n):\n    \"\"\"\n    প্রদত্ত সংখ্যার প্রধান ফ্যাক্টরের স্বতন্ত্র শক্তির সংখ্যা গণনা করে।\n    \n    প্রধান ফ্যাক্টর হল সংখ্যাটির প্রধান উৎপাদকগুলি।\n    এই ফাংশন প্রতিটি প্রধান উৎপাদকের স্বতন্ত্র শক্তি (অর্থাৎ শক্তি যা প্রদত্ত সংখ্যার উৎপাদক হিসেবে উপস্থিত হয়) গণনা করে এবং সেগুলির সংখ্যা ফিরে দেয়।\n    \n    Parameters:\n    n (int): প্রদত্ত সংখ্যা (স্বাভাবিক সংখ্যা হতে হবে)\n    \n    Returns:\n    int: প্রধান উৎপাদকের স্বতন্ত্র শক্তির সংখ্যা\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    count = 0\n    i = 2\n    \n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            while n % i == 0:\n                n \/\/= i\n        i += 1\n    \n    # যদি n > 1 হয়, তবে n এটি একটি প্রধান উৎপাদক\n    if n > 1"
  },
  {
    "id":115,
    "response":"```python\ndef str_to_tuple(s):\n    \"\"\"\n    পূর্ণসংখ্যার প্রদত্ত স্ট্রিংকে একটি টিপলে রূপান্তর করে।\n    \n    Args:\n        s (str): পূর্ণসংখ্যা সংখ্যা যা স্ট্রিং হিসাবে দেওয়া হয়েছে, যেমন \"1,2,3\"\n    \n    Returns:\n        tuple: পূর্ণসংখ্যা সমূহের টিপল\n    \"\"\"\n    if not s or s.strip() == \"\":\n        return ()\n    \n    # স্ট্রিংকে কমা দ্বারা ভাগ করে পূর্ণসংখ্যা তৈরি করা\n    parts = s.strip().split(',')\n    \n    # প্রতিটি পার্টকে পূর্ণসংখ্যা হিসাবে পরিবর্তন করা\n    result = tuple(int(part.strip()) for part in parts if part.strip())\n    \n    return result\n```"
  },
  {
    "id":116,
    "response":"```python\ndef rombus_perimeter(n):\n    \"\"\"\n    রম্বসের পরিধি বের করে তোলে।\n    \n    রম্বসের প্রতিটি বাহুর দৈর্ঘ্য n হলে, পরিধি = 4 * n\n    \n    Parameters:\n    n (int or float): রম্বসের প্রতিটি বাহুর দৈর্ঘ্য\n    \n    Returns:\n    int or float: রম্বসের পরিধি\n    \"\"\"\n    return 4 * n\n```"
  },
  {
    "id":117,
    "response":"```python\nimport math\n\ndef sd_calc(lst):\n    \"\"\"\n    Calculate the standard deviation of a list of numbers.\n    \n    Args:\n        lst: List of numbers\n        \n    Returns:\n        float: Standard deviation of the list\n    \"\"\"\n    if len(lst) == 0:\n        return 0\n    \n    # Calculate mean\n    mean = sum(lst) \/ len(lst)\n    \n    # Calculate variance\n    variance = sum((x - mean) ** 2 for x in lst) \/ len(lst)\n    \n    # Return standard deviation (square root of variance)\n    return math.sqrt(variance)\n```"
  },
  {
    "id":118,
    "response":"```python\ndef alternate_elements(lst):\n    \"\"\"\n    একটি তালিকা তৈরি করে যা দেয় অন্য তালিকা থেকে বিকল্প উপাদানগুলি।\n    \n    Args:\n        lst: উপাদানগুলি থেকে বিকল্প উপাদান নেবে যে তালিকা।\n    \n    Returns:\n        বিকল্প উপাদানগুলি বহুল তালিকা।\n    \"\"\"\n    result = []\n    for i in range(0, len(lst), 2):\n        result.append(lst[i])\n    return result\n```"
  },
  {
    "id":119,
    "response":"```python\ndef text_match(s):\n    \"\"\"\n    Check if a string contains 'a' followed by zero or more 'b's.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string has 'a' followed by zero or more 'b's, False otherwise.\n    \"\"\"\n    # Look for 'a' followed by zero or more 'b's\n    import re\n    pattern = r'a(b*)'\n    return bool(re.search(pattern, s))\n```"
  },
  {
    "id":120,
    "response":"```python\ndef add_dict_to_tuple(tup, dct):\n    \"\"\"\n    একটি টিপলে একটি অভিধান যোগ করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    tup: টিপল\n    dct: অভিধান\n    \n    ফেরত দেয়:\n    টিপলে অভিধান যোগ করা টিপল\n    \"\"\"\n    return tup + (dct,)\n```"
  },
  {
    "id":121,
    "response":"```python\ndef maxAverageOfPath(lst, n):\n    \"\"\"\n    Find the path in an n*n matrix that has the maximum average value.\n    \n    Args:\n        lst: A 2D list representing an n*n matrix\n        n: The size of the matrix (n*n)\n    \n    Returns:\n        A list representing the path that has the maximum average value\n    \"\"\"\n    # Convert the 2D list to a matrix for easier access\n    matrix = [row[:] for row in lst]\n    \n    # If matrix is empty or n is 0, return empty path\n    if not matrix or n == 0:\n        return []\n    \n    # Generate all possible paths from top-left to bottom-right\n    # We'll use DFS to explore all paths\n    max_avg = float('-inf')\n    best_path = []\n    \n    def dfs(row, col, path):\n        nonlocal max_avg, best_path\n        \n        # Base case: reached bottom-right corner\n        if row == n - 1 and col == n - 1:\n            # Calculate average of the path\n            path_sum = sum(path)\n            avg = path_sum \/ len(path)\n            \n            if avg > max_avg:\n                max_avg = avg\n                best_path = path[:]\n            return\n        \n        # Explore right and down directions\n        # Right\n        if col + 1 < n:\n            path.append(matrix[row][col + 1])\n            dfs(row, col + 1, path)\n            path.pop()\n        \n        # Down\n        if row + 1 < n:\n            path.append(matrix[row + 1][col])\n            dfs(row + 1, col, path)\n            path.pop()\n    \n    # Start DFS from top-left corner (0,0)\n    # Add the starting cell to the path\n    path = [matrix[0][0]]\n    dfs(0, 0, path)\n    \n    return best_path\n```"
  },
  {
    "id":122,
    "response":"```python\ndef filter_data(dct, n, n2):\n    \"\"\"\n    শিক্ষার্থীদের উচ্চতা এবং প্রস্থ ফিল্টার করে যা একটি অভিধানে সংরক্ষিত থাকে।\n    \n    Parameters:\n    dct (dict): শিক্ষার্থীদের তথ্যের অভিধান, যেখানে কোন কোন শিক্ষার্থীর উচ্চতা এবং প্রস্থ থাকে\n    n (int): উচ্চতা ফিল্টারের সীমা (উচ্চতা >= n হলে ফিল্টার করা হবে)\n    n2 (int): প্রস্থ ফিল্টারের সীমা (প্রস্থ >= n2 হলে ফিল্টার করা হবে)\n    \n    Returns:\n    dict: ফিল্টার করা শিক্ষার্থীদের অভিধান\n    \"\"\"\n    filtered_dct = {}\n    for key, value in dct.items():\n        height = value.get('height')\n        width = value.get('width')\n        \n        if height is not None and height >= n and width is not None and width >= n2:\n            filtered_dct[key] = value\n    \n    return filtered_dct\n```"
  },
  {
    "id":123,
    "response":"```python\ndef count_same_pair(lst, lst2):\n    \"\"\"\n    Count the number of pairs that appear in both lists.\n    \n    Args:\n        lst: First list of elements\n        lst2: Second list of elements\n    \n    Returns:\n        int: Number of common pairs (elements that appear in both lists)\n    \"\"\"\n    # Convert both lists to sets for efficient lookup\n    set1 = set(lst)\n    set2 = set(lst2)\n    \n    # Find intersection of both sets\n    common_elements = set1.intersection(set2)\n    \n    # Count the number of common elements\n    return len(common_elements)\n```"
  },
  {
    "id":124,
    "response":"```python\ndef power_base_sum(n, n2):\n    \"\"\"\n    Calculate the sum of digits of n raised to the power of n2.\n    \n    Args:\n        n (int): The base number\n        n2 (int): The exponent\n    \n    Returns:\n        int: Sum of digits of (n^n2)\n    \"\"\"\n    # Calculate n raised to the power of n2\n    result = n ** n2\n    \n    # Convert result to string to access individual digits\n    result_str = str(result)\n    \n    # Sum all digits\n    digit_sum = sum(int(digit) for digit in result_str)\n    \n    return digit_sum\n```"
  },
  {
    "id":125,
    "response":"```python\nimport re\n\ndef extract_quotation(s):\n    \"\"\"\n    রেজেক্স ব্যবহার করে প্রদত্ত স্ট্রিংয়ের উদ্ধৃতি চিহ্নের মধ্যে মানগুলি বের করে।\n    \n    Args:\n        s (str): প্রদত্ত স্ট্রিং\n        \n    Returns:\n        list: উদ্ধৃতি চিহ্নের মধ্যে মানগুলির একটি তালিকা\n    \"\"\"\n    # উদ্ধৃতি চিহ্নের মধ্যে কোনও মান বের করার জন্য রেজেক্স প্যাটার্ন ব্যবহার করা হয়\n    # উদ্ধৃতি চিহ্ন হতে পারে কোনও ক্ষেত্রে সাধারণ উদ্ধৃতি চিহ্ন হিসাবে ব্যবহার করা হয়\n    pattern = r'\"([^\"]*)\"'  # দুটি উদ্ধৃতি চিহ্ন দিয়ে আবদ্ধ মানগুলি খুঁজে বের করা হয়\n    \n    # মানগুলি বের করা হয় এবং ফাংশন তাদের তালিকায় রাখে\n    matches = re.findall(pattern, s)\n    \n    return matches\n```"
  },
  {
    "id":126,
    "response":"```python\ndef multiply_elements(tup):\n    \"\"\"\n    প্রদত্ত টিপলের সংলগ্ন উপাদানগুলিকে গুণ করে একটি সংখ্যা রিটার্ন করে।\n    \n    আর্গুমেন্ট:\n    tup: একটি টিপল যার উপাদানগুলি গুণ করা হবে\n    \n    রিটার্ন:\n    টিপলের সব উপাদানের গুণফল\n    \"\"\"\n    result = 1\n    for element in tup:\n        result *= element\n    return result\n```"
  },
  {
    "id":127,
    "response":"```python\nimport re\n\ndef remove_char(s):\n    \"\"\"\n    রেজেক্স ব্যবহার করে অক্ষর এবং সংখ্যা ছাড়া সমস্ত অক্ষর সরানোর জন্য একটি ফাংশন।\n    এখানে বোঝানো হয়েছে যে অক্ষর এবং সংখ্যা ছাড়া সব অক্ষর সরাবে।\n    কিন্তু তা যদি তার মানে হয় যে অক্ষর এবং সংখ্যা ছাড়া সব অক্ষর সরানো হবে, তবে তা অসম্ভব।\n    সম্ভবত মানে হয় যে অক্ষর এবং সংখ্যা ছাড়া সব অক্ষর সরানো হবে না।\n    সম্ভবত মানে হয় যে অক্ষর এবং সংখ্যা ছাড়া সব অক্ষর সরানো হবে না।\n    সম্ভবত মানে হয় যে অক্ষর এবং সংখ্যা ছাড়া সব অক্ষর সরানো হবে না।\n    সম্ভবত মানে হয় যে অক্ষর এব�"
  },
  {
    "id":128,
    "response":"```python\ndef sum_list(lst, lst2):\n    \"\"\"\n    দুটি তালিকার উপাদান যোগ করে একটি নতুন তালিকা তৈরি করে।\n    \n    Parameters:\n    lst (list): প্রথম তালিকা\n    lst2 (list): দ্বিতীয় তালিকা\n    \n    Returns:\n    list: উপাদানগুলি যোগ করা তালিকা\n    \"\"\"\n    result = []\n    for i in range(min(len(lst), len(lst2))):\n        result.append(lst[i] + lst2[i])\n    return result\n```"
  },
  {
    "id":129,
    "response":"```python\ndef add_list(lst, lst2):\n    \"\"\"\n    দুটি তালিকা যোগ করে একটি নতুন তালিকা রিটার্ন করে।\n    \n    Args:\n        lst: প্রথম তালিকা\n        lst2: দ্বিতীয় তালিকা\n    \n    Returns:\n        দুটি তালিকার যোগফল হিসাবে একটি তালিকা\n    \"\"\"\n    return lst + lst2\n```"
  },
  {
    "id":130,
    "response":"```python\ndef consecutive_duplicates(lst):\n    \"\"\"\n    Remove consecutive duplicates from a list.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A new list with consecutive duplicates removed\n    \"\"\"\n    if not lst:\n        return []\n    \n    result = [lst[0]]\n    \n    for i in range(1, len(lst)):\n        if lst[i] != lst[i-1]:\n            result.append(lst[i])\n    \n    return result\n```"
  },
  {
    "id":131,
    "response":"```python\nimport math\n\ndef lateralsurface_cone(n, n2):\n    \"\"\"\n    Calculate the lateral surface area of a cone.\n    \n    Parameters:\n    n (float): The radius of the base of the cone.\n    n2 (float): The height of the cone.\n    \n    Returns:\n    float: The lateral surface area of the cone.\n    \"\"\"\n    # Calculate the slant height of the cone\n    slant_height = math.sqrt(n**2 + n2**2)\n    \n    # Calculate the lateral surface area: π * r * l\n    lateral_area = math.pi * n * slant_height\n    \n    return lateral_area\n```"
  },
  {
    "id":132,
    "response":"```python\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, and periods with colons.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: String with spaces, commas, and periods replaced by colons\n    \"\"\"\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')\n```"
  },
  {
    "id":133,
    "response":"```python\ndef find_first_occurrence(lst, n):\n    \"\"\"\n    সাজানো অ্যারেতে প্রদত্ত সংখ্যার প্রথম উপস্থিতির সূচক খুঁজে পায়।\n    \n    প্যারামিটার:\n    lst: সাজানো অ্যারে (লিস্ট)\n    n: খুঁজে বের করার সংখ্যা\n    \n    রিটার্ন:\n    সংখ্যাটির প্রথম উপস্থিতির সূচক (ইনডেক্স), যদি উপস্থিত না থাকে তবে -1 রিটার্ন করে।\n    \"\"\"\n    left, right = 0, len(lst) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) \/\/ 2\n        if lst[mid] == n:\n            result = mid\n            right = mid - 1  # আরও প্রথম উপস্থিতি খুঁজব\n        elif lst[mid] < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n```"
  },
  {
    "id":134,
    "response":"```python\ndef sum_Of_Subarray_Prod(lst, n):\n    \"\"\"\n    Calculate the sum of products of all possible subarrays in the given list.\n    \n    Args:\n        lst: List of integers\n        n: Length of the list\n    \n    Returns:\n        Sum of products of all subarrays\n    \"\"\"\n    total_sum = 0\n    \n    # Iterate through all possible starting positions\n    for i in range(n):\n        current_product = 1\n        # Iterate through all possible ending positions from i\n        for j in range(i, n):\n            current_product *= lst[j]\n            total_sum += current_product\n    \n    return total_sum\n```"
  },
  {
    "id":135,
    "response":"```python\ndef toggle_middle_bits(n):\n    \"\"\"\n    Toggle all bits of a number except the first and last bits.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The number with middle bits toggled, first and last bits unchanged\n    \"\"\"\n    # Handle edge cases\n    if n == 0:\n        return 0\n    \n    # Find the number of bits in the number\n    bit_length = n.bit_length()\n    \n    # If only 1 bit (i.e., n is 0 or 1), no middle bits to toggle\n    if bit_length <= 2:\n        return n\n    \n    # Create a mask to toggle middle bits\n    # First bit is at position 0, last bit is at position (bit_length - 1)\n    # Middle bits are from position 1 to (bit_length - 2)\n    \n    # Create a mask with all bits set except first and last\n    mask = 0\n    for i in range(1, bit_length - 1):\n        mask |= (1 << i)\n    \n    # Toggle middle bits by XOR with mask\n    result = n ^ mask\n    \n    return result\n```"
  },
  {
    "id":136,
    "response":"```python\ndef left_insertion(lst, n):\n    \"\"\"\n    নির্দিষ্ট মানের বাম সন্নিবেশ পয়েন্ট সনাক্ত করে।\n    \n    এই ফাংশনটি একটি লিস্টে দেওয়া মান n এর বাম সন্নিবেশ পয়েন্ট বের করে।\n    বাম সন্নিবেশ পয়েন্ট হল যে পয়েন্টে মান n কে সন্নিবেশ করা যায় যাতে সব মানগুলি বামে থাকে।\n    \n    Parameters:\n    lst (list): সংখ্যা বিশিষ্ট লিস্ট\n    n (int\/float): সন্নিবেশ করার জন্য মান\n    \n    Returns:\n    int: বাম সন্নিবেশ পয়েন্টের ক্রম (0 থেকে শুরু)\n    \"\"\"\n    # যদি লিস্ট খালি হয় তবে সন্নিবেশ পয়েন্ট 0\n    if not lst:\n        return 0\n    \n    # লিস্টে মান n কে সন্নিবেশ করার জন্য বাম পয়েন্ট নির্ধারণ\n    # যদি সব মান অনুসরণ করে তবে সব মানগুলি বামে থ"
  },
  {
    "id":137,
    "response":"```python\ndef check_str(s):\n    \"\"\"\n    Check if the given string starts with a vowel.\n    \n    Args:\n        s (str): The string to check.\n        \n    Returns:\n        bool: True if the string starts with a vowel, False otherwise.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    if s and s[0] in vowels:\n        return True\n    return False\n```"
  },
  {
    "id":138,
    "response":"```python\ndef geometric_sum(n):\n    \"\"\"\n    Calculate the geometric sum of n-1 terms with common ratio 1.\n    For geometric series with ratio 1, the sum is simply n-1.\n    \n    Args:\n        n (int): The number of terms (n-1 terms are summed)\n    \n    Returns:\n        int: The sum of the geometric series with ratio 1\n    \"\"\"\n    if n <= 1:\n        return 0\n    return n - 1\n```"
  },
  {
    "id":139,
    "response":"```python\ndef find_Index(n):\n    \"\"\"\n    Find the smallest triangular number with n digits.\n    \n    A triangular number is of the form T_k = k * (k + 1) \/ 2.\n    This function finds the smallest k such that T_k has at least n digits.\n    \n    Args:\n        n (int): Number of digits required in the triangular number.\n    \n    Returns:\n        int: The index k such that T_k is the smallest triangular number with n digits.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # We need to find the smallest k such that k*(k+1)\/2 has at least n digits\n    # A number has at least n digits if it's >= 10^(n-1)\n    \n    # We can solve k*(k+1)\/2 >= 10^(n-1)\n    # Approximately: k^2\/2 >= 10^(n-1) => k >= sqrt(2 * 10^(n-1))\n    \n    # Start with an initial estimate\n    lower_bound = int((2 * (10 ** (n - 1))) ** 0.5)\n    \n    # Adjust to ensure we have at least n digits\n    k = lower_bound\n    \n    # We need to find the smallest k such that k*(k+1)\/\/2 >= 10^(n-1)\n    while k * (k + 1) \/\/ 2 < 10 ** (n - 1):\n        k += 1\n    \n    return k\n```"
  },
  {
    "id":140,
    "response":"```python\ndef tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple into a dictionary using adjacent elements as key-value pairs.\n    \n    Args:\n        tup: A tuple where adjacent elements are used as (key, value) pairs.\n        \n    Returns:\n        A dictionary with key-value pairs formed from adjacent elements in the tuple.\n        \n    Example:\n        tuple_to_dict((1, 2, 3, 4)) -> {1: 2, 3: 4}\n    \"\"\"\n    result = {}\n    for i in range(0, len(tup) - 1, 2):\n        key = tup[i]\n        value = tup[i + 1]\n        result[key] = value\n    return result\n```"
  },
  {
    "id":141,
    "response":"```python\ndef all_characters_same(s):\n    \"\"\"\n    Check if all characters in the string are the same.\n    \n    Args:\n        s (str): The input string to check.\n    \n    Returns:\n        bool: True if all characters are the same, False otherwise.\n    \"\"\"\n    if len(s) <= 1:\n        return True\n    \n    return all(char == s[0] for char in s)\n```"
  },
  {
    "id":142,
    "response":"```python\nimport math\n\ndef area_tetrahedron(n):\n    \"\"\"\n    Calculate the surface area of a regular tetrahedron with edge length n.\n    \n    A regular tetrahedron has 4 equilateral triangular faces.\n    The area of one equilateral triangle with side length n is:\n    (sqrt(3)\/4) * n^2\n    \n    Therefore, the total surface area is:\n    4 * (sqrt(3)\/4) * n^2 = sqrt(3) * n^2\n    \n    Args:\n        n (float): Edge length of the tetrahedron\n        \n    Returns:\n        float: Surface area of the tetrahedron\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Edge length must be positive\")\n    \n    return math.sqrt(3) * n * n\n```"
  },
  {
    "id":143,
    "response":"```python\ndef rotate_right(lst, n, n2):\n    \"\"\"\n    Rotate a list to the right by n positions, with n2 as an optional parameter.\n    If n2 is provided, it may be used for additional logic (e.g., modulo operation).\n    \n    Args:\n        lst: The list to rotate\n        n: Number of positions to rotate right\n        n2: Optional parameter (can be used for additional processing)\n    \n    Returns:\n        A new list rotated to the right by n positions\n    \"\"\"\n    if not lst:\n        return lst\n    \n    # Ensure n is non-negative and within bounds\n    n = n % len(lst)\n    \n    # Perform right rotation by taking the last n elements and moving them to the front\n    return lst[-n:] + lst[:-n]\n```"
  },
  {
    "id":144,
    "response":"```python\ndef check_none(tup):\n    \"\"\"\n    Check if any element in the tuple is None.\n    \n    Args:\n        tup: A tuple to check for None values.\n        \n    Returns:\n        bool: True if there is at least one None value in the tuple, False otherwise.\n    \"\"\"\n    return None in tup\n```"
  },
  {
    "id":145,
    "response":"```python\ndef divisible_by_digits(n, n2):\n    \"\"\"\n    দুটি সংখ্যা n এবং n2 এর মধ্যে সংখ্যা খুঁজে বের করে যেগুলি তাদের মধ্যে থাকা প্রতিটি অঙ্কের দ্বারা বিভাজ্য।\n    \n    Parameters:\n    n (int): প্রথম সংখ্যা\n    n2 (int): দ্বিতীয় সংখ্যা\n    \n    Returns:\n    list: সংখ্যা এর মধ্যে যেগুলি তাদের অঙ্কের দ্বারা বিভাজ্য হয় তাদের তালিকা\n    \"\"\"\n    result = []\n    \n    for num in range(n, n2 + 1):\n        # সংখ্যার অঙ্কগুলি পাওয়া যায়\n        digits = [int(d) for d in str(num)]\n        \n        # যদি কোন অঙ্ক 0 হয় তবে বিভাজ্য হতে পারে না\n        if 0 in digits:\n            continue\n            \n        # সংখ্যাটি প্রতিটি অঙ্কের দ্বারা বিভাজ্য হওয়ার জন্য চেক করা হয়\n        divisible = True\n        for digit in digits:\n            if num % digit != 0:\n                divisible = False\n                break\n                \n        if divisible:\n            result.append(num)\n    \n    return result\n```"
  },
  {
    "id":146,
    "response":"```python\ndef sector_area(n, n2):\n    \"\"\"\n    Calculate the area of a sector given two parameters n and n2.\n    \n    Parameters:\n    n: First parameter (could represent radius or angle)\n    n2: Second parameter (could represent radius or angle)\n    \n    Returns:\n    Area of the sector\n    \"\"\"\n    # Assuming the sector area formula: (theta\/360) * π * r^2\n    # where theta is in degrees and r is radius\n    # If n and n2 represent radius and angle respectively\n    if n2 <= 0:\n        return 0\n    \n    # Using the formula for sector area\n    import math\n    area = (n2 \/ 360) * math.pi * (n ** 2)\n    return area\n```"
  },
  {
    "id":147,
    "response":"```python\ndef lcs_of_three(s, s2, s3):\n    \"\"\"\n    Find the longest common subsequence among three strings.\n    \n    Args:\n        s (str): First string\n        s2 (str): Second string  \n        s3 (str): Third string\n    \n    Returns:\n        str: The longest common subsequence\n    \"\"\"\n    m, n, p = len(s), len(s2), len(s3)\n    \n    # Create a 3D DP table\n    # dp[i][j][k] represents the LCS of s[0:i], s2[0:j], s3[0:k]\n    dp = [[[\"\" for _ in range(p + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, p + 1):\n                if s[i-1] == s2[j-1] == s3[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + s[i-1]\n                else:\n                    # Take the maximum from the three possible cases\n                    option1 = dp[i-1][j][k]\n                    option2 = dp[i][j-1][k]\n                    option3 = dp[i][j][k-1]\n                    \n                    # Find the longest among them\n                    if len(option1) >= len(option2) and len(option1) >= len(option3):\n                        dp[i][j][k] = option1\n                    elif len(option2) >= len(option1) and len(option2) >= len(option3):\n                        dp[i][j][k] = option2\n                    else:\n                        dp[i][j][k] = option3\n    \n    return dp[m][n][p]\n```"
  },
  {
    "id":148,
    "response":"```python\ndef capital_words_spaces(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিং-এ বড় অক্ষর দিয়ে শুরু হওয়া শব্দের মধ্যে স্পেস রাখে।\n    \n    Args:\n        s (str): প্রদত্ত স্ট্রিং\n        \n    Returns:\n        str: বড় অক্ষর দিয়ে শুরু হওয়া শব্দের মধ্যে স্পেস রাখা স্ট্রিং\n    \"\"\"\n    result = []\n    i = 0\n    while i < len(s):\n        if s[i].isupper():\n            if result:\n                result.append(' ')\n            result.append(s[i])\n            i += 1\n            # পরবর্তী অক্ষরগুলি স্পেস না দিয়ে যাবে যতক্ষণ না বড় অক্ষর পায়\n            while i < len(s) and not s[i].isupper():\n                result.append(s[i])\n                i += 1\n        else:\n            result.append(s[i])\n            i += 1\n    \n    return ''.join(result)\n```"
  },
  {
    "id":149,
    "response":"```python\ndef sort_numeric_strings(lst):\n    \"\"\"\n    সংখ্যার একটি প্রদত্ত স্ট্রিংকে সংখ্যাসূচকভাবে সাজায়।\n    \n    Args:\n        lst: সংখ্যার স্ট্রিং এর একটি লিস্ট\n        \n    Returns:\n        সংখ্যাসূচকভাবে সাজানো লিস্ট\n    \"\"\"\n    def numeric_key(s):\n        \"\"\"স্ট্রিং কে সংখ্যাসূচক করে ফেরত দেয়\"\"\"\n        import re\n        return [int(text) for text in re.split(r'(\\d+)', s) if text.isdigit()]\n    \n    return sorted(lst, key=numeric_key)\n```"
  },
  {
    "id":150,
    "response":"```python\ndef add_tuple(lst, tup):\n    \"\"\"\n    প্রদত্ত তালিকায় প্রদত্ত টিউপেল যোগ করে।\n    \n    প্যারামিটার:\n    lst: যোগ করার জন্য তালিকা\n    tup: যোগ করা হবে টিউপেল\n    \n    রিটার্ন:\n    যোগ করা তালিকা\n    \"\"\"\n    lst.extend(tup)\n    return lst\n```"
  },
  {
    "id":151,
    "response":"```python\ndef check_min_heap(lst, n):\n    \"\"\"\n    Check if the given array represents a min heap.\n    \n    Args:\n        lst: List representing the heap (0-indexed)\n        n: Number of elements in the heap\n    \n    Returns:\n        True if the array represents a min heap, False otherwise\n    \"\"\"\n    # For a min heap, every parent node should be smaller than or equal to its children\n    # For node at index i, its left child is at 2*i + 1 and right child at 2*i + 2\n    \n    for i in range(n):\n        left_child_idx = 2 * i + 1\n        right_child_idx = 2 * i + 2\n        \n        # Check if left child exists and violates min heap property\n        if left_child_idx < n and lst[i] > lst[left_child_idx]:\n            return False\n            \n        # Check if right child exists and violates min heap property\n        if right_child_idx < n and lst[i] > lst[right_child_idx]:\n            return False\n    \n    return True\n```"
  },
  {
    "id":152,
    "response":"```python\ndef jacobsthal_num(n):\n    \"\"\"\n    Calculate the nth Jacobsthal number.\n    \n    The Jacobsthal numbers are defined by the recurrence relation:\n    J(0) = 0, J(1) = 1, J(n) = J(n-1) + 2*J(n-2) for n >= 2\n    \n    Args:\n        n (int): The index of the Jacobsthal number to compute\n        \n    Returns:\n        int: The nth Jacobsthal number\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for i in range(2, n + 1):\n        a, b = b, a + 2 * b\n    \n    return b\n```"
  },
  {
    "id":153,
    "response":"```python\ndef min_k(lst, k):\n    \"\"\"\n    Return the k smallest elements from the given list.\n    \n    Args:\n        lst: A list of comparable elements\n        k: Number of smallest elements to return\n    \n    Returns:\n        A tuple containing the k smallest elements in ascending order\n    \"\"\"\n    if not lst or k <= 0:\n        return ()\n    \n    # Sort the list and return first k elements\n    sorted_lst = sorted(lst)\n    return tuple(sorted_lst[:k])\n```"
  },
  {
    "id":154,
    "response":"```python\ndef extract_index_list(lst1, lst2, lst3):\n    \"\"\"\n    তিনটি তালিকা থেকে সাধারণ সূচক উপাদান খুঁজে পেয়ে তাদের সূচিকা একটি তালিকা হিসাবে ফেরত দেয়।\n    \n    Parameters:\n    lst1, lst2, lst3: তিনটি তালিকা (list)\n    \n    Returns:\n    সাধারণ উপাদানের সূচিকা বিশিষ্ট তালিকা\n    \"\"\"\n    # তিনটি তালিকার উপাদানগুলি পাওয়া যায়\n    set1 = set(lst1)\n    set2 = set(lst2)\n    set3 = set(lst3)\n    \n    # সাধারণ উপাদানগুলি খুঁজে পাওয়া যায়\n    common_elements = set1.intersection(set2, set3)\n    \n    # সাধারণ উপাদানগুলির সূচিকা পাওয়া যায়\n    indices = []\n    for i, element in enumerate(lst1):\n        if element in common_elements:\n            indices.append(i)\n    \n    # সাধারণ উপাদানগুলি যদি অন্য দুটি তালিকায় না থাকে তবে তা বাদ দেওয়া হবে\n    # এখানে আমরা মাত্র প্রথম তালিকার সূচিকা"
  },
  {
    "id":155,
    "response":"```python\ndef second_smallest(lst):\n    \"\"\"\n    একটি তালিকার দ্বিতীয় ক্ষুদ্রতম সংখ্যা খুঁজে বের করে।\n    \n    Args:\n        lst: একটি সংখ্যা বিশিষ্ট তালিকা\n        \n    Returns:\n        দ্বিতীয় ক্ষুদ্রতম সংখ্যা, যদি তালিকার দ্বিতীয় ক্ষুদ্রতম সংখ্যা থাকে।\n        যদি দ্বিতীয় ক্ষুদ্রতম সংখ্যা না থাকে তবে None রিটার্ন করে।\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # সংখ্যা বিশিষ্ট তালিকা থেকে বিশ্লেষণ করা\n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]\n```"
  },
  {
    "id":156,
    "response":"```python\ndef text_match_zero_one(s):\n    \"\"\"\n    Check if a string contains either a '0' or a 'b' (case-sensitive).\n    \n    Args:\n        s (str): The input string to check.\n    \n    Returns:\n        bool: True if the string contains '0' or 'b', False otherwise.\n    \"\"\"\n    return '0' in s or 'b' in s\n```"
  },
  {
    "id":157,
    "response":"```python\ndef count_reverse_pairs(lst):\n    \"\"\"\n    Count the number of reverse pairs in a list of strings.\n    A reverse pair consists of two strings where one is the reverse of the other.\n    \n    Args:\n        lst: List of strings\n        \n    Returns:\n        int: Number of reverse pairs\n    \"\"\"\n    if not lst or len(lst) < 2:\n        return 0\n    \n    count = 0\n    n = len(lst)\n    \n    # Check all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    \n    return count\n```"
  },
  {
    "id":158,
    "response":"```python\ndef unique_sublists(lst):\n    \"\"\"\n    একটি তালিকার মধ্যে অনন্য তালিকার সংখ্যা গণনা করে।\n    এটি তালিকার সব উপসংগ্রহ (sublists) কে অনন্য করে এবং তাদের সংখ্যা ফেরত দেয়।\n    \n    Args:\n        lst: একটি তালিকা (list)\n    \n    Returns:\n        অনন্য উপসংগ্রহের সংখ্যা\n    \"\"\"\n    if not lst:\n        return 0\n    \n    # সব উপসংগ্রহ তৈরি করে\n    sublists = []\n    n = len(lst)\n    \n    # সব সম্ভাব্য দৈর্ঘ্যের উপসংগ্রহ তৈরি করা\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            sublists.append(lst[i:j])\n    \n    # অনন্য উপসংগ্রহ তৈরি করা\n    unique_sublists_set = set(tuple(sublist) for sublist in sublists)\n    \n    return len(unique_sublists_set)\n```"
  },
  {
    "id":159,
    "response":"```python\ndef is_decimal(s):\n    \"\"\"\n    Check if a string represents a decimal number with 2 decimal places.\n    \n    Args:\n        s (str): The string to check.\n        \n    Returns:\n        bool: True if the string represents a decimal number with exactly 2 decimal places, False otherwise.\n    \"\"\"\n    # Remove leading\/trailing whitespace\n    s = s.strip()\n    \n    # Check if the string is empty\n    if not s:\n        return False\n    \n    # Split by decimal point\n    parts = s.split('.')\n    \n    # Must have exactly one decimal point\n    if len(parts) != 2:\n        return False\n    \n    # Check if both parts exist\n    integer_part, decimal_part = parts\n    \n    # Integer part should be non-negative and contain only digits\n    if not integer_part or not integer_part.isdigit():\n        return False\n    \n    # Decimal part must have exactly 2 digits\n    if len(decimal_part) != 2 or not decimal_part.isdigit():\n        return False\n    \n    return True\n```"
  },
  {
    "id":160,
    "response":"```python\ndef unique_element(lst, n):\n    \"\"\"\n    Check if there is exactly one unique element in the array.\n    \n    Args:\n        lst: List of elements to check\n        n: Length of the list (optional, for clarity)\n    \n    Returns:\n        True if there is exactly one unique element, False otherwise\n    \"\"\"\n    # Count frequency of each element\n    freq = {}\n    for element in lst:\n        freq[element] = freq.get(element, 0) + 1\n    \n    # Count how many elements appear exactly once\n    unique_count = sum(1 for count in freq.values() if count == 1)\n    \n    # Return True if exactly one element appears once (and all others appear more than once)\n    return unique_count == 1\n```"
  },
  {
    "id":161,
    "response":"```python\nimport math\n\ndef arc_length(n, n2):\n    \"\"\"\n    Calculate the arc length of a circle given the radius and angle in radians.\n    \n    Parameters:\n    n (float): Radius of the circle\n    n2 (float): Angle in radians\n    \n    Returns:\n    float: Arc length\n    \"\"\"\n    return n * n2\n```"
  },
  {
    "id":162,
    "response":"```python\ndef check_month_number(n):\n    \"\"\"\n    Check if the given month number has 30 days.\n    \n    Args:\n        n (int): The month number (1-12)\n    \n    Returns:\n        bool: True if the month has 30 days, False otherwise\n    \"\"\"\n    # Months with 30 days: April (4), June (6), September (9), November (11)\n    months_with_30_days = {4, 6, 9, 11}\n    \n    return n in months_with_30_days\n```"
  },
  {
    "id":163,
    "response":"```python\ndef find_Min_Diff(arr, n):\n    \"\"\"\n    Find the minimum difference between any two elements in an array.\n    \n    Args:\n        arr: List of integers\n        n: Length of the array\n    \n    Returns:\n        Integer representing the minimum difference between any two elements\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    # Sort the array to make finding minimum difference efficient\n    arr.sort()\n    \n    # Find minimum difference between adjacent elements\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        min_diff = min(min_diff, diff)\n    \n    return min_diff\n```"
  },
  {
    "id":164,
    "response":"```python\ndef number_ctr(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিং-এ সংখ্যাসূচক মান (0-9) গণনা করে রেটার্ন করে।\n    \n    Args:\n        s (str): স্ট্রিং ইনপুট\n        \n    Returns:\n        int: সংখ্যাসূচক মানের সংখ্যা\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count\n```"
  },
  {
    "id":165,
    "response":"```python\ndef is_polite(n):\n    \"\"\"\n    Check if a number n is a polite number.\n    \n    A polite number is a positive integer that can be written as the sum of two or more consecutive positive integers.\n    \n    Args:\n        n (int): The number to check.\n        \n    Returns:\n        bool: True if n is a polite number, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    # A number is polite if and only if it is not a power of 2\n    # Powers of 2 cannot be expressed as the sum of consecutive positive integers\n    # This is because powers of 2 have only one odd divisor (1)\n    \n    # Check if n is a power of 2\n    # A number is a power of 2 if (n & (n-1)) == 0 and n > 0\n    return (n & (n - 1)) != 0\n```"
  },
  {
    "id":166,
    "response":"```python\ndef pair_wise(lst):\n    \"\"\"\n    প্রদত্ত তালিকার সমস্ত পরপর আইটেম জুড়ি উপর পুনরাবৃত্তি করে ফেরত দেয়।\n    \n    Args:\n        lst: প্রদত্ত তালিকা\n        \n    Returns:\n        পরপর আইটেম জুড়ির একটি তালিকা (প্রতিটি জুড়ি হবে দুটি পরপর আইটেমের সাথে)\n        \n    Example:\n        pair_wise([1, 2, 3, 4]) -> [(1, 2), (2, 3), (3, 4)]\n    \"\"\"\n    if len(lst) <= 1:\n        return []\n    \n    result = []\n    for i in range(len(lst) - 1):\n        result.append((lst[i], lst[i + 1]))\n    \n    return result\n```"
  },
  {
    "id":167,
    "response":"```python\ndef get_Pairs_Count(lst, sum, n2):\n    \"\"\"\n    জোড়ার সংখ্যা গণনা করে যার যোগফল sum এর সমান।\n    \n    Parameters:\n    lst: একটি সংখ্যা বিশিষ্ট লিস্ট\n    sum: যোগফলের মান\n    n2: অতিরিক্ত প্যারামিটার (এখানে ব্যবহার করা হয়নি কারণ এটি প্রয়োজন নেই)\n    \n    Returns:\n    int: যোগফল sum এর সমান জোড়ার সংখ্যা\n    \"\"\"\n    count = 0\n    n = len(lst)\n    \n    # সব জোড়া চেক করা হয়\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lst[i] + lst[j] == sum:\n                count += 1\n    \n    return count\n```"
  },
  {
    "id":168,
    "response":"```python\ndef check_Odd_Parity(n):\n    \"\"\"\n    Check if a number has odd parity (i.e., has an odd number of 1-bits in its binary representation).\n    \n    Args:\n        n (int): The integer to check for odd parity.\n    \n    Returns:\n        bool: True if the number has odd parity, False otherwise.\n    \"\"\"\n    # Count the number of 1-bits in the binary representation of n\n    ones_count = bin(n).count('1')\n    \n    # Return True if the count of 1-bits is odd\n    return ones_count % 2 == 1\n```"
  },
  {
    "id":169,
    "response":"```python\ndef Diff(lst, lst2):\n    \"\"\"\n    Return the difference between two lists.\n    Returns elements that are in the first list but not in the second list.\n    \"\"\"\n    return [item for item in lst if item not in lst2]\n```"
  },
  {
    "id":170,
    "response":"```python\ndef odd_Num_Sum(n):\n    \"\"\"\n    প্রথম n অদ্ভুত প্রাকৃতিক সংখ্যার চতুর্থ ক্ষমতার যোগফল খুঁজে বের করে।\n    \n    অদ্ভুত প্রাকৃতিক সংখ্যা হল অবশ্যই একটি বিজোড় সংখ্যা।\n    চতুর্থ ক্ষমতা হল x^4।\n    \n    Parameters:\n    n (int): প্রথম n অদ্ভুত প্রাকৃতিক সংখ্যা নির্দেশ করে।\n    \n    Returns:\n    int: প্রথম n অদ্ভুত প্রাকৃতিক সংখ্যার চতুর্থ ক্ষমতার যোগফল।\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        odd_num = 2 * i - 1  # প্রথম n টি বিজোড় সংখ্যা\n        total += odd_num ** 4\n    return total\n```"
  },
  {
    "id":171,
    "response":"```python\ndef check_expression(s):\n    \"\"\"\n    Check if the given expression is balanced (has matching parentheses, brackets, and braces).\n    \n    Args:\n        s (str): The expression string to check.\n    \n    Returns:\n        bool: True if the expression is balanced, False otherwise.\n    \"\"\"\n    stack = []\n    # Define mapping of closing brackets to opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        # If it's an opening bracket, push to stack\n        if char in '({[':\n            stack.append(char)\n        # If it's a closing bracket\n        elif char in ')}]':\n            # If stack is empty or the top doesn't match, it's unbalanced\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    \n    # If stack is empty, all brackets were matched\n    return len(stack) == 0\n```"
  },
  {
    "id":172,
    "response":"```python\ndef remove_length(s, k):\n    \"\"\"\n    প্রদত্ত স্ট্রিংয়ের k দৈর্ঘ্যের সমস্ত শব্দকে সরিয়ে দেয়।\n    \n    Args:\n        s (str): প্রদত্ত স্ট্রিং\n        k (int): দৈর্ঘ্যের সীমা, k দৈর্ঘ্যের শব্দগুলি সরিয়ে দেয়\n    \n    Returns:\n        str: k দৈর্ঘ্যের শব্দগুলি সরিয়ে দেওয়া স্ট্রিং\n    \"\"\"\n    words = s.split()\n    filtered_words = [word for word in words if len(word) != k]\n    return ' '.join(filtered_words)\n```"
  },
  {
    "id":173,
    "response":"```python\ndef occurrence_substring(s, s2):\n    \"\"\"\n    Find all occurrences of substring s2 in string s and return a list of starting indices.\n    \n    Args:\n        s (str): The main string to search in.\n        s2 (str): The substring to search for.\n    \n    Returns:\n        list: A list of starting indices where s2 occurs in s. If not found, returns empty list.\n    \"\"\"\n    if not s2:\n        return []\n    \n    indices = []\n    start = 0\n    \n    while True:\n        index = s.find(s2, start)\n        if index == -1:\n            break\n        indices.append(index)\n        start = index + 1\n    \n    return indices\n```"
  },
  {
    "id":174,
    "response":"```python\ndef check_email(s):\n    \"\"\"\n    Check if a string is a valid email address without using regular expressions.\n    \n    Args:\n        s (str): The string to validate as an email address.\n        \n    Returns:\n        bool: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Check if the string is empty or None\n    if not s or not isinstance(s, str):\n        return False\n    \n    # Split the string by '@' to get local and domain parts\n    parts = s.split('@')\n    \n    # Must have exactly one '@' symbol\n    if len(parts) != 2:\n        return False\n    \n    local, domain = parts\n    \n    # Both local and domain parts must be non-empty\n    if not local or not domain:\n        return False\n    \n    # Local part should not start or end with a dot\n    if local.startswith('.') or local.endswith('.'):\n        return False\n    \n    # Domain part should contain at least one dot and not start or end with a dot\n    if domain.startswith('.') or domain.endswith('.'):\n        return False\n    \n    # Domain part should have at least one dot\n    if '.' not in domain:\n        return False\n    \n    # Domain part should not have consecutive dots\n    if '..' in domain:\n        return False\n    \n    # Check that the domain has at least one valid character after the first dot\n    domain_parts = domain.split('.')\n    if len(domain_parts) < 2:\n        return False\n    \n    # Each domain part should not be empty\n    for part in domain_parts:\n        if not part:\n            return False\n    \n    # Local part can contain letters, digits, dots, underscores, and hyphens\n    # But no consecutive dots or hyphens at the start\/end\n    for char in local:\n        if not (char.isalnum() or char in '._-'):\n            return False\n    \n    # Local part should not have consecutive dots or hyphens\n    if '..' in local or '--' in local or '.-' in local or '-.' in local:\n        return False\n    \n    # Local part should not start or end with a hyphen or dot\n    if local.startswith('-') or local.endswith('-') or local.startswith('.') or local.endswith('.'):\n        return False\n    \n    # Check that domain part has valid characters (letters, digits, hyphens, dots)\n    for char in domain:\n        if not (char.isalnum() or char in '-"
  },
  {
    "id":175,
    "response":"```python\ndef odd_position(lst):\n    \"\"\"\n    Check if each odd-positioned element in the list contains an odd number.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        bool: True if every element at odd positions (1, 3, 5, ...) is odd, False otherwise\n    \"\"\"\n    for i in range(1, len(lst), 2):  # iterate through odd positions (1-indexed)\n        if lst[i] % 2 == 0:  # if the element at odd position is even\n            return False\n    return True\n```"
  },
  {
    "id":176,
    "response":"```python\ndef count_vowels(s):\n    \"\"\"\n    Count the number of vowels in a given string.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        int: Number of vowels in the string\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count\n```"
  },
  {
    "id":177,
    "response":"```python\ndef find_Sum(lst, n):\n    \"\"\"\n    Find the sum of elements that do not repeat in the given list.\n    \n    Args:\n        lst: List of integers\n        n: Length of the list (optional, for validation)\n    \n    Returns:\n        Sum of unique elements (elements that appear only once)\n    \"\"\"\n    # Count frequency of each element\n    freq = {}\n    for num in lst:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Sum elements that appear only once\n    total_sum = 0\n    for num, count in freq.items():\n        if count == 1:\n            total_sum += num\n    \n    return total_sum\n```"
  },
  {
    "id":178,
    "response":"```python\ndef pack_consecutive_duplicates(lst):\n    \"\"\"\n    Pack consecutive duplicates from a list into sublists.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A list of sublists, where each sublist contains consecutive duplicate elements\n    \"\"\"\n    if not lst:\n        return []\n    \n    result = []\n    current_group = [lst[0]]\n    \n    for i in range(1, len(lst)):\n        if lst[i] == lst[i-1]:\n            current_group.append(lst[i])\n        else:\n            result.append(current_group)\n            current_group = [lst[i]]\n    \n    # Don't forget the last group\n    result.append(current_group)\n    \n    return result\n```"
  },
  {
    "id":179,
    "response":"```python\ndef unique_sublists(lst):\n    \"\"\"\n    Count the number of unique sublists in a given list.\n    \n    Args:\n        lst: A list of lists (sublists)\n    \n    Returns:\n        int: The number of unique sublists\n    \"\"\"\n    if not lst:\n        return 0\n    \n    # Convert each sublist to a tuple (since lists are unhashable)\n    # and use a set to store unique sublists\n    unique_sublists_set = set()\n    \n    for sublist in lst:\n        # Convert list to tuple for hashing\n        unique_sublists_set.add(tuple(sublist))\n    \n    return len(unique_sublists_set)\n```"
  },
  {
    "id":180,
    "response":"```python\ndef find_combinations(lst):\n    \"\"\"\n    Find all possible combinations of tuples from the given list of tuples.\n    \n    Args:\n        lst: A list of tuples\n        \n    Returns:\n        A list of tuples, where each tuple represents a combination of elements\n        from the original list of tuples.\n    \"\"\"\n    result = []\n    \n    # Handle empty list\n    if not lst:\n        return result\n    \n    # Generate all possible combinations of the tuples\n    # We'll use a recursive approach to generate combinations of different lengths\n    def generate_combinations(current_combination, remaining_tuples):\n        # Add the current combination to result if it's not empty\n        if current_combination:\n            result.append(tuple(current_combination))\n        \n        # If there are more tuples to process, generate combinations\n        if remaining_tuples:\n            # Take the first tuple and generate combinations with and without it\n            first_tuple = remaining_tuples[0]\n            rest_tuples = remaining_tuples[1:]\n            \n            # Include the first tuple in the combination\n            generate_combinations(current_combination + [first_tuple], rest_tuples)\n            \n            # Exclude the first tuple from the combination\n            generate_combinations(current_combination, rest_tuples)\n    \n    # Start the recursive generation\n    generate_combinations([], lst)\n    \n    return result\n```"
  },
  {
    "id":181,
    "response":"```python\ndef count_divisors(n):\n    \"\"\"\n    একটি সংখ্যার বিভাজকগুলির সংখ্যা গণনা করে এবং তা জোড় কিনা অজোড় কিনা চেক করে।\n    \n    Parameters:\n    n (int): বিভাজকগুলির জন্য পরীক্ষা করা হবে সংখ্যা।\n    \n    Returns:\n    str: \"জোড়\" অথবা \"অজোড়\" যদি বিভাজকের সংখ্যা জোড় অথবা অজোড় হয়।\n    \"\"\"\n    if n <= 0:\n        return \"অজোড়\"\n    \n    # বিভাজকগুলির সংখ্যা গণনা\n    divisor_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                divisor_count += 1  # পূর্ণ বর্গ হলে একবার গণনা\n            else:\n                divisor_count += 2  # i এবং n\/\/i উভয়ই বিভাজক\n    \n    # বিভাজকের সংখ্যা জোড় কিনা অজোড় চেক করা\n    if divisor_count % 2 == 0:\n        return \"জোড়\"\n    else:\n        return \"অজোড়\"\n```"
  },
  {
    "id":182,
    "response":"```python\ndef Odd_Length_Sum(lst):\n    \"\"\"\n    Calculate the sum of all subarray sums where the subarray length is odd.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        int: Sum of all subarray sums with odd lengths\n    \"\"\"\n    total_sum = 0\n    n = len(lst)\n    \n    # Iterate through all possible odd lengths (1, 3, 5, ...)\n    for length in range(1, n + 1, 2):\n        # For each odd length, iterate through all possible starting positions\n        for start in range(n - length + 1):\n            # Calculate sum of subarray from start to start + length - 1\n            subarray_sum = sum(lst[start:start + length])\n            total_sum += subarray_sum\n    \n    return total_sum\n```"
  },
  {
    "id":183,
    "response":"```python\ndef rgb_to_hsv(r, g, b):\n    \"\"\"\n    Convert RGB color to HSV color.\n    \n    Parameters:\n    r, g, b: Integers in range [0, 255] representing red, green, and blue components.\n    \n    Returns:\n    A tuple (h, s, v) where:\n    - h is hue in degrees [0, 360]\n    - s is saturation in range [0, 1]\n    - v is value in range [0, 1]\n    \"\"\"\n    # Normalize RGB values to range [0, 1]\n    r, g, b = r \/ 255.0, g \/ 255.0, b \/ 255.0\n    \n    # Find maximum and minimum values\n    max_val = max(r, g, b)\n    min_val = min(r, g, b)\n    diff = max_val - min_val\n    \n    # Calculate value (V)\n    v = max_val\n    \n    # Calculate saturation (S)\n    if diff == 0:\n        s = 0\n    else:\n        s = diff \/ max_val\n    \n    # Calculate hue (H)\n    if diff == 0:\n        h = 0\n    elif max_val == r:\n        h = (60 * ((g - b) \/ diff) % 6)\n    elif max_val == g:\n        h = (60 * ((b - r) \/ diff) + 2)\n    else:  # max_val == b\n        h = (60 * ((r - g) \/ diff) + 4)\n    \n    return (h, s, v)\n```"
  },
  {
    "id":184,
    "response":"```python\ndef mul_even_odd(lst):\n    \"\"\"\n    Find the product of the first even number and the first odd number in the list.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        int: Product of first even and first odd number, or 0 if either is missing\n    \"\"\"\n    even_found = False\n    odd_found = False\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0:\n            if not even_found:\n                first_even = num\n                even_found = True\n        else:\n            if not odd_found:\n                first_odd = num\n                odd_found = True\n                \n        # Early exit if both found\n        if even_found and odd_found:\n            break\n    \n    if even_found and odd_found:\n        return first_even * first_odd\n    else:\n        return 0\n```"
  },
  {
    "id":185,
    "response":"```python\ndef tuple_str_int(s):\n    \"\"\"\n    একটি টুপল স্ট্রিংকে পূর্ণসংখ্যা টুপলে রূপান্তর করে।\n    \n    Args:\n        s (tuple): স্ট্রিং থেকে পূর্ণসংখ্যা টুপলে রূপান্তর করার জন্য স্ট্রিং টুপল।\n    \n    Returns:\n        tuple: পূর্ণসংখ্যা টুপল।\n    \"\"\"\n    return tuple(int(x) for x in s)\n```"
  },
  {
    "id":186,
    "response":"```python\ndef right_insertion(lst, n):\n    \"\"\"\n    একটি সংখ্যার জন্য সঠিক সন্নিবেশ পয়েন্ট সনাক্ত করে ফেরত দেয়।\n    যদি সংখ্যাটি এখন থাকে তবে সেটি সংখ্যাগুলির সাথে সামঞ্জস্য করে দেয়।\n    \n    Parameters:\n    lst: একটি সংখ্যা বিশিষ্ট তালিকা\n    n: যা সন্নিবেশ করা হবে\n    \n    Returns:\n    সন্নিবেশের পয়েন্ট (স্থান) যা সংখ্যাগুলির উপর ভিত্তি করে নির্ধারিত হয়\n    \"\"\"\n    # সংখ্যাগুলি সাজানো হয়েছে তাই আমরা সর্বোচ্চ স্থান নির্ধারণ করি\n    if not lst:\n        return 0\n    \n    # যদি সংখ্যা তালিকার প্রথমে থাকে তবে 0 রিটার্ন করা হবে\n    if n <= lst[0]:\n        return 0\n    \n    # যদি সংখ্যা তালিকার শেষে থাকে তবে তালিকার দৈর্ঘ্য রিটার্ন করা"
  },
  {
    "id":187,
    "response":"```python\ndef text_match_three(s):\n    \"\"\"\n    Check if a string contains 'a' followed by exactly three 'b's.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if 'a' is followed by 'bbb', otherwise False.\n    \"\"\"\n    # Look for 'a' followed by 'bbb'\n    pattern = 'abbb'\n    return pattern in s\n```"
  },
  {
    "id":188,
    "response":"```python\ndef new_tuple(lst, s):\n    \"\"\"\n    Create a new tuple by combining elements from the list and string.\n    \n    Args:\n        lst: A list of elements\n        s: A string\n    \n    Returns:\n        A tuple containing elements from the list followed by characters from the string\n    \"\"\"\n    # Convert list to tuple and concatenate with string characters\n    return tuple(lst) + tuple(s)\n```"
  },
  {
    "id":189,
    "response":"```python\ndef perimeter_polygon(n, n2):\n    \"\"\"\n    একটি নিয়মিত বহুভুজের পরিধি গণনা করে।\n    \n    প্যারামিটার:\n    n: বহুভুজের বাহুর সংখ্যা (int)\n    n2: বাহুর দৈর্ঘ্য (int)\n    \n    ফলাফল:\n    বহুভুজের পরিধি (int)\n    \"\"\"\n    if n <= 0 or n2 <= 0:\n        return 0\n    \n    return n * n2\n```"
  },
  {
    "id":190,
    "response":"```python\ndef even_position(lst):\n    \"\"\"\n    Check if every even-indexed element in the list is even.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        bool: True if every element at even position (0, 2, 4, ...) is even, False otherwise\n    \"\"\"\n    for i in range(0, len(lst), 2):  # Iterate over even positions: 0, 2, 4, ...\n        if lst[i] % 2 != 0:  # If the element at even position is odd\n            return False\n    return True\n```"
  },
  {
    "id":191,
    "response":"```python\ndef remove_nested(tup):\n    \"\"\"\n    প্রদত্ত টিউপেল থেকে নেস্টেড রেকর্ড সরানোর জন্য একটি ফাংশন।\n    নেস্টেড রেকর্ড হল যে কোন টিউপেল যা অন্য টিউপেল বা লিস্টের ভেতরে আছে।\n    এই ফাংশন সব নেস্টেড টিউপেল কে সরিয়ে দেয় এবং প্রতিটি প্রতিটি মান একটি স্ট্রিং হিসেবে রাখে।\n    \n    Args:\n        tup: প্রদত্ত টিউপেল\n        \n    Returns:\n        নেস্টেড রেকর্ড সরিয়ে দেওয়া স্ট্রিং এর টিউপেল\n    \"\"\"\n    result = []\n    \n    for item in tup:\n        if isinstance(item, tuple):\n            # নেস্টেড টিউপেল থাকলে এটি আরও পরীক্ষা করা হবে\n            result.extend(remove_nested(item))\n        else:\n            # নেস্টেড না হলে স্ট্রিং হিসেবে যোগ করা হবে\n            result.append(str(item))\n    \n    return tuple(result)\n```"
  },
  {
    "id":192,
    "response":"```python\ndef count_list(lst):\n    \"\"\"\n    একটি তালিকার দৈর্ঘ্য গণনা করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    lst: একটি তালিকা (list)\n    \n    ফেরত দেয়:\n    তালিকার দৈর্ঘ্য (int)\n    \"\"\"\n    return len(lst)\n```"
  },
  {
    "id":193,
    "response":"```python\ndef last(lst, n, n2):\n    \"\"\"\n    Find the last occurrence of an element in a sorted array.\n    \n    Args:\n        lst: A sorted list of elements\n        n: The target element to search for\n        n2: Another parameter (not used in the function)\n    \n    Returns:\n        The index of the last occurrence of n in lst, or -1 if not found\n    \"\"\"\n    try:\n        # Since the array is sorted, we can use binary search to find the last occurrence\n        left, right = 0, len(lst) - 1\n        result = -1\n        \n        while left <= right:\n            mid = (left + right) \/\/ 2\n            if lst[mid] == n:\n                result = mid  # Found the element, but continue searching to the right\n                left = mid + 1\n            elif lst[mid] < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return result\n    except:\n        return -1\n```"
  },
  {
    "id":194,
    "response":"```python\ndef text_starta_endb(s):\n    \"\"\"\n    Check if a string starts with 'a' and ends with 'b'.\n    \n    Args:\n        s (str): The input string to check.\n    \n    Returns:\n        bool: True if the string starts with 'a' and ends with 'b', False otherwise.\n    \"\"\"\n    if s.startswith('a') and s.endswith('b'):\n        return True\n    return False\n```"
  },
  {
    "id":195,
    "response":"```python\ndef cheap_items(lst, n):\n    \"\"\"\n    একটি ডেটাসেট থেকে n - সস্তা মূল্যের আইটেমগুলি খুঁজে বের করে।\n    \n    প্যারামিটার:\n    lst: একটি লিস্ট যার মধ্যে আইটেমের মূল্য থাকে\n    n: সস্তা মূল্যের আইটেমগুলির সংখ্যা\n    \n    রিটার্ন:\n    মূল্য কম থাকা প্রথম n টি আইটেমের লিস্ট\n    \"\"\"\n    if not lst or n <= 0:\n        return []\n    \n    # মূল্য কম থাকা আইটেমগুলি সাজানো\n    sorted_items = sorted(lst)\n    \n    # প্রথম n টি মূল্য কম আইটেম\n    return sorted_items[:n]\n```"
  },
  {
    "id":196,
    "response":"```python\ndef return_sum(dct):\n    \"\"\"\n    Return the sum of all values in the given dictionary.\n    \n    Args:\n        dct (dict): A dictionary with numeric values.\n    \n    Returns:\n        int\/float: The sum of all values in the dictionary.\n    \"\"\"\n    return sum(dct.values())\n```"
  },
  {
    "id":197,
    "response":"```python\ndef sum_in_range(l, r):\n    \"\"\"\n    দেওয়া হয়েছে l এবং r এর মধ্যে থাকা সমস্ত বিজোড় প্রাকৃতিক সংখ্যার যোগফল খুঁজে বের করে।\n    \n    Parameters:\n    l (int): শুরুর সংখ্যা (অবশ্যই প্রাকৃতিক সংখ্যা)\n    r (int): শেষ সংখ্যা (অবশ্যই প্রাকৃতিক সংখ্যা)\n    \n    Returns:\n    int: বিজোড় সংখ্যার যোগফল\n    \"\"\"\n    total = 0\n    # l থেকে r এর মধ্যে সব বিজোড় সংখ্যা কে যোগ করা হয়\n    for num in range(l, r + 1):\n        if num % 2 == 1:  # যদি সংখ্যা বিজোড় হয়\n            total += num\n    return total\n```"
  },
  {
    "id":198,
    "response":"```python\ndef _sum(lst):\n    \"\"\"\n    Calculate the sum of all elements in a list.\n    \n    Args:\n        lst: A list of numbers\n        \n    Returns:\n        The sum of all elements in the list\n    \"\"\"\n    return sum(lst)\n```"
  },
  {
    "id":199,
    "response":"```python\ndef left_rotate(n, n2):\n    \"\"\"\n    একটি সংখ্যার বিটগুলি বাম দিকে ঘোরায়।\n    \n    Parameters:\n    n (int): ঘোরানো হবে এই সংখ্যার বিটগুলি\n    n2 (int): ঘোরানোর পরিমাণ (বিটের সংখ্যা)\n    \n    Returns:\n    int: বাম দিকে ঘোরানো সংখ্যা\n    \"\"\"\n    # প্রদত্ত সংখ্যার বিটগুলি নির্দেশ করে\n    # বাম দিকে ঘোরানোর জন্য, আমরা বাম দিকে ঘোরানো বিটগুলি প্রয়োগ করব\n    # প্রথমে সংখ্যার বিট সংখ্যা নির্ণয় করা হবে\n    # এবং ঘোরানোর পরিমাণ নির্দেশ করা হবে\n    # আমরা সংখ্যার বিটগুলি বাম দিকে ঘোরাব যেমন সাধারণ বাইনারি সংখ্যার ঘোরানো\n    \n    # প্রদত্ত n এর বিটগুলি নির্ণয় করা হয়\n    # বাম দিক"
  },
  {
    "id":200,
    "response":"```python\ndef remove_all_spaces(s):\n    \"\"\"\n    একটি স্ট্রিং থেকে সব হোয়াইটস্পেস অপসারণ করে ফেরত দেয়।\n    \n    Args:\n        s (str): হোয়াইটস্পেস অপসারণের জন্য দেয়া স্ট্রিং\n        \n    Returns:\n        str: হোয়াইটস্পেস বিহীন স্ট্রিং\n    \"\"\"\n    return s.replace(\" \", \"\")\n```"
  },
  {
    "id":201,
    "response":"```python\ndef test_three_equal(n, n2, n3):\n    \"\"\"\n    তিনটি পূর্ণসংখ্যা থেকে সমান সংখ্যার সংখ্যা গণনা করে।\n    \n    Parameters:\n    n, n2, n3: তিনটি পূর্ণসংখ্যা\n    \n    Returns:\n    সমান সংখ্যার সংখ্যা (0, 1 বা 2 বা 3)\n    \"\"\"\n    count = 0\n    if n == n2:\n        count += 1\n    if n == n3:\n        count += 1\n    if n2 == n3:\n        count += 1\n    \n    # যদি সব সমান হয়, তবে 3; যদি দুটি সমান হয়, তবে 2; যদি একটি সমান হয়, তবে 1; অথবা 0\n    # কিন্তু এখানে আমরা সমান সংখ্যা গণনা করছি তাই সংখ্যা গণনা করা হয়েছে\n    return count\n```"
  },
  {
    "id":202,
    "response":"```python\ndef count_Rotation(lst, n):\n    \"\"\"\n    Calculate the number of rotations needed to make the array sorted in ascending order.\n    \n    Args:\n        lst: A list of integers (assumed to be rotated)\n        n: Length of the array\n    \n    Returns:\n        The number of rotations required to sort the array in ascending order\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    # Find the pivot point where the sorted array would be split\n    # In a rotated sorted array, the pivot is the point where lst[i] > lst[i+1]\n    pivot = -1\n    for i in range(n - 1):\n        if lst[i] > lst[i + 1]:\n            pivot = i\n            break\n    \n    # If no pivot found, array is already sorted\n    if pivot == -1:\n        return 0\n    \n    # The number of rotations is the index of the pivot\n    return pivot + 1\n```"
  },
  {
    "id":203,
    "response":"```python\ndef is_Perfect_Square(n):\n    \"\"\"\n    Check if a given number is a perfect square.\n    \n    Args:\n        n (int): The number to check\n        \n    Returns:\n        bool: True if n is a perfect square, False otherwise\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n    \n    # Find the square root\n    sqrt_n = int(n ** 0.5)\n    \n    # Check if the square of the square root equals n\n    return sqrt_n * sqrt_n == n\n```"
  },
  {
    "id":204,
    "response":"```python\ndef is_Product_Even(lst, n):\n    \"\"\"\n    Check if the product of the first n elements in the list is even.\n    \n    Args:\n        lst: List of integers\n        n: Number of elements to consider from the start of the list\n    \n    Returns:\n        True if the product is even, False otherwise\n    \"\"\"\n    # Handle edge cases\n    if n <= 0 or n > len(lst):\n        return False\n    \n    # Calculate the product of first n elements\n    product = 1\n    for i in range(n):\n        product *= lst[i]\n    \n    # Check if the product is even\n    return product % 2 == 0\n```"
  },
  {
    "id":205,
    "response":"```python\ndef max_sum_list(lst):\n    \"\"\"\n    Find the sublist with the maximum sum of elements.\n    \n    Args:\n        lst: A list of lists (or sublists) of numbers.\n    \n    Returns:\n        The sublist with the maximum sum of elements.\n        If the input is empty or all sublists are empty, returns an empty list.\n    \"\"\"\n    if not lst:\n        return []\n    \n    max_sum = float('-inf')\n    max_sum_list = []\n    \n    for sublist in lst:\n        if not sublist:\n            continue\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_list = sublist\n    \n    return max_sum_list\n```"
  },
  {
    "id":206,
    "response":"```python\ndef max_run_uppercase(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিং-এ বড় অক্ষরের সর্বোচ্চ সংখ্যা খুঁজে বের করে।\n    \n    Args:\n        s (str): প্রদত্ত স্ট্রিং\n        \n    Returns:\n        int: বড় অক্ষরের সর্বোচ্চ সংখ্যা\n    \"\"\"\n    count = 0\n    max_count = 0\n    \n    for char in s:\n        if char.isupper():\n            count += 1\n            max_count = max(max_count, count)\n        else:\n            count = 0\n    \n    return max_count\n```"
  },
  {
    "id":207,
    "response":"```python\ndef first_odd(lst):\n    \"\"\"\n    প্রদত্ত সংখ্যার তালিকায় প্রথম অদ্ভুত সংখ্যাটি পাওয়া যায়।\n    \n    অদ্ভুত সংখ্যা হল যে সংখ্যা যা সম হয় না (অর্থাৎ বিজোড় সংখ্যা)।\n    \n    Args:\n        lst: সংখ্যার তালিকা\n        \n    Returns:\n        প্রথম অদ্ভুত (বিজোড়) সংখ্যা। যদি কোন অদ্ভুত সংখ্যা না থাকে তবে None রিটার্ন করে।\n    \"\"\"\n    for num in lst:\n        if num % 2 != 0:\n            return num\n    return None\n```"
  },
  {
    "id":208,
    "response":"```python\ndef check_K(tup, k):\n    \"\"\"\n    Check if the value k exists in the given tuple.\n    \n    Args:\n        tup: A tuple to search in.\n        k: The value to check for existence.\n    \n    Returns:\n        bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tup\n```"
  },
  {
    "id":209,
    "response":"```python\ndef check_smaller(tup, tup2):\n    \"\"\"\n    Check if each element in the second tuple is smaller than the corresponding element in the first tuple.\n    \n    Args:\n        tup: First tuple\n        tup2: Second tuple\n    \n    Returns:\n        bool: True if every element in tup2 is smaller than the corresponding element in tup, False otherwise\n    \"\"\"\n    if len(tup) != len(tup2):\n        return False\n    \n    for i in range(len(tup)):\n        if tup2[i] >= tup[i]:\n            return False\n    \n    return True\n```"
  },
  {
    "id":210,
    "response":"```python\ndef count_variable(n, n2, n3, n4):\n    \"\"\"\n    একটি ফাংশন যা উপাদানগুলোর পুনরাবৃত্তির সংখ্যা দেখায়।\n    যেমন: n হল 2 হলে এটি পুনরাবৃত্তি করবে 2 বার, এবং এর মতো অন্য উপাদানগুলোও সেই পুনরাবৃত্তির সংখ্যা অনুসারে প্রদর্শিত হবে।\n    \n    Parameters:\n    n, n2, n3, n4: উপাদানগুলো যারা পুনরাবৃত্তি করা হবে\n    \n    Returns:\n    একটি লিস্ট যেখানে প্রতিটি উপাদান তাদের পুনরাবৃত্তির সংখ্যা অনুসারে পুনরাবৃত্তি করা হয়েছে।\n    \"\"\"\n    result = []\n    for item in [n, n2, n3, n4]:\n        result.extend([item] * item)\n    return result\n```"
  },
  {
    "id":211,
    "response":"```python\ndef check_identical(lst, lst2):\n    \"\"\"\n    Check if two lists are identical (same elements in same order).\n    \n    Args:\n        lst: First list to compare\n        lst2: Second list to compare\n        \n    Returns:\n        bool: True if both lists are identical, False otherwise\n    \"\"\"\n    return lst == lst2\n```"
  },
  {
    "id":212,
    "response":"```python\ndef road_rd(s):\n    \"\"\"\n    Replace all occurrences of 'road' with 'rd.' in the given string.\n    \n    Args:\n        s (str): The input string where 'road' needs to be replaced with 'rd.'\n    \n    Returns:\n        str: The string with 'road' replaced by 'rd.'\n    \"\"\"\n    return s.replace('road', 'rd.')\n```"
  },
  {
    "id":213,
    "response":"```python\ndef string_length(s):\n    \"\"\"\n    একটি স্ট্রিং এর দৈর্ঘ্য খুঁজে বের করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    s (str): দৈর্ঘ্য খুঁজে বের করতে হবে স্ট্রিং এর মান\n    \n    রিটার্ন:\n    int: স্ট্রিং এর দৈর্ঘ্য\n    \"\"\"\n    return len(s)\n```"
  },
  {
    "id":214,
    "response":"```python\ndef rombus_area(n, n2):\n    \"\"\"\n    রম্বসের ক্ষেত্রফল বের করে তোলে।\n    \n    রম্বসের ক্ষেত্রফল = (দুইটি কর্ণের গুণফল) \/ 2\n    \n    Parameters:\n    n (float): রম্বসের প্রথম কর্ণের দৈর্ঘ্য\n    n2 (float): রম্বসের দ্বিতীয় কর্ণের দৈর্ঘ্য\n    \n    Returns:\n    float: রম্বসের ক্ষেত্রফল\n    \"\"\"\n    return (n * n2) \/ 2\n```"
  },
  {
    "id":215,
    "response":"```python\ndef sort_by_dnf(lst):\n    \"\"\"\n    Sorts an array containing only 0, 1, and 2 using the DNF (Dutch National Flag) algorithm\n    without using any built-in sorting functions.\n    \n    Args:\n        lst: List containing only 0, 1, and 2\n        \n    Returns:\n        Sorted list with all 0s followed by 1s followed by 2s\n    \"\"\"\n    if not lst:\n        return lst\n    \n    # Using three pointers: low, mid, high\n    low = 0\n    mid = 0\n    high = len(lst) - 1\n    \n    while mid <= high:\n        if lst[mid] == 0:\n            # Swap low and mid elements\n            lst[low], lst[mid] = lst[mid], lst[low]\n            low += 1\n            mid += 1\n        elif lst[mid] == 1:\n            # Move mid pointer forward\n            mid += 1\n        else:  # lst[mid] == 2\n            # Swap mid and high elements\n            lst[mid], lst[high] = lst[high], lst[mid]\n            high -= 1\n    \n    return lst\n```"
  },
  {
    "id":216,
    "response":"```python\ndef clear_tuple(tup):\n    \"\"\"\n    প্রদত্ত টুপলের মানগুলি সাফ করে দেয়।\n    এটি টুপলের মানগুলি প্রদত্ত করে যা প্রয়োজন অনুসারে সাফ করা হয়।\n    \n    প্রদত্ত:\n    tup: একটি টুপল যার মানগুলি সাফ করা হবে\n    \n    প্রত্যাশিত আউটপুট:\n    সাফ করা টুপল (সাধারণত শূন্য টুপল হবে)\n    \"\"\"\n    return ()\n```"
  },
  {
    "id":217,
    "response":"```python\ndef div_of_nums(lst, m, n):\n    \"\"\"\n    ল্যাম্বদা ফাংশন ব্যবহার করে সংখ্যার তালিকা থেকে m বা n দ্বারা বিভাজ্য সংখ্যা খুঁজে বের করে।\n    \n    Args:\n        lst: সংখ্যার তালিকা\n        m: প্রথম বিভাজক\n        n: দ্বিতীয় বিভাজক\n    \n    Returns:\n        যে সংখ্যাগুলো m বা n দ্বারা বিভাজ্য\n    \"\"\"\n    return list(filter(lambda x: x % m == 0 or x % n == 0, lst))\n```"
  },
  {
    "id":218,
    "response":"```python\ndef lower_ctr(s):\n    \"\"\"\n    Count the number of lowercase letters in a given string.\n    \n    Args:\n        s (str): The input string\n        \n    Returns:\n        int: The count of lowercase letters\n    \"\"\"\n    return sum(1 for char in s if char.islower())\n```"
  },
  {
    "id":219,
    "response":"```python\ndef count_duplic(lst):\n    \"\"\"\n    Count the frequency of consecutive duplicate elements in a list.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A list of tuples (element, frequency) for consecutive duplicates\n    \"\"\"\n    if not lst:\n        return []\n    \n    result = []\n    current_element = lst[0]\n    current_count = 1\n    \n    for i in range(1, len(lst)):\n        if lst[i] == current_element:\n            current_count += 1\n        else:\n            # Add the consecutive duplicate count to result\n            if current_count > 1:\n                result.append((current_element, current_count))\n            # Reset for new element\n            current_element = lst[i]\n            current_count = 1\n    \n    # Don't forget the last group\n    if current_count > 1:\n        result.append((current_element, current_count))\n    \n    return result\n```"
  },
  {
    "id":220,
    "response":"```python\ndef check_monthnum_number(n):\n    \"\"\"\n    Check if the given month number has 28 days.\n    \n    Args:\n        n (int): The month number (1-12)\n    \n    Returns:\n        bool: True if the month has 28 days, False otherwise\n    \"\"\"\n    # February has 28 days (29 in leap year, but the question asks about 28 days)\n    # So we check if the input is February (month 2)\n    return n == 2\n```"
  },
  {
    "id":221,
    "response":"```python\ndef merge_dictionaries(dct, dct2):\n    \"\"\"\n    দুটি অভিধান একক অভিব্যক্তিতে একত্রিত করে।\n    \n    Args:\n        dct: প্রথম অভিধান\n        dct2: দ্বিতীয় অভিধান\n    \n    Returns:\n        একটি নতুন অভিধান যা দুটি অভিধানের সংমিশ্রণ\n    \"\"\"\n    result = dct.copy()\n    for key, value in dct2.items():\n        if key in result:\n            if isinstance(result[key], list) and isinstance(value, list):\n                result[key].extend(value)\n            elif isinstance(result[key], dict) and isinstance(value, dict):\n                result[key] = merge_dictionaries(result[key], value)\n            else:\n                result[key] = value\n        else:\n            result[key] = value\n    return result\n```"
  },
  {
    "id":222,
    "response":"```python\ndef pass_validity(s):\n    \"\"\"\n    Check if a password is valid.\n    \n    A valid password must:\n    - Be at least 8 characters long\n    - Contain at least one uppercase letter\n    - Contain at least one lowercase letter\n    - Contain at least one digit\n    - Contain at least one special character (e.g., !@#$%^&*())\n    \n    Args:\n        s (str): The password to validate\n        \n    Returns:\n        bool: True if the password is valid, False otherwise\n    \"\"\"\n    if len(s) < 8:\n        return False\n    \n    has_upper = any(c.isupper() for c in s)\n    has_lower = any(c.islower() for c in s)\n    has_digit = any(c.isdigit() for c in s)\n    has_special = any(not c.isalnum() for c in s)\n    \n    return has_upper and has_lower and has_digit and has_special\n```"
  },
  {
    "id":223,
    "response":"```python\nimport re\n\ndef check_substring(s, s2):\n    \"\"\"\n    Check if string s starts with substring s2 using regex.\n    \n    Args:\n        s (str): The main string to check\n        s2 (str): The substring to check if it starts with\n    \n    Returns:\n        bool: True if s starts with s2, False otherwise\n    \"\"\"\n    # Use regex to check if s starts with s2\n    pattern = re.compile(f'^{re.escape(s2)}')\n    return bool(pattern.match(s))\n```"
  },
  {
    "id":224,
    "response":"```python\ndef remove_even(lst):\n    \"\"\"\n    একটি তালিকা থেকে সম সংখ্যা অপসারণ করে এবং বিজোড় সংখ্যা বাদ দেয়।\n    \n    Args:\n        lst: একটি পূর্ণসংখ্যা তালিকা\n        \n    Returns:\n        সম সংখ্যা বাদ দেওয়া তালিকা\n    \"\"\"\n    return [x for x in lst if x % 2 != 0]\n```"
  },
  {
    "id":225,
    "response":"```python\ndef access_elements(lst, indices):\n    \"\"\"\n    নির্দিষ্ট সূচকের একাধিক উপাদান অ্যাক্সেস করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    lst: তালিকা (list)\n    indices: সূচকের তালিকা (list of indices)\n    \n    রিটার্ন:\n    নির্দিষ্ট সূচকের উপাদানগুলির একটি তালিকা\n    \"\"\"\n    result = []\n    for index in indices:\n        if 0 <= index < len(lst):\n            result.append(lst[index])\n        else:\n            result.append(None)  # সূচক অবৈধ হলে None রেখে দেয়\n    return result\n```"
  },
  {
    "id":226,
    "response":"```python\ndef check_Type_Of_Triangle(n, n2, n3):\n    \"\"\"\n    ত্রিভুজের ধরন খুঁজে বের করে।\n    \n    Parameters:\n    n, n2, n3: ত্রিভুজের তিনটি বাহুর দৈর্ঘ্য\n    \n    Returns:\n    ত্রিভুজের ধরনের নাম (যেমন: \"সমবাহু\", \"সমদ্বিবাহু\", \"সমকোণী\", \"অসমবাহু\", \"অসম্ভব\")\n    \"\"\"\n    # ত্রিভুজের স্থাপনের জন্য তিনটি বাহুর মধ্যে কোনও একটি বাহু অন্য দুটির সমষ্টির চেয়ে বড় হয় না\n    if (n + n2 <= n3) or (n + n3 <= n2) or (n2 + n3 <= n):\n        return \"অসম্ভব\"\n    \n    # সমবাহু ত্রিভুজ\n    if n == n2 == n3:\n        return \"সমবাহু\"\n    \n    # সমদ্বিবাহু ত্রিভুজ\n    if n == n2 or n2 == n3 or n == n3:\n        return \"সমদ্বিবাহু\"\n    \n    # সমকোণী ত্রিভুজ (পিথাগোরাসের নীতি)\n    sides = sorted([n, n2, n3])\n    if abs(sides[0]**2 + sides[1]**2 - sides[2]**2) < 1e-9:"
  },
  {
    "id":227,
    "response":"```python\ndef sum_column(lst, n):\n    \"\"\"\n    Calculate the sum of a specific column in a list of lists.\n    \n    Args:\n        lst: A list of lists, where each inner list represents a row and contains values.\n        n: The index of the column (0-based) to sum.\n    \n    Returns:\n        The sum of the values in the specified column.\n    \n    Raises:\n        IndexError: If the column index n is out of bounds for any row.\n        TypeError: If the input is not a list of lists or contains non-numeric values.\n    \"\"\"\n    total = 0\n    for row in lst:\n        if not isinstance(row, list):\n            raise TypeError(\"All elements must be lists\")\n        if n >= len(row):\n            raise IndexError(f\"Column index {n} is out of bounds for row {row}\")\n        total += row[n]\n    return total\n```"
  },
  {
    "id":228,
    "response":"```python\ndef count_alpha_dig_spl(s):\n    \"\"\"\n    Count the number of alphabets, digits, and special characters in a given string.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        tuple: (count_alpha, count_digit, count_special)\n    \"\"\"\n    count_alpha = 0\n    count_digit = 0\n    count_special = 0\n    \n    for char in s:\n        if char.isalpha():\n            count_alpha += 1\n        elif char.isdigit():\n            count_digit += 1\n        else:\n            count_special += 1\n    \n    return count_alpha, count_digit, count_special\n```"
  },
  {
    "id":229,
    "response":"```python\nfrom collections import Counter\n\ndef second_frequent(lst):\n    \"\"\"\n    Find the second most frequent string in a list.\n    \n    Args:\n        lst: List of strings\n        \n    Returns:\n        The second most frequent string, or None if there is no second frequency\n    \"\"\"\n    if not lst:\n        return None\n    \n    # Count frequency of each string\n    counter = Counter(lst)\n    \n    # Get sorted frequencies in descending order\n    freqs = sorted(counter.values(), reverse=True)\n    \n    # If there's less than 2 unique elements, no second frequent element\n    if len(freqs) < 2:\n        return None\n    \n    # Get the second highest frequency\n    second_freq = freqs[1]\n    \n    # Find all strings with this frequency\n    second_frequent_strings = [item for item, freq in counter.items() if freq == second_freq]\n    \n    # Return the first one (or any one, since they're all equally frequent)\n    return second_frequent_strings[0] if second_frequent_strings else None\n```"
  },
  {
    "id":230,
    "response":"```python\ndef round_up(n, n2):\n    \"\"\"\n    একটি সংখ্যাকে নির্দিষ্ট সংখ্যায় গোলাকার করে।\n    \n    উদাহরণ: round_up(3.2, 5) হবে 5, কারণ 3.2 কে 5 এ গোলাকার করা হয়েছে।\n    \n    Parameters:\n    n (float): গোলাকার করার জন্য সংখ্যা\n    n2 (int\/float): গোলাকারের উদ্দেশ্য সংখ্যা\n    \n    Returns:\n    int\/float: গোলাকার সংখ্যা\n    \"\"\"\n    return n2 if n < n2 else n2\n```"
  },
  {
    "id":231,
    "response":"```python\ndef count_Pairs(lst, n):\n    \"\"\"\n    Count the number of pairs in the list where the sum of the pair equals n.\n    \n    Args:\n        lst: List of integers\n        n: Target sum for the pairs\n    \n    Returns:\n        Integer count of pairs that sum to n\n    \"\"\"\n    count = 0\n    seen = set()\n    \n    for num in lst:\n        complement = n - num\n        if complement in seen:\n            count += 1\n        seen.add(num)\n    \n    return count\n```"
  },
  {
    "id":232,
    "response":"```python\nimport re\n\ndef extract_max(s):\n    \"\"\"\n    রেজেক্স ব্যবহার করে একটি স্ট্রিং থেকে সর্বোচ্চ সংখ্যাসূচক মান বের করে।\n    \n    Args:\n        s (str): স্ট্রিং ইনপুট\n        \n    Returns:\n        int or None: সর্বোচ্চ সংখ্যাসূচক মান, যদি কোনো সংখ্যা না থাকে তবে None\n    \"\"\"\n    # সংখ্যা সংরক্ষণের জন্য রেজেক্স প্যাটার্ন\n    numbers = re.findall(r'-?\\d+\\.?\\d*', s)\n    \n    # সংখ্যা সংগ্রহ করা হয়েছে, তবে সংখ্যা হিসাবে পরিবর্তন করা হয়\n    numeric_values = []\n    for num_str in numbers:\n        if num_str:\n            try:\n                # সংখ্যা হিসাবে পরিবর্তন করা\n                value = float(num_str)\n                numeric_values.append(value)\n            except ValueError:\n                continue\n    \n    # যদি কোনো সংখ্যা না থাকে\n    if not numeric_values:\n        return None\n    \n    # সর্বোচ্চ সংখ্যা বের করা\n    return int(max(numeric_values))\n```"
  },
  {
    "id":233,
    "response":"```python\ndef get_key(dct):\n    \"\"\"\n    একটি অভিধান (dictionary) থেকে কী (key) পেতে ফাংশন লিখা হয়েছে।\n    এই ফাংশনটি অভিধানের সবগুলো কী প্রদান করে।\n    \n    Parameters:\n        dct (dict): অভিধান যার কী পাওয়া যাবে।\n    \n    Returns:\n        list: অভিধানের সবগুলো কী একটি তালিকা হিসাবে রাখা হয়।\n    \"\"\"\n    return list(dct.keys())\n```"
  },
  {
    "id":234,
    "response":"```python\ndef generate_matrix(n):\n    \"\"\"\n    Generate an n x n matrix filled with numbers from 1 to n*n \n    in a spiral order, starting from the top-left corner and moving \n    clockwise (right, down, left, up).\n    \n    Args:\n        n (int): Size of the matrix (n x n)\n    \n    Returns:\n        list[list[int]]: n x n matrix filled in spiral order\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    # Initialize the matrix with zeros\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Define the boundaries\n    top, bottom = 0, n - 1\n    left, right = 0, n - 1\n    \n    # Current number to fill\n    num = 1\n    \n    while top <= bottom and left <= right:\n        # Fill top row from left to right\n        for col in range(left, right + 1):\n            matrix[top][col] = num\n            num += 1\n        top += 1\n        \n        # Fill right column from top to bottom\n        for row in range(top, bottom + 1):\n            matrix[row][right] = num\n            num += 1\n        right -= 1\n        \n        # Fill bottom row from right to left (if there's still a row)\n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                matrix[bottom][col] = num\n                num += 1\n            bottom -= 1\n        \n        # Fill left column from bottom to top (if there's still a column)\n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                matrix[row][left] = num\n                num += 1\n            left += 1\n    \n    return matrix\n```"
  },
  {
    "id":235,
    "response":"```python\ndef slope(n, n2, n3, n4):\n    \"\"\"\n    Calculate the slope of a line given four points.\n    The function assumes the line is defined by two points (n, n2) and (n3, n4).\n    \n    Args:\n        n, n2: coordinates of the first point (x1, y1)\n        n3, n4: coordinates of the second point (x2, y2)\n    \n    Returns:\n        The slope of the line, or None if the line is vertical (undefined slope)\n    \"\"\"\n    if n3 == n:  # vertical line - undefined slope\n        return None\n    \n    slope_value = (n4 - n2) \/ (n3 - n)\n    return slope_value\n```"
  },
  {
    "id":236,
    "response":"```python\ndef max_sub_array_sum(lst, n):\n    \"\"\"\n    Find the maximum sum of a contiguous subarray and its length.\n    \n    Args:\n        lst: List of integers\n        n: Length of the list\n    \n    Returns:\n        A tuple (max_sum, length) where max_sum is the maximum sum of any subarray\n        and length is the length of that subarray.\n    \"\"\"\n    if not lst or n == 0:\n        return (0, 0)\n    \n    max_sum = lst[0]\n    current_sum = lst[0]\n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, n):\n        # If current sum becomes negative, start a new subarray from current element\n        if current_sum < 0:\n            current_sum = lst[i]\n            current_length = 1\n        else:\n            current_sum += lst[i]\n            current_length += 1\n        \n        # Update max_sum and max_length if current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_length = current_length\n    \n    return (max_sum, max_length)\n```"
  },
  {
    "id":237,
    "response":"```python\ndef cube_Sum(n):\n    \"\"\"\n    প্রথম n অদ্ভুত প্রাকৃতিক সংখ্যার ঘনক্ষেত্র সমষ্টি খুঁজে বের করে।\n    অদ্ভুত প্রাকৃতিক সংখ্যা হল যারা সংখ্যার ঘন হয়, যেমন 1, 8, 27, 64, ...\n    তবে এখানে বোঝার জন্য যে প্রথম n অদ্ভুত প্রাকৃতিক সংখ্যা হল প্রথম n সংখ্যার ঘন মান, \n    তাদের ঘনক্ষেত্র সমষ্টি বের করা হয়।\n    \n    এখানে অদ্ভুত প্রাকৃতিক সংখ্যা হল প্রথম n সংখ্যার ঘন মান।\n    যেমন: 1^3, 2^3, 3^3, ..., n^3\n    তাদের সমষ্টি হল প্রথম n সংখ্যার ঘনের সমষ্টি।\n    \n    প্রতিটি ঘনক্ষেত্র হল i^3 যেখানে i = 1, 2, 3, ..., n\n    সমষ্টি = 1^3 + 2^3 + 3^3 + ... + n^3 = (n(n+1)\/2)^2\n    \n    ফল"
  },
  {
    "id":238,
    "response":"```python\ndef min_swaps(s, s2):\n    \"\"\"\n    Find the minimum number of swaps needed to make two binary strings equal.\n    \n    Args:\n        s (str): First binary string\n        s2 (str): Second binary string\n    \n    Returns:\n        int: Minimum number of swaps needed\n    \n    Note:\n        This problem is equivalent to finding the minimum number of swaps\n        to make two binary strings identical. Since we can only swap characters\n        within each string, the minimum swaps needed is equal to the number of\n        positions where the strings differ, divided by 2 (since each swap can fix\n        two mismatches).\n    \"\"\"\n    # Count the number of positions where the strings differ\n    diff_count = 0\n    for i in range(len(s)):\n        if s[i] != s2[i]:\n            diff_count += 1\n    \n    # If no differences, no swaps needed\n    if diff_count == 0:\n        return 0\n    \n    # Each swap can fix at most 2 differences\n    # So minimum swaps is ceil(diff_count \/ 2)\n    return (diff_count + 1) \/\/ 2\n```"
  },
  {
    "id":239,
    "response":"```python\ndef sort_tuple(lst):\n    \"\"\"\n    Sorts a list of tuples based on the first item of each tuple in ascending order.\n    \n    Args:\n        lst: A list of tuples\n        \n    Returns:\n        A new list of tuples sorted by the first item of each tuple\n    \"\"\"\n    return sorted(lst, key=lambda x: x[0])\n```"
  },
  {
    "id":240,
    "response":"```python\ndef Check_Solution(n, n2, n3):\n    \"\"\"\n    Check if three numbers are numerically equal but have opposite signs.\n    \n    Parameters:\n    n, n2, n3: numeric values to compare\n    \n    Returns:\n    True if the absolute values are equal but signs are opposite (in at least one pair),\n    False otherwise.\n    \"\"\"\n    # Check if all three numbers have the same absolute value\n    if abs(n) == abs(n2) == abs(n3):\n        # Check if at least one pair has opposite signs\n        # (n and n2 have opposite signs, or n and n3 have opposite signs, or n2 and n3 have opposite signs)\n        if (n > 0 and n2 < 0) or (n < 0 and n2 > 0) or \\\n           (n > 0 and n3 < 0) or (n < 0 and n3 > 0) or \\\n           (n2 > 0 and n3 < 0) or (n2 < 0 and n3 > 0):\n            return True\n    return False\n```"
  },
  {
    "id":241,
    "response":"```python\ndef get_inv_count(lst, n):\n    \"\"\"\n    Calculate the number of inversions in the given list.\n    An inversion is a pair (i, j) such that i < j and lst[i] > lst[j].\n    \n    Args:\n        lst: List of integers\n        n: Length of the list\n    \n    Returns:\n        Integer representing the number of inversions\n    \"\"\"\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lst[i] > lst[j]:\n                inv_count += 1\n    return inv_count\n```"
  },
  {
    "id":242,
    "response":"```python\ndef get_odd_occurence(lst, n):\n    \"\"\"\n    Find the number that occurs odd number of times in the list.\n    \n    Args:\n        lst: List of integers\n        n: Length of the list (not used in current implementation)\n    \n    Returns:\n        The number that occurs odd number of times, or None if no such number exists\n    \"\"\"\n    # Count frequency of each number\n    freq = {}\n    for num in lst:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Find the number with odd frequency\n    for num, count in freq.items():\n        if count % 2 == 1:\n            return num\n    \n    # If no number occurs odd times, return None\n    return None\n```"
  },
  {
    "id":243,
    "response":"```python\nimport heapq\n\ndef nth_super_ugly_number(n, lst):\n    \"\"\"\n    Find the nth super ugly number using a min-heap approach.\n    \n    Args:\n        n: The position of the super ugly number to find (1-indexed)\n        lst: List of prime factors (prime numbers)\n    \n    Returns:\n        The nth super ugly number\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # Initialize the heap with the first super ugly number (1)\n    heap = [1]\n    # Keep track of the last used index for each prime factor\n    indices = [0] * len(lst)\n    \n    # Generate super ugly numbers until we reach the nth one\n    result = []\n    \n    for _ in range(n):\n        # Get the smallest number from the heap\n        current = heapq.heappop(heap)\n        result.append(current)\n        \n        # Generate new candidates by multiplying the current number with each prime\n        for i in range(len(lst)):\n            next_val = current * lst[i]\n            # Avoid duplicates by ensuring we don't add the same value multiple times\n            if not result or next_val > result[-1]:\n                heapq.heappush(heap, next_val)\n    \n    return result[n-1]\n```"
  },
  {
    "id":244,
    "response":"```python\ndef get_Number(n, n2):\n    \"\"\"\n    একটি অ্যারেতে kth উপাদান খুঁজে পাবে।\n    এখানে n এবং n2 হল দুটি প্যারামিটার যা অ্যারে বা কোন উপাদান নির্দেশ করতে পারে।\n    \n    যদি অ্যারেতে kth উপাদান থাকে, তবে সেটি রিটার্ন করা হবে।\n    অন্যথায় কোনও মান রিটার্ন করা হবে।\n    \"\"\"\n    # ধরা যাক যে অ্যারেটি হল n2 (যদি n2 একটি অ্যারে হয়)\n    if not isinstance(n2, list):\n        return None\n    \n    # kth উপাদান খুঁজছি - এখানে k হবে n এর মান\n    k = n\n    if k <= 0 or k > len(n2):\n        return None\n    \n    return n2[k - 1]  # 0-based indexing\n```"
  },
  {
    "id":245,
    "response":"```python\ndef find_Digits(n):\n    \"\"\"\n    একটি সংখ্যার ফ্যাক্টরিয়ালের সংখ্যা গণনা করে প্রদত্ত সংখ্যার সংখ্যা প্রদান করে।\n    যদি ফ্যাক্টরিয়ালের সংখ্যার প্রতিটি অঙ্ক একটি পৃথক সংখ্যা হয়, তবে সেগুলি গণনা করে।\n    \n    উদাহরণ:\n    find_Digits(5) -> 120 এর অঙ্কগুলি: 1, 2, 0 -> সংখ্যা গণনা = 3\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    # ফ্যাক্টরিয়াল গণনা\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    \n    # ফ্যাক্টরিয়ালের অঙ্কগুলি গণনা করা\n    digit_count = 0\n    for digit_char in str(factorial):\n        digit_count += 1\n    \n    return digit_count\n```"
  },
  {
    "id":246,
    "response":"```python\ndef find_platform(lst, lst2, n):\n    \"\"\"\n    Find the minimum number of platforms required at a railway or bus station\n    to handle all the arrivals and departures within a given time period.\n    \n    Args:\n        lst: List of arrival times (integers or floats)\n        lst2: List of departure times (integers or floats)\n        n: Number of time slots or a specific time range (not used directly in logic)\n    \n    Returns:\n        Minimum number of platforms required\n    \"\"\"\n    # Sort arrival and departure times\n    arrivals = sorted(lst)\n    departures = sorted(lst2)\n    \n    # Use two pointers to simulate platform usage\n    platforms = 0\n    max_platforms = 0\n    i, j = 0, 0\n    \n    while i < len(arrivals) and j < len(departures):\n        if arrivals[i] <= departures[j]:\n            # A new train arrives, so we need one more platform\n            platforms += 1\n            i += 1\n        else:\n            # A train departs, so we free up one platform\n            platforms -= 1\n            j += 1\n        \n        # Update the maximum platforms needed\n        max_platforms = max(max_platforms, platforms)\n    \n    return max_platforms\n```"
  },
  {
    "id":247,
    "response":"```python\ndef lcopy(lst):\n    \"\"\"\n    একটি সিঙ্গেলটন টিপল থেকে একটি তালিকা কপি করে ফেরত দেয়।\n    \n    Parameters:\n    lst: একটি টিপল (সিঙ্গেলটন হতে পারে অথবা অন্য কোনও টিপল)\n    \n    Returns:\n    তালিকা হিসাবে কপি করা মূল টিপলের প্রতিনিধি\n    \"\"\"\n    return list(lst)\n```"
  },
  {
    "id":248,
    "response":"```python\ndef area_trapezium(n, n2, n3):\n    \"\"\"\n    ট্র্যাপিসিয়ামের ক্ষেত্রফল বের করে।\n    \n    ফাংশনটি দুটি সমান্তর প্রান্তের দৈর্ঘ্য (n এবং n2) এবং উচ্চতা (n3) নিয়ে ক্ষেত্রফল গণনা করে।\n    \n    সূত্র: ক্ষেত্রফল = (সমান্তর 1 + সমান্তর 2) * উচ্চতা \/ 2\n    \n    প্যারামিটার:\n    n: প্রথম সমান্তরের দৈর্ঘ্য\n    n2: দ্বিতীয় সমান্তরের দৈর্ঘ্য\n    n3: উচ্চতা\n    \n    রিটার্ন: ক্ষেত্রফল\n    \"\"\"\n    return (n + n2) * n3 \/ 2\n```"
  },
  {
    "id":249,
    "response":"```python\ndef sum_of_divisors_of_digits(n):\n    \"\"\"\n    Calculate the sum of all divisors of each digit in the given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: Sum of divisors of all digits in n\n    \"\"\"\n    total = 0\n    digits = str(n)\n    \n    for digit_char in digits:\n        digit = int(digit_char)\n        if digit != 0:\n            # Find all divisors of the digit\n            divisors_sum = 0\n            for i in range(1, digit + 1):\n                if digit % i == 0:\n                    divisors_sum += i\n            total += divisors_sum\n    \n    return total\n```"
  },
  {
    "id":250,
    "response":"```python\ndef is_triangleexists(n, n2, n3):\n    \"\"\"\n    Check if three given sides can form a triangle with positive area.\n    \n    A triangle can be formed if and only if the sum of any two sides is greater than the third side.\n    This is known as the triangle inequality theorem.\n    \n    Args:\n        n (float): First side length\n        n2 (float): Second side length  \n        n3 (float): Third side length\n    \n    Returns:\n        bool: True if a triangle with positive area can be formed, False otherwise\n    \"\"\"\n    # Check if all sides are positive (necessary for positive area)\n    if n <= 0 or n2 <= 0 or n3 <= 0:\n        return False\n    \n    # Triangle inequality: sum of any two sides must be greater than the third side\n    return (n + n2 > n3) and (n + n3 > n2) and (n2 + n3 > n)\n```"
  },
  {
    "id":251,
    "response":"```python\ndef sum_of_inverse_divisors(n, n2):\n    \"\"\"\n    Calculate the sum of inverse divisors of n and n2.\n    \n    Args:\n        n: First number\n        n2: Second number\n    \n    Returns:\n        Sum of inverse divisors of n and n2\n    \"\"\"\n    def get_inverse_divisors_sum(num):\n        divisors_sum = 0\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors_sum += 1 \/ i\n                if i != num \/\/ i:  # Avoid double counting for perfect squares\n                    divisors_sum += 1 \/ (num \/\/ i)\n        return divisors_sum\n    \n    return get_inverse_divisors_sum(n) + get_inverse_divisors_sum(n2)\n```"
  },
  {
    "id":252,
    "response":"```python\ndef remove_negs(lst):\n    \"\"\"\n    একটি তালিকা থেকে নেতিবাচক সংখ্যা অপসারণ করে একটি নতুন তালিকা প্রদান করে।\n    \n    Args:\n        lst (list): নেতিবাচক সংখ্যা অপসারণের জন্য দেয়া তালিকা।\n    \n    Returns:\n        list: নেতিবাচক সংখ্যা বাদ দেওয়া তালিকা।\n    \"\"\"\n    return [x for x in lst if x >= 0]\n```"
  },
  {
    "id":253,
    "response":"```python\ndef sum_of_odd_factors(n):\n    \"\"\"\n    Calculate the sum of all odd factors of a given number n.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: Sum of all odd factors of n\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    total_sum = 0\n    i = 1\n    \n    # Check all possible odd factors\n    while i * i <= n:\n        if n % i == 0:\n            # i is a factor\n            if i % 2 == 1:  # i is odd\n                total_sum += i\n            \n            # n \/\/ i is also a factor\n            other_factor = n \/\/ i\n            if other_factor != i and other_factor % 2 == 1:  # other_factor is odd and different from i\n                total_sum += other_factor\n        \n        i += 1\n    \n    return total_sum\n```"
  },
  {
    "id":254,
    "response":"```python\ndef raw_heap(lst):\n    \"\"\"\n    Convert a list into a heap using the heapify algorithm.\n    \n    Args:\n        lst: A list of elements (assumed to be comparable)\n    \n    Returns:\n        A list that represents a heap (min-heap by default)\n    \"\"\"\n    # Convert the list into a heap using the built-in heapify function\n    import heapq\n    \n    # Create a copy to avoid modifying the original list\n    heap_list = lst[:]\n    \n    # Heapify the list\n    heapq.heapify(heap_list)\n    \n    return heap_list\n```"
  },
  {
    "id":255,
    "response":"```python\ndef check_Even_Parity(n):\n    \"\"\"\n    Check if the number of 1s in the binary representation of n is even.\n    \n    Args:\n        n (int): The integer to check for even parity.\n    \n    Returns:\n        bool: True if the number of 1s in binary representation is even, False otherwise.\n    \"\"\"\n    # Count the number of 1s in binary representation\n    count_ones = bin(n).count('1')\n    \n    # Return True if count is even, False if odd\n    return count_ones % 2 == 0\n```"
  },
  {
    "id":256,
    "response":"```python\ndef find_Min_Swaps(lst, n):\n    \"\"\"\n    Find the minimum number of swaps required to sort a binary array.\n    \n    Args:\n        lst: List of integers containing only 0s and 1s\n        n: Length of the array\n    \n    Returns:\n        Minimum number of swaps required to sort the array\n    \"\"\"\n    # Count the number of 0s and 1s\n    zeros = lst.count(0)\n    ones = lst.count(1)\n    \n    # In a sorted binary array, all 0s come before all 1s\n    # The minimum swaps needed is the number of 0s that are misplaced\n    # or equivalently, the number of 1s that are misplaced\n    \n    # We can use a sliding window approach to count misplaced elements\n    # Actually, the minimum swaps is simply the number of 0s that are at the end\n    # or the number of 1s that are at the beginning\n    \n    # Count how many 0s are at the end (after the correct position)\n    misplaced_zeros = 0\n    for i in range(zeros, n):\n        if lst[i] == 0:\n            misplaced_zeros += 1\n    \n    # Count how many 1s are at the beginning (before the correct position)\n    misplaced_ones = 0\n    for i in range(zeros):\n        if lst[i] == 1:\n            misplaced_ones += 1\n    \n    # The minimum swaps is the minimum of misplaced zeros or misplaced ones\n    # Actually, since each swap can fix two misplaced elements, we just need\n    # to count the number of misplaced 0s at the end (or misplaced 1s at the beginning)\n    \n    # The answer is simply the number of misplaced 0s at the end\n    return misplaced_zeros\n```"
  },
  {
    "id":257,
    "response":"```python\ndef listify_list(lst):\n    \"\"\"\n    প্রদত্ত স্ট্রিংগুলির তালিকা পৃথকভাবে তালিকাভুক্ত করে ফেরত দেয়।\n    \n    Args:\n        lst: একটি স্ট্রিংগুলির তালিকা\n        \n    Returns:\n        প্রতিটি স্ট্রিংকে একটি তালিকার সাথে পৃথকভাবে তালিকাভুক্ত করা তালিকা\n    \"\"\"\n    return [[item] for item in lst]\n```"
  },
  {
    "id":258,
    "response":"```python\ndef count_list(lst):\n    \"\"\"\n    Count the occurrences of each element in the list and return a list of tuples.\n    Each tuple contains (element, count).\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A list of tuples where each tuple is (element, count)\n    \"\"\"\n    count_dict = {}\n    for item in lst:\n        count_dict[item] = count_dict.get(item, 0) + 1\n    \n    return [(item, count) for item, count in count_dict.items()]\n```"
  },
  {
    "id":259,
    "response":"```python\ndef sub_lists(lst):\n    \"\"\"\n    Generate all possible sublists from a given list.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A list of lists, where each inner list is a sublist of the original list\n    \"\"\"\n    result = []\n    \n    # Generate all possible sublists using bit manipulation\n    n = len(lst)\n    for i in range(1 << n):  # 2^n possible subsets (including empty set)\n        sublist = []\n        for j in range(n):\n            if i & (1 << j):  # if j-th bit is set\n                sublist.append(lst[j])\n        if sublist:  # only include non-empty sublists\n            result.append(sublist)\n    \n    return result\n```"
  },
  {
    "id":260,
    "response":"```python\ndef check_alphanumeric(s):\n    \"\"\"\n    Check if a string ends with only alphanumeric characters.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string ends with only alphanumeric characters, False otherwise.\n    \"\"\"\n    if not s:\n        return False\n    \n    # Get the last character and check if it's alphanumeric\n    last_char = s[-1]\n    return last_char.isalnum()\n```"
  },
  {
    "id":261,
    "response":"```python\nfrom collections import Counter\n\ndef anagram_lambda(lst, s):\n    \"\"\"\n    Find all strings in the list that are anagrams of the given string s.\n    \n    Args:\n        lst: List of strings to search through\n        s: Target string to find anagrams for\n    \n    Returns:\n        List of strings that are anagrams of s\n    \"\"\"\n    # Lambda function to check if two strings are anagrams\n    is_anagram = lambda x, y: Counter(x) == Counter(y)\n    \n    # Filter the list to find all strings that are anagrams of s\n    return [item for item in lst if is_anagram(item, s)]\n```"
  },
  {
    "id":262,
    "response":"```python\ndef n_common_words(s, n):\n    \"\"\"\n    নির্দিষ্ট পাঠে n টি সর্বাধিক সাধারণ শব্দের উপস্থিতি খুঁজে বের করে।\n    \n    Parameters:\n    s (str): পাঠের স্ট্রিং\n    n (int): সর্বাধিক সাধারণ শব্দের সংখ্যা\n    \n    Returns:\n    list: সর্বাধিক সাধারণ শব্দগুলির তালিকা (পুনরাবৃত্তি অনুসারে সাজানো)\n    \"\"\"\n    # শব্দগুলি স্ট্রিংটি ভাগ করে\n    words = s.lower().split()\n    \n    # প্রতিটি শব্দের পুনরাবৃত্তি গণনা\n    word_count = {}\n    for word in words:\n        # অক্ষর পরিবর্তন করে প্রতিটি শব্দকে স্থান বাড়ানো হয় (যেমন: \"a\", \"an\", \"the\" এর মতো)\n        cleaned_word = word.strip('.,!?\";:()[]{}')\n        if cleaned_word:\n            word_count[cleaned_word] = word_count.get(cleaned_word, 0) + 1\n    \n    # সাধারণত সাজানো হয় (পুনরাবৃত্তি অনুসারে হারানো)\n    sorted_words = sorted(word_count.items(), key=lambda x: x[1], reverse=True)\n    \n    # প্র"
  },
  {
    "id":263,
    "response":"```python\ndef find_longest_conseq_subseq(lst, n):\n    \"\"\"\n    Find the length of the longest consecutive subsequence in the list.\n    \n    Args:\n        lst: List of integers\n        n: Length of the list\n    \n    Returns:\n        Length of the longest consecutive subsequence\n    \"\"\"\n    if not lst:\n        return 0\n    \n    # Convert list to set for O(1) lookup\n    num_set = set(lst)\n    \n    max_length = 0\n    \n    # Check each number to see if it's the start of a sequence\n    for num in num_set:\n        # Only start counting if num is the beginning of a sequence\n        # (i.e., num - 1 is not in the set)\n        if num - 1 not in num_set:\n            current_num = num\n            current_length = 1\n            \n            # Count the length of the consecutive sequence\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_length += 1\n            \n            # Update max length if current length is greater\n            max_length = max(max_length, current_length)\n    \n    return max_length\n```"
  },
  {
    "id":264,
    "response":"```python\ndef palindrome_lambda(lst):\n    \"\"\"\n    ল্যাম্বদা ফাংশন ব্যবহার করে স্ট্রিংগুলির একটি প্রদত্ত তালিকায় প্যালিনড্রোমগুলি খুঁজে পেয়ে ফেরত দেয়।\n    \n    Args:\n        lst: স্ট্রিং গুলির একটি তালিকা\n        \n    Returns:\n        প্যালিনড্রোম স্ট্রিংগুলির একটি তালিকা\n    \"\"\"\n    is_palindrome = lambda s: s == s[::-1]\n    return [s for s in lst if is_palindrome(s)]\n```"
  },
  {
    "id":265,
    "response":"```python\ndef ntimes_list(lst, n):\n    \"\"\"\n    একটি তালিকা n বার প্রিন্ট করে।\n    \n    প্যারামিটার:\n    lst: প্রিন্ট করা হবে তালিকা\n    n: তালিকা কতবার প্রিন্ট করা হবে\n    \n    রিটার্ন:\n    কিছু রিটার্ন করে না, শুধুমাত্র তালিকা n বার প্রিন্ট করে।\n    \"\"\"\n    for _ in range(n):\n        print(lst)\n```"
  },
  {
    "id":266,
    "response":"```python\ndef check_monthnumb(month_name):\n    \"\"\"\n    Check if the given month name has 31 days.\n    \n    Args:\n        month_name (str): The name of the month (e.g., \"January\", \"March\")\n    \n    Returns:\n        bool: True if the month has 31 days, False otherwise\n    \"\"\"\n    # Dictionary mapping month names to number of days\n    days_in_month = {\n        \"January\": 31,\n        \"February\": 28,  # 29 in leap year, but we only care about 31-day check\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    \n    # Check if the month name exists in the dictionary and has 31 days\n    return days_in_month.get(month_name.title(), 0) == 31\n```"
  },
  {
    "id":267,
    "response":"```python\ndef min_Num(lst, n):\n    \"\"\"\n    একটি ন্যূনতম সংখ্যা যোগ করে যাতে অ্যারের যোগফল একটি সম্পূর্ণ সংখ্যা হয়।\n    \n    Parameters:\n    lst (list of int): অ্যারে\n    n (int): যোগ করা হবে সংখ্যা (এটি ন্যূনতম সংখ্যা হিসাবে কাজ করবে)\n    \n    Returns:\n    int: যোগ করা হবে ন্যূনতম সংখ্যা\n    \"\"\"\n    total = sum(lst)\n    remainder = total % n\n    \n    if remainder == 0:\n        return 0\n    else:\n        return n - remainder\n```"
  },
  {
    "id":268,
    "response":"```python\ndef length_Of_Last_Word(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিংয়ের শেষ শব্দের দৈর্ঘ্য খুঁজে পায়।\n    \n    Args:\n        s (str): প্রদত্ত স্ট্রিং\n        \n    Returns:\n        int: শেষ শব্দের দৈর্ঘ্য, যদি কোনো শব্দ না থাকে তবে 0 রিটার্ন করে\n    \"\"\"\n    # স্ট্রিং খালি হলে রিটার্ন 0\n    if not s or s.strip() == \"\":\n        return 0\n    \n    # স্ট্রিং এর শেষে স্পেস কে কাটে এবং শেষ শব্দ পাওয়া যায়\n    words = s.strip().split()\n    \n    # শেষ শব্দের দৈর্ঘ্য রিটার্ন করা হয়\n    if words:\n        return len(words[-1])\n    else:\n        return 0\n```"
  },
  {
    "id":269,
    "response":"```python\ndef remove_list_range(lst, n, n2):\n    \"\"\"\n    Remove elements from a list that fall within the range [n, n2] (inclusive).\n    \n    Args:\n        lst: The input list\n        n: The start of the range (inclusive)\n        n2: The end of the range (inclusive)\n    \n    Returns:\n        A new list with elements outside the range [n, n2]\n    \"\"\"\n    return [x for x in lst if x < n or x > n2]\n```"
  },
  {
    "id":270,
    "response":"```python\ndef sum_positivenum(lst):\n    return sum(filter(lambda x: x > 0, lst))\n```"
  },
  {
    "id":271,
    "response":"```python\ndef are_Rotations(s, s2):\n    \"\"\"\n    Check if string s2 is a rotation of string s.\n    \n    Args:\n        s (str): The original string\n        s2 (str): The string to check if it's a rotation of s\n        \n    Returns:\n        bool: True if s2 is a rotation of s, False otherwise\n    \"\"\"\n    # If lengths are different, they can't be rotations\n    if len(s) != len(s2):\n        return False\n    \n    # A string is a rotation of another if and only if \n    # the second string appears as a substring in the first string concatenated with itself\n    return s2 in (s + s)\n```"
  },
  {
    "id":272,
    "response":"```python\ndef check_subset(lst, lst2):\n    \"\"\"\n    Check if lst is a subset of lst2 in a nested list structure.\n    \n    Args:\n        lst: The potential subset (nested list)\n        lst2: The potential superset (nested list)\n    \n    Returns:\n        bool: True if lst is a subset of lst2, False otherwise\n    \"\"\"\n    if not lst:\n        return True\n    \n    if not lst2:\n        return False\n    \n    # Convert both lists to tuples for hashing and comparison\n    def to_tuple(lst):\n        if isinstance(lst, list):\n            return tuple(to_tuple(item) for item in lst)\n        return lst\n    \n    tuple_lst = to_tuple(lst)\n    tuple_lst2 = to_tuple(lst2)\n    \n    # Check if tuple_lst is a subset of tuple_lst2\n    def is_subset(subset_tuple, superset_tuple):\n        if not subset_tuple:\n            return True\n        \n        # Convert superset to a set of tuples for efficient lookup\n        superset_set = set()\n        stack = [superset_tuple]\n        \n        while stack:\n            current = stack.pop()\n            if isinstance(current, tuple):\n                for item in current:\n                    if isinstance(item, tuple):\n                        stack.append(item)\n                    else:\n                        superset_set.add(item)\n            else:\n                superset_set.add(current)\n        \n        # Check if all elements in subset are in superset\n        subset_items = []\n        stack = [subset_tuple]\n        while stack:\n            current = stack.pop()\n            if isinstance(current, tuple):\n                for item in current:\n                    if isinstance(item, tuple):\n                        stack.append(item)\n                    else:\n                        subset_items.append(item)\n            else:\n                subset_items.append(current)\n        \n        return all(item in superset_set for item in subset_items)\n    \n    # For nested lists, we need a more sophisticated approach\n    def is_nested_subset(subset, superset):\n        if not subset:\n            return True\n        \n        # If subset is empty, it's a subset of any list\n        if len(subset) == 0:\n            return True\n            \n        # If superset is empty, it can't contain non-empty subset\n        if len(superset) == 0:\n            return False\n            \n        # Compare elements recursively\n        for sub_item in subset:\n            found = False\n            for sup_item in superset:\n                if isinstance(sub_item, list) and isinstance(sup_item, list):\n                    if len(sub_item"
  },
  {
    "id":273,
    "response":"```python\ndef fibonacci(n):\n    \"\"\"\n    পুনরাবৃত্তি (Recursion) ব্যবহার করে ফিবোনাক্সি ক্রম সমাধান করে।\n    \n    প্যারামিটার:\n    n (int): ফিবোনাক্সি ক্রমের ক্রমের সংখ্যা\n    \n    রিটার্ন:\n    int: n তম ফিবোনাক্সি সংখ্যা\n    \"\"\"\n    # প্রাথমিক ক্ষেত্র: যদি n <= 1 হয়, তবে ফাংশনটি ফেরত দেয় n\n    if n <= 1:\n        return n\n    \n    # পুনরাবৃত্তি ব্যবহার করে পূর্ববর্তী দুটি সংখ্যা যোগ করে\n    return fibonacci(n - 1) + fibonacci(n - 2)\n```"
  },
  {
    "id":274,
    "response":"```python\ndef check_Concat(s, s2):\n    \"\"\"\n    Check if string s2 is the concatenation of string s with itself.\n    \n    Args:\n        s (str): The base string to check\n        s2 (str): The string to check if it's the concatenation of s with itself\n        \n    Returns:\n        bool: True if s2 is s + s, otherwise False\n    \"\"\"\n    return s + s == s2\n```"
  },
  {
    "id":275,
    "response":"```python\ndef min_difference(lst):\n    \"\"\"\n    প্রদত্ত টুপলগুলির টুপল জোড়াগুলির মধ্যে সর্বনিম্ন পার্থক্য খুঁজে বের করে।\n    \n    Args:\n        lst: একটি টুপল জোড়া (tuple of tuples) যেখানে প্রতিটি টুপল দুটি সংখ্যা বহন করে\n        \n    Returns:\n        int: সর্বনিম্ন পার্থক্য (দুটি সংখ্যার মধ্যে পার্থক্য)\n        \n    Example:\n        min_difference(((1, 3), (2, 4), (5, 7))) -> 1\n    \"\"\"\n    if not lst:\n        return 0\n    \n    differences = []\n    for pair in lst:\n        if len(pair) == 2:\n            diff = abs(pair[0] - pair[1])\n            differences.append(diff)\n    \n    return min(differences) if differences else 0\n```"
  },
  {
    "id":276,
    "response":"```python\ndef lcm(n, n2):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) of two positive integers.\n    \n    Args:\n        n (int): First positive integer\n        n2 (int): Second positive integer\n    \n    Returns:\n        int: The LCM of n and n2\n    \"\"\"\n    # Helper function to find GCD using Euclidean algorithm\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    # LCM formula: LCM(a,b) = (a * b) \/ GCD(a,b)\n    return (n * n2) \/\/ gcd(n, n2)\n```"
  },
  {
    "id":277,
    "response":"```python\ndef sort_string(s):\n    \"\"\"\n    Sorts the characters in the given string in ascending order.\n    \n    Args:\n        s (str): The input string to be sorted.\n    \n    Returns:\n        str: A new string with characters sorted in ascending order.\n    \"\"\"\n    return ''.join(sorted(s))\n```"
  },
  {
    "id":278,
    "response":"```python\ndef check_tuples(tup, lst):\n    \"\"\"\n    Check if the given tuple has exactly k elements where k is the length of the list.\n    \n    Args:\n        tup: The tuple to check\n        lst: The list whose length will be compared with the tuple's length\n        \n    Returns:\n        bool: True if the tuple has exactly the same number of elements as the list, False otherwise\n    \"\"\"\n    return len(tup) == len(lst)\n```"
  },
  {
    "id":279,
    "response":"```python\nimport re\n\ndef text_match(s):\n    \"\"\"\n    Check if a string has 'a' followed by some characters and ends with 'b'.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string starts with 'a' followed by any characters and ends with 'b', otherwise False.\n    \"\"\"\n    pattern = r'^a.*b$'\n    return bool(re.search(pattern, s))\n```"
  },
  {
    "id":280,
    "response":"```python\ndef Check_Solution(n, n2, n3):\n    \"\"\"\n    বর্গক্ষেত্র সমীকরণের সমাধানের সংখ্যা খুঁজে বের করে।\n    \n    বর্গক্ষেত্র সমীকরণ: ax^2 + bx + c = 0\n    এখানে n = a, n2 = b, n3 = c\n    \n    সমাধানের সংখ্যা হয়:\n    - 2টি বাস্তব সমাধান (যদি বিষমান হয়)\n    - 1টি বাস্তব সমাধান (যদি বিষমান হয়)\n    - 0টি বাস্তব সমাধান (যদি বিষমান হয়)\n    \n    Parameters:\n    n (float): সমীকরণের সহগ (a)\n    n2 (float): সমীকরণের সহগ (b)\n    n3 (float): সমীকরণের সহগ (c)\n    \n    Returns:\n    int: বাস্তব সমাধানের সংখ্যা\n    \"\"\"\n    # যদি a = 0 হয় তবে এটি একটি সরল সমীকরণ (বর্গক্ষেত্র না)\n    if n == 0:\n        if n2 == 0:\n            if n3 == 0:\n                return 1  # 0 = 0 হলে অসংখ্য সমাধান\n            else:\n                return 0  # 0 = সংখ্যা (অসম্ভব)\n        else:"
  },
  {
    "id":281,
    "response":"```python\ndef sum_even_odd(lst):\n    \"\"\"\n    Find the sum of the first even number and the first odd number in the list.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        int: Sum of the first even and first odd number, or 0 if neither exists\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0:\n            if first_even is None:\n                first_even = num\n        else:\n            if first_odd is None:\n                first_odd = num\n                break  # Once we find the first odd, we can stop looking for more odd numbers\n    \n    if first_even is not None and first_odd is not None:\n        return first_even + first_odd\n    else:\n        return 0\n```"
  },
  {
    "id":282,
    "response":"```python\ndef parallelogram_perimeter(n, n2):\n    \"\"\"\n    Calculate the perimeter of a parallelogram.\n    \n    A parallelogram has opposite sides equal in length.\n    So, if one pair of opposite sides is of length 'n' and the other pair is of length 'n2',\n    the perimeter is 2*(n + n2).\n    \n    Args:\n        n (float): Length of one pair of opposite sides\n        n2 (float): Length of the other pair of opposite sides\n    \n    Returns:\n        float: Perimeter of the parallelogram\n    \"\"\"\n    return 2 * (n + n2)\n```"
  },
  {
    "id":283,
    "response":"```python\ndef div_of_nums(lst, m, n):\n    \"\"\"\n    ল্যাম্বদা ফাংশন ব্যবহার করে সংখ্যার তালিকা থেকে m এবং n দ্বারা বিভাজ্য সংখ্যা খুঁজে বের করে।\n    \n    Parameters:\n    lst (list): সংখ্যার তালিকা\n    m (int): প্রথম বিভাজক\n    n (int): দ্বিতীয় বিভাজক\n    \n    Returns:\n    list: m এবং n দ্বারা বিভাজ্য সংখ্যার তালিকা\n    \"\"\"\n    return list(filter(lambda x: x % m == 0 and x % n == 0, lst))\n```"
  },
  {
    "id":284,
    "response":"```python\ndef all_Bits_Set_In_The_Given_Range(n, n2, n3):\n    \"\"\"\n    Check if all bits of n are set within the range [n2, n3].\n    \n    Args:\n        n: The number whose bits we want to check.\n        n2: The lower bound of the range (inclusive).\n        n3: The upper bound of the range (inclusive).\n    \n    Returns:\n        True if all bits of n are set within the range [n2, n3], False otherwise.\n    \"\"\"\n    # Convert n to binary and remove '0b' prefix\n    binary_n = bin(n)[2:]\n    \n    # Convert n2 and n3 to binary and pad to same length as n\n    binary_n2 = bin(n2)[2:].zfill(len(binary_n))\n    binary_n3 = bin(n3)[2:].zfill(len(binary_n))\n    \n    # Check if n is within the range [n2, n3]\n    if n < n2 or n > n3:\n        return False\n    \n    # Check if all bits of n are set within the range\n    # This is a simplified interpretation - if we interpret the problem as\n    # checking if all bits of n are set in the range [n2, n3], we need to\n    # verify that each bit position in n is within [n2, n3].\n    \n    # Convert n to binary and check each bit\n    for i in range(len(binary_n)):\n        bit = int(binary_n[i])\n        if bit == 1:\n            # Check if this bit position is within the range\n            # We need to map bit position to value\n            pos_value = (1 << (len(binary_n) - 1 - i))\n            if pos_value < n2 or pos_value > n3:\n                return False\n    \n    return True\n```"
  },
  {
    "id":285,
    "response":"```python\ndef is_isomorphic(s, s2):\n    \"\"\"\n    Check if two strings are isomorphic.\n    \n    Two strings are isomorphic if there is a one-to-one mapping between their characters\n    and the mapping is consistent throughout both strings.\n    \n    Args:\n        s (str): First string\n        s2 (str): Second string\n    \n    Returns:\n        bool: True if strings are isomorphic, False otherwise\n    \"\"\"\n    if len(s) != len(s2):\n        return False\n    \n    # Maps from character in s to character in s2\n    char_map_s_to_s2 = {}\n    # Maps from character in s2 to character in s\n    char_map_s2_to_s = {}\n    \n    for i in range(len(s)):\n        char1, char2 = s[i], s2[i]\n        \n        # Check if there's already a mapping\n        if char1 in char_map_s_to_s2:\n            if char_map_s_to_s2[char1] != char2:\n                return False\n        else:\n            char_map_s_to_s2[char1] = char2\n        \n        # Check if there's already a mapping in reverse\n        if char2 in char_map_s2_to_s:\n            if char_map_s2_to_s[char2] != char1:\n                return False\n        else:\n            char_map_s2_to_s[char2] = char1\n    \n    return True\n```"
  },
  {
    "id":286,
    "response":"```python\ndef sum_num(tup):\n    \"\"\"\n    একটি তালিকার (তালিকা বা কার্টেজিয় জোড়া) সব সংখ্যা যোগ করে এবং তা তালিকার দৈর্ঘ্যের সাথে ভাগ করে।\n    \n    আর্গুমেন্ট:\n    tup: একটি তালিকা যার মধ্যে সংখ্যা থাকবে।\n    \n    রিটার্ন:\n    যোগফল এবং দৈর্ঘ্যের ভাগফল।\n    \"\"\"\n    if not tup:\n        return 0\n    \n    total_sum = sum(tup)\n    length = len(tup)\n    \n    return total_sum \/\/ length\n```"
  },
  {
    "id":287,
    "response":"```python\ndef is_odd(n):\n    \"\"\"\n    বিটওয়াইস অপারেটর ব্যবহার করে প্রদত্ত সংখ্যাটি অদ্ভুত কিনা তা পরীক্ষা করে।\n    \n    একটি সংখ্যা অদ্ভুত হলে তার সবথেকে ডান বিট (লস্ট বিট) 1 হবে।\n    এটি বিটওয়াইস এ্যান্ড অপারেটর (&) দিয়ে চেক করা যায় যখন 1 এর সাথে সংখ্যাটির বিট এক্সরে করা হয়।\n    \n    Parameters:\n        n (int): পরীক্ষা করার সংখ্যা\n    \n    Returns:\n        bool: সংখ্যা অদ্ভুত হলে True, না হলে False\n    \"\"\"\n    return n & 1 == 1\n```"
  },
  {
    "id":288,
    "response":"```python\ndef subtract_elements(tup, tup2):\n    \"\"\"\n    Subtract elements of tup2 from tup element-wise.\n    \n    Args:\n        tup: A tuple of numbers\n        tup2: A tuple of numbers (same length as tup)\n    \n    Returns:\n        A tuple containing the result of element-wise subtraction\n    \"\"\"\n    if len(tup) != len(tup2):\n        raise ValueError(\"Tuples must have the same length\")\n    \n    result = tuple(tup[i] - tup2[i] for i in range(len(tup)))\n    return result\n```"
  },
  {
    "id":289,
    "response":"```python\ndef reverse_list_lists(lst):\n    \"\"\"\n    প্রতিটি তালিকার তালিকাকে বিপরীত করে।\n    \n    Args:\n        lst: একটি তালিকা, যার প্রতিটি উপাদান একটি তালিকা হবে।\n    \n    Returns:\n        একটি তালিকা, যার প্রতিটি উপাদান পূর্বের তালিকার বিপরীত হবে।\n    \"\"\"\n    return [sublist[::-1] for sublist in lst]\n```"
  },
  {
    "id":290,
    "response":"```python\ndef find_Extra(lst, lst2, n):\n    \"\"\"\n    সাজানো অ্যারেতে উপস্থিত অতিরিক্ত উপাদানগুলির সূচকটি খুঁজে পেয়ে ফেরত দেয়।\n    \n    প্যারামিটার:\n    lst: প্রথম সাজানো অ্যারে (উপাদানগুলি অতিরিক্ত হতে পারে)\n    lst2: দ্বিতীয় সাজানো অ্যারে (সব উপাদান থাকবে)\n    n: অ্যারের দৈর্ঘ্য\n    \n    ফেরত দেয়:\n    অতিরিক্ত উপাদানের সূচক (ইনডেক্স)\n    \"\"\"\n    # অতিরিক্ত উপাদান খুঁজে পাবে যদি দুটি অ্যারের মধ্যে একটি উপাদান অতিরিক্ত থাকে\n    for i in range(n):\n        if lst[i] != lst2[i]:\n            return i\n    return -1  # অতিরিক্ত উপাদান নেই\n```"
  },
  {
    "id":291,
    "response":"```python\ndef same_length(n, n2):\n    \"\"\"\n    Check if two numbers have the same number of digits.\n    \n    Args:\n        n (int): First number\n        n2 (int): Second number\n    \n    Returns:\n        bool: True if both numbers have the same number of digits, False otherwise\n    \"\"\"\n    return len(str(abs(n))) == len(str(abs(n2)))\n```"
  },
  {
    "id":292,
    "response":"```python\ndef remove_spaces(s):\n    \"\"\"\n    একটি স্ট্রিংয়ে একাধিক স্পেস অপসারণ করে একটি স্পেস বা কোনও স্পেস না থাকার স্ট্রিং তৈরি করে।\n    \n    Args:\n        s (str): স্পেস অপসারণের জন্য দেয়া স্ট্রিং\n        \n    Returns:\n        str: স্পেস অপসারণ করা স্ট্রিং\n    \"\"\"\n    return ' '.join(s.split())\n```"
  },
  {
    "id":293,
    "response":"```python\ndef Extract(lst):\n    \"\"\"\n    Extract the last element from each sublist in a list of lists.\n    \n    Args:\n        lst: A list of lists (sublists)\n    \n    Returns:\n        A list containing the last element from each sublist\n    \"\"\"\n    return [sublist[-1] for sublist in lst]\n```"
  },
  {
    "id":294,
    "response":"```python\ndef float_to_tuple(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিংকে ফ্লোট টাইপের মানগুলি একটি টিউপলে রূপান্তর করে।\n    \n    Args:\n        s (str): ফ্লোট মানগুলি স্পেস দিয়ে বিভক্ত হওয়া স্ট্রিং\n        \n    Returns:\n        tuple: ফ্লোট মানগুলি একটি টিউপলে রূপান্তরিত হয়ে আসে\n        \n    Example:\n        >>> float_to_tuple(\"1.5 2.3 3.7\")\n        (1.5, 2.3, 3.7)\n    \"\"\"\n    if not s or not s.strip():\n        return ()\n    \n    # স্ট্রিং থেকে স্পেস দিয়ে ভাগ করে অংশগুলি তৈরি করা হয়\n    parts = s.strip().split()\n    \n    # প্রতিটি অংশকে ফ্লোটে রূপান্তর করা হয়\n    float_values = []\n    for part in parts:\n        try:\n            float_values.append(float(part))\n        except ValueError:\n            # যদি কোনও অংশ ফ্লোট হিসেবে রূপান্তর করা যায় না, তবে এটি অবজ্ঞা করা হবে\n            continue\n    \n    return tuple(float_values)\n```"
  },
  {
    "id":295,
    "response":"```python\ndef max_sum_subseq(lst):\n    \"\"\"\n    Find the maximum sum of a subsequence in the given list.\n    A subsequence does not need to be contiguous, and can be empty.\n    \n    Args:\n        lst: List of integers\n        \n    Returns:\n        Integer representing the maximum sum of any subsequence\n    \"\"\"\n    if not lst:\n        return 0\n    \n    # Since we can choose any subsequence (not necessarily contiguous),\n    # and we want the maximum sum, we simply sum all positive numbers.\n    # If all numbers are negative, we return 0 (empty subsequence).\n    \n    total = 0\n    for num in lst:\n        if num > 0:\n            total += num\n    \n    return total\n```"
  },
  {
    "id":296,
    "response":"```python\ndef sort_list_last(lst):\n    \"\"\"\n    একটি তালিকাকে শেষের উপাদান অনুসারে বর্ধমান ক্রমে সাজায়।\n    \n    Args:\n        lst: একটি তালিকা (list)\n    \n    Returns:\n        শেষের উপাদান অনুসারে বর্ধমান ক্রমে সাজানো তালিকা\n    \"\"\"\n    return sorted(lst, key=lambda x: x[-1] if isinstance(x, (list, tuple)) else x)\n```"
  },
  {
    "id":297,
    "response":"```python\ndef is_Word_Present(s, s2):\n    \"\"\"\n    Check if word s2 is present in the sentence s.\n    \n    Args:\n        s (str): The sentence to search in.\n        s2 (str): The word to search for.\n    \n    Returns:\n        bool: True if s2 is present in s, False otherwise.\n    \"\"\"\n    return s2 in s\n```"
  },
  {
    "id":298,
    "response":"```python\ndef extract_elements(lst, n):\n    \"\"\"\n    একটি নির্দিষ্ট তালিকা থেকে নির্দিষ্ট সংখ্যক উপাদান বের করে যা একে অপরকে ক্রমাগত অনুসরণ করে।\n    \n    Args:\n        lst: তালিকা (list)\n        n: বের করার উপাদানের সংখ্যা\n    \n    Returns:\n        ক্রমাগত উপাদানগুলির একটি তালিকা\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    # প্রথম n টি উপাদান নিয়ে ক্রমাগত তালিকা তৈরি করা\n    return lst[:n]\n```"
  },
  {
    "id":299,
    "response":"```python\ndef check(lst, n):\n    \"\"\"\n    Check if the array contains only elements that are multiples of n.\n    \n    Args:\n        lst: List of integers to check\n        n: Integer to check divisibility against\n    \n    Returns:\n        bool: True if all elements in lst are divisible by n, False otherwise\n    \"\"\"\n    if n == 0:\n        return False\n    \n    for element in lst:\n        if element % n != 0:\n            return False\n    \n    return True\n```"
  },
  {
    "id":300,
    "response":"```python\ndef match_num(s, num):\n    \"\"\"\n    Check if a string starts with a specific number.\n    \n    Args:\n        s (str): The string to check.\n        num (int): The number to check if the string starts with.\n    \n    Returns:\n        bool: True if the string starts with the number, False otherwise.\n    \"\"\"\n    # Convert number to string for comparison\n    num_str = str(num)\n    \n    # Check if string starts with the number string\n    return s.startswith(num_str)\n```"
  },
  {
    "id":301,
    "response":"```python\ndef num_comm_div(n, n2):\n    \"\"\"\n    দুটি সংখ্যার মধ্যে সাধারণ বিভাজকগুলির সংখ্যা খুঁজে পায়।\n    \n    প্যারামিটার:\n    n (int): প্রথম সংখ্যা\n    n2 (int): দ্বিতীয় সংখ্যা\n    \n    রিটার্ন:\n    int: সাধারণ বিভাজকগুলির সংখ্যা\n    \"\"\"\n    # দুটি সংখ্যার গসাগু বের করা\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    # গসাগু বের করে সাধারণ বিভাজকগুলির সংখ্যা বের করা\n    g = gcd(n, n2)\n    \n    # গসাগু এর সংখ্যা সাধারণ বিভাজকগুলির সংখ্যা\n    count = 0\n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            count += 1\n            if i != g \/\/ i:\n                count += 1\n    \n    return count\n```"
  },
  {
    "id":302,
    "response":"```python\ndef find(n, n2):\n    \"\"\"\n    দুটি সংখ্যার অবশিষ্ট খুঁজে বের করে।\n    \n    Parameters:\n    n (int): প্রথম সংখ্যা\n    n2 (int): দ্বিতীয় সংখ্যা\n    \n    Returns:\n    int: n এর জন্য n2 দ্বারা ভাগের অবশিষ্ট মান\n    \"\"\"\n    return n % n2\n```"
  },
  {
    "id":303,
    "response":"```python\ndef add_consecutive_nums(lst):\n    \"\"\"\n    Add consecutive numbers in a list.\n    \n    Args:\n        lst: A list of numbers\n        \n    Returns:\n        A list where consecutive elements are summed together.\n    \"\"\"\n    if not lst:\n        return []\n    \n    result = []\n    i = 0\n    \n    while i < len(lst):\n        current_sum = lst[i]\n        j = i + 1\n        \n        # Add consecutive elements until the end of list or a different value\n        while j < len(lst) and lst[j] == lst[i]:\n            current_sum += lst[j]\n            j += 1\n        \n        result.append(current_sum)\n        i = j\n    \n    return result\n```"
  },
  {
    "id":304,
    "response":"```python\ndef sum_Of_Series(n):\n    \"\"\"\n    প্রথম n টি প্রাকৃতিক সংখ্যার ঘনক্ষেত্রের যোগফল বের করে ফেরত দেয়।\n    \n    উদাহরণ: 1^3 + 2^3 + 3^3 + ... + n^3\n    \n    Parameters:\n    n (int): প্রথম n টি প্রাকৃতিক সংখ্যা নির্দেশ করে\n    \n    Returns:\n    int: ঘনক্ষেত্রের যোগফল\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total += i ** 3\n    return total\n```"
  },
  {
    "id":305,
    "response":"```python\ndef re_order(lst):\n    \"\"\"\n    সব শূন্যকে প্রদত্ত অ্যারের শেষে সরিয়ে দেয়।\n    \n    Args:\n        lst: একটি পূর্ণসংখ্যা অ্যারে\n        \n    Returns:\n        শূন্যগুলি শেষে রয়েছে এমন অ্যারে\n    \"\"\"\n    # শূন্যগুলি সরিয়ে দেওয়ার জন্য একটি নতুন অ্যারে তৈরি করা হয়\n    non_zeros = [x for x in lst if x != 0]\n    \n    # শূন্যগুলি যোগ করা হয় যেমন অ্যারের শেষে\n    zeros_count = len(lst) - len(non_zeros)\n    \n    # শূন্যগুলি যোগ করা হয় শেষে\n    result = non_zeros + [0] * zeros_count\n    \n    return result\n```"
  },
  {
    "id":306,
    "response":"```python\ndef permutation_coefficient(n, k):\n    \"\"\"\n    Calculate the permutation coefficient P(n, k) = n! \/ (n-k)!\n    \n    Args:\n        n (int): Total number of items\n        k (int): Number of items to arrange\n    \n    Returns:\n        int: Permutation coefficient P(n, k)\n    \"\"\"\n    if k > n or k < 0:\n        return 0\n    \n    if k == 0 or k == n:\n        return 1\n    \n    # Calculate P(n, k) = n * (n-1) * (n-2) * ... * (n-k+1)\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n    \n    return result\n```"
  },
  {
    "id":307,
    "response":"```python\ndef remove_words(lst, lst2):\n    \"\"\"\n    নির্দিষ্ট তালিকা থেকে নির্দিষ্ট শব্দগুলি অপসারণ করে।\n    \n    প্যারামিটার:\n    lst: শব্দগুলি থাকে যা অপসারণ করা হবে\n    lst2: অপসারণের জন্য শব্দগুলির তালিকা\n    \n    রিটার্ন:\n    অপসারণ করা শব্দগুলির তালিকা\n    \"\"\"\n    return [word for word in lst if word not in lst2]\n```"
  },
  {
    "id":308,
    "response":"```python\ndef same_order(lst, lst2):\n    \"\"\"\n    Check if two lists have the same elements in the same order.\n    \n    Args:\n        lst: First list\n        lst2: Second list\n    \n    Returns:\n        bool: True if both lists have the same elements in the same order, False otherwise\n    \"\"\"\n    # If both lists are empty, they are identical in order\n    if len(lst) == 0 and len(lst2) == 0:\n        return True\n    \n    # If one list is empty but the other is not, they are not the same\n    if len(lst) == 0 or len(lst2) == 0:\n        return False\n    \n    # Compare elements one by one\n    for i in range(len(lst)):\n        if lst[i] != lst2[i]:\n            return False\n    \n    return True\n```"
  },
  {
    "id":309,
    "response":"```python\ndef average_odd(n):\n    \"\"\"\n    Calculate the average of all odd numbers from 1 to n (inclusive).\n    \n    Args:\n        n (int): The upper limit (inclusive)\n    \n    Returns:\n        float: The average of all odd numbers from 1 to n\n    \"\"\"\n    if n <= 0:\n        return 0.0\n    \n    # Find all odd numbers from 1 to n\n    odd_numbers = [i for i in range(1, n + 1, 2)]\n    \n    # Calculate the average\n    if odd_numbers:\n        return sum(odd_numbers) \/ len(odd_numbers)\n    else:\n        return 0.0\n```"
  },
  {
    "id":310,
    "response":"```python\ndef no_of_subsequences(lst, k):\n    \"\"\"\n    Find the number of subsequences in the given non-negative array \n    whose product is less than k.\n    \n    Args:\n        lst: List of non-negative integers\n        k: Threshold value\n    \n    Returns:\n        Integer count of subsequences with product less than k\n    \"\"\"\n    if not lst or k <= 0:\n        return 0\n    \n    n = len(lst)\n    count = 0\n    \n    # Generate all possible subsequences\n    # Using bit manipulation to represent all subsets\n    for mask in range(1, 1 << n):\n        product = 1\n        for i in range(n):\n            if mask & (1 << i):\n                product *= lst[i]\n        \n        if product < k:\n            count += 1\n    \n    return count\n```"
  },
  {
    "id":311,
    "response":"```python\ndef find_Min_Sum(n):\n    \"\"\"\n    Find the minimum sum of factors of a given number n.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The minimum sum of factors of n\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    if n == 1:\n        return 1\n    \n    # Find all factors of n\n    factors = []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            factors.append(i)\n            if i != n \/\/ i:\n                factors.append(n \/\/ i)\n        i += 1\n    \n    # Return the sum of all factors\n    return sum(factors)\n```"
  },
  {
    "id":312,
    "response":"```python\ndef count_element_freq(tup):\n    \"\"\"\n    Count the frequency of each element in a nested tuple.\n    \n    Args:\n        tup: A nested tuple (can contain tuples, lists, or other iterables)\n    \n    Returns:\n        A dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq = {}\n    \n    def traverse(element):\n        if isinstance(element, tuple):\n            for item in element:\n                traverse(item)\n        elif isinstance(element, list):\n            for item in element:\n                traverse(item)\n        else:\n            freq[element] = freq.get(element, 0) + 1\n    \n    traverse(tup)\n    return freq\n```"
  },
  {
    "id":313,
    "response":"```python\ndef add_str(tup, s):\n    \"\"\"\n    Takes a tuple and a string, and returns a list where each element of the tuple\n    is followed by the string s.\n    \n    Args:\n        tup: A tuple of elements\n        s: A string to append after each element\n    \n    Returns:\n        A list where each element from the tuple is followed by the string s\n    \"\"\"\n    return [str(element) + s for element in tup]\n```"
  },
  {
    "id":314,
    "response":"```python\ndef sum_elements(tup):\n    \"\"\"\n    Calculate the sum of all elements in a tuple.\n    \n    Args:\n        tup: A tuple containing numbers\n        \n    Returns:\n        int or float: The sum of all elements in the tuple\n    \"\"\"\n    return sum(tup)\n```"
  },
  {
    "id":315,
    "response":"```python\ndef modular_sum(lst, m, n, n2):\n    \"\"\"\n    Check if there exists a subset of the list whose sum is divisible by m.\n    \n    Args:\n        lst: List of integers\n        m: Divisor to check divisibility against\n        n: First parameter (not used in current logic)\n        n2: Second parameter (not used in current logic)\n    \n    Returns:\n        True if there exists a subset with sum divisible by m, False otherwise\n    \"\"\"\n    # If m is 0, any sum is divisible by 0 (undefined), so we handle it as edge case\n    if m == 0:\n        return False\n    \n    # If the list is empty, no subset exists (except empty set which has sum 0)\n    if not lst:\n        return True  # Empty set has sum 0, which is divisible by any m != 0\n    \n    # Use dynamic programming to check if any subset sum is divisible by m\n    # dp[i] will be True if sum i (mod m) is achievable\n    dp = [False] * m\n    dp[0] = True  # Sum 0 is always achievable (empty set)\n    \n    for num in lst:\n        # Traverse backwards to avoid using the same element multiple times\n        new_dp = dp[:]\n        for remainder in range(m):\n            if dp[remainder]:\n                new_remainder = (remainder + num) % m\n                new_dp[new_remainder] = True\n        dp = new_dp\n    \n    # Check if sum 0 (mod m) is achievable (i.e., sum divisible by m)\n    return dp[0]\n```"
  },
  {
    "id":316,
    "response":"```python\ndef radix_sort(lst):\n    \"\"\"\n    র্যাডিক্স বাছাই ব্যবহার করে একটি তালিকা বাছাই করে।\n    \n    প্রতিটি উপাদানের অংশগুলি (উদাহরণস্বরূপ দশমিক সংখ্যা) বিশ্লেষণ করে এবং সংখ্যাগুলি আরো সহজ সাজানোর জন্য ব্যবহার করে।\n    \n    Parameters:\n    lst (list): বাছাই করার জন্য তালিকা (অবশ্যই পূর্ণ সংখ্যা হওয়া উচিত)\n    \n    Returns:\n    list: বাছাইকৃত তালিকা\n    \"\"\"\n    if not lst:\n        return lst\n    \n    # সব সংখ্যার সর্বোচ্চ অঙ্কের স্থান বের করা\n    max_num = max(lst)\n    max_digits = len(str(max_num))\n    \n    # প্রতি অঙ্কের জন্য বাছাই করা\n    for digit_place in range(max_digits):\n        # প্রতি অঙ্কের জন্য একটি প্রতিটি অঙ্কের জন্য সাজানো\n        buckets = [[] for _ in range(10)]\n        \n        # প্রতিটি উপাদানকে বিশ্লেষণ করা\n        for num in lst:\n            # এই অঙ্কে"
  },
  {
    "id":317,
    "response":"```python\ndef largest_pos(lst):\n    \"\"\"\n    প্রদত্ত তালিকা থেকে বৃহত্তম ধনাত্মক সংখ্যা খুঁজে পায়।\n    \n    Args:\n        lst: একটি সংখ্যা বিশিষ্ট তালিকা\n        \n    Returns:\n        বৃহত্তম ধনাত্মক সংখ্যা, যদি ধনাত্মক সংখ্যা থাকে, অন্যথা None\n    \"\"\"\n    max_pos = None\n    for num in lst:\n        if num > 0 and (max_pos is None or num > max_pos):\n            max_pos = num\n    return max_pos\n```"
  },
  {
    "id":318,
    "response":"```python\nimport math\n\ndef sqrt_root(n):\n    \"\"\"\n    Calculate the square root of a given integer.\n    \n    Args:\n        n (int): The integer whose square root is to be calculated.\n    \n    Returns:\n        float: The square root of n.\n    \n    Examples:\n        >>> sqrt_root(16)\n        4.0\n        >>> sqrt_root(25)\n        5.0\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Cannot calculate square root of negative number\")\n    \n    return math.sqrt(n)\n```"
  },
  {
    "id":319,
    "response":"```python\nimport math\n\ndef volume_tetrahedron(n):\n    \"\"\"\n    একটি টেট্রাহেড্রনের আয়তন গণনা করে।\n    \n    প্রায় সব টেট্রাহেড্রনের আয়তন হয় তাদের স্থানান্তরিত স্থান বা স্পেস অনুযায়ী হয়।\n    যদি n হয় একটি সমান বাহুর টেট্রাহেড্রনের বাহুর দৈর্ঘ্য, তবে আয়তন হয়:\n    \n    V = (a^3) \/ (6√2)\n    \n    যেখানে a হল বাহুর দৈর্ঘ্য।\n    \n    Parameters:\n    n (float): টেট্রাহেড্রনের বাহুর দৈর্ঘ্য\n    \n    Returns:\n    float: টেট্রাহেড্রনের আয়তন\n    \"\"\"\n    if n <= 0:\n        return 0.0\n    \n    volume = (n ** 3) \/ (6 * math.sqrt(2))\n    return volume\n```"
  },
  {
    "id":320,
    "response":"```python\nimport math\nfrom functools import reduce\n\ndef get_lcm(lst):\n    \"\"\"\n    Calculate the LCM (Least Common Multiple) of all elements in the list.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        The LCM of all elements in the list\n    \"\"\"\n    if not lst:\n        return 0\n    \n    def lcm(a, b):\n        return abs(a * b) \/\/ math.gcd(a, b)\n    \n    return reduce(lcm, lst)\n```"
  },
  {
    "id":321,
    "response":"```python\ndef check_isosceles(n, n2, n3):\n    \"\"\"\n    Check if a triangle is isosceles (has at least two equal sides).\n    \n    Args:\n        n, n2, n3: The three side lengths of the triangle\n        \n    Returns:\n        True if the triangle is isosceles, False otherwise\n    \"\"\"\n    # A triangle is isosceles if at least two sides are equal\n    return n == n2 or n2 == n3 or n == n3\n```"
  },
  {
    "id":322,
    "response":"```python\ndef lbs(lst):\n    \"\"\"\n    Find the length of the longest bitonic subsequence in the given list.\n    \n    A bitonic subsequence is a sequence that first increases (non-decreasing) \n    and then decreases (non-increasing).\n    \n    Args:\n        lst: List of integers\n        \n    Returns:\n        Length of the longest bitonic subsequence\n    \"\"\"\n    if not lst:\n        return 0\n    \n    n = len(lst)\n    \n    # lis[i] represents length of longest increasing subsequence ending at index i\n    lis = [1] * n\n    \n    # lds[i] represents length of longest decreasing subsequence starting at index i\n    lds = [1] * n\n    \n    # Fill lis array (longest increasing subsequence ending at each index)\n    for i in range(1, n):\n        for j in range(i):\n            if lst[j] < lst[i]:\n                lis[i] = max(lis[i], lis[j] + 1)\n    \n    # Fill lds array (longest decreasing subsequence starting at each index)\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1, n):\n            if lst[j] < lst[i]:\n                lds[i] = max(lds[i], lds[j] + 1)\n    \n    # Find the maximum length of bitonic subsequence\n    max_length = 0\n    for i in range(n):\n        max_length = max(max_length, lis[i] + lds[i] - 1)\n    \n    return max_length\n```"
  },
  {
    "id":323,
    "response":"```python\ncheck_string = lambda s, length: len(s) == length and any(c.isupper() for c in s) and any(c.islower() for c in s) and any(c.isdigit() for c in s)\n```"
  },
  {
    "id":324,
    "response":"```python\ndef max_sum_increasing_subsequence(lst, n):\n    \"\"\"\n    Find the maximum sum of an increasing subsequence in the given array.\n    \n    Args:\n        lst: List of integers\n        n: Length of the array\n    \n    Returns:\n        Maximum sum of increasing subsequence\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    # dp[i] represents the maximum sum of increasing subsequence ending at index i\n    dp = [0] * n\n    \n    # Initialize dp array\n    for i in range(n):\n        dp[i] = lst[i]\n    \n    # Fill dp array\n    for i in range(1, n):\n        for j in range(i):\n            if lst[j] < lst[i]:\n                dp[i] = max(dp[i], dp[j] + lst[i])\n    \n    # Return the maximum value in dp array\n    return max(dp)\n```"
  },
  {
    "id":325,
    "response":"```python\ndef parallel_lines(lst, lst2):\n    \"\"\"\n    Check if two lines are parallel.\n    \n    Args:\n        lst: List representing the first line in the form [x1, y1, x2, y2]\n        lst2: List representing the second line in the form [x1, y1, x2, y2]\n    \n    Returns:\n        bool: True if the lines are parallel, False otherwise\n    \"\"\"\n    # Extract coordinates\n    x1, y1, x2, y2 = lst\n    x3, y3, x4, y4 = lst2\n    \n    # Calculate slopes\n    # For line 1: slope = (y2 - y1) \/ (x2 - x1)\n    # For line 2: slope = (y4 - y3) \/ (x4 - x3)\n    \n    # Handle vertical lines (infinite slope)\n    if x2 == x1:\n        slope1 = float('inf')\n    else:\n        slope1 = (y2 - y1) \/ (x2 - x1)\n    \n    if x4 == x3:\n        slope2 = float('inf')\n    else:\n        slope2 = (y4 - y3) \/ (x4 - x3)\n    \n    # Lines are parallel if slopes are equal (or both are infinite)\n    return slope1 == slope2\n```"
  },
  {
    "id":326,
    "response":"```python\ndef capitalize_first_last_letters(s):\n    \"\"\"\n    Capitalizes the first and last letters of each word in a string.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: String with first and last letters of each word capitalized\n    \"\"\"\n    if not s:\n        return s\n    \n    words = s.split()\n    result = []\n    \n    for word in words:\n        if len(word) == 1:\n            result.append(word.upper())\n        else:\n            first_letter = word[0].upper()\n            last_letter = word[-1].upper()\n            middle_letters = word[1:-1]\n            result.append(first_letter + middle_letters + last_letter)\n    \n    return ' '.join(result)\n```"
  },
  {
    "id":327,
    "response":"```python\ndef get_pairs_count(lst, n, n2):\n    \"\"\"\n    একটি পূর্ণসংখ্যা অ্যারেতে সমস্ত জোড়া খুঁজে বের করে যার যোগফল প্রদত্ত সংখ্যা n এবং n2 এর সমান।\n    \n    নোট: এখানে বাকি সংখ্যা n2 এর ক্ষেত্রে ব্যবহার হয়নি যদি সমস্ত জোড়ার যোগফল n হয়।\n    যদি n2 ব্যবহার হয় তবে সম্ভবত সমস্ত জোড়ার যোগফল n এবং n2 উভয়ই হয়।\n    \n    এখানে ধরা হয়েছে যে যোগফল n হওয়া উচিত।\n    \n    Parameters:\n    lst: পূর্ণসংখ্যা অ্যারে\n    n: যোগফলের মান (প্রদত্ত সংখ্যা)\n    n2: অপর সংখ্যা (সম্ভবত ত্রুটি বা অপসারণ হয়েছে)\n    \n    Returns:\n    যোগফল n এর জোড়ার সংখ্যা\n    \"\"\"\n    count = 0\n    seen = set()\n    \n    for num in lst:\n        complement = n - num\n        if complement in seen:\n            count +="
  },
  {
    "id":328,
    "response":"```python\ndef min_length(lst):\n    \"\"\"\n    তালিকার সর্বনিম্ন দৈর্ঘ্য খুঁজে বের করে।\n    \n    প্যারামিটার:\n    lst: একটি তালিকা (list) যার দৈর্ঘ্য খুঁজে বের করা হবে\n    \n    রিটার্ন:\n    তালিকার সর্বনিম্ন দৈর্ঘ্য (int)\n    \"\"\"\n    if not lst:\n        return 0\n    return len(lst)\n```"
  },
  {
    "id":329,
    "response":"```python\ndef jacobsthal_lucas(n):\n    \"\"\"\n    Calculate the nth Jacobsthal-Lucas number.\n    \n    The Jacobsthal-Lucas numbers are defined by the recurrence relation:\n    J(0) = 2, J(1) = 1, and J(n) = J(n-1) + 2*J(n-2) for n >= 2.\n    \n    Args:\n        n (int): The index of the Jacobsthal-Lucas number to compute.\n    \n    Returns:\n        int: The nth Jacobsthal-Lucas number.\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    a, b = 2, 1  # J(0) = 2, J(1) = 1\n    for i in range(2, n + 1):\n        a, b = b, a + 2 * b\n    \n    return b\n```"
  },
  {
    "id":330,
    "response":"```python\ndef negative_count(lst):\n    \"\"\"\n    পূর্ণসংখ্যার একটি অ্যারেতে নেতিবাচন সংখ্যার অনুপাত খুঁজে বের করে।\n    \n    অনুপাত = নেতিবাচন সংখ্যা \/ সমস্ত সংখ্যা\n    \"\"\"\n    if not lst:\n        return 0\n    \n    negative_count_value = sum(1 for x in lst if x < 0)\n    total_count = len(lst)\n    \n    return negative_count_value \/ total_count\n```"
  },
  {
    "id":331,
    "response":"```python\ndef min_coins(lst, n, n2):\n    \"\"\"\n    প্রদত্ত মান n এবং n2 কে তৈরি করার জন্য ন্যূনতম সংখ্যক মুদ্রা খুঁজে বের করে।\n    \n    প্রদত্ত:\n    lst: মুদ্রা এর মানের তালিকা (যেমন [1, 3, 4])\n    n: প্রথম মান\n    n2: দ্বিতীয় মান\n    \n    ফেরত দেয়:\n    দুটি মান তৈরি করার জন্য ন্যূনতম মুদ্রা সংখ্যা\n    \"\"\"\n    # যদি কোনো মুদ্রা না থাকে তবে অসম্ভব\n    if not lst:\n        return -1\n    \n    # মুদ্রা এর মানগুলি সাজানো\n    lst.sort()\n    \n    # মুদ্রা এর সংখ্যা নির্ধারণ\n    coins_needed = 0\n    \n    # প্রতিটি মুদ্রা দিয়ে মানগুলি তৈরি করা\n    # প্রথমে সব মুদ্রা ব্যবহার করে ন্যূনতম সংখ্যক মুদ্রা খুঁজে বের করা\n    for coin in lst:\n        if coin >= n:\n            coins_needed"
  },
  {
    "id":332,
    "response":"```python\ndef check_permutation(s, s2):\n    \"\"\"\n    Check if two strings are permutations of each other.\n    \n    Args:\n        s (str): First string\n        s2 (str): Second string\n    \n    Returns:\n        bool: True if the strings are permutations of each other, False otherwise\n    \"\"\"\n    # If lengths are different, they can't be permutations\n    if len(s) != len(s2):\n        return False\n    \n    # Sort both strings and compare\n    return sorted(s) == sorted(s2)\n```"
  },
  {
    "id":333,
    "response":"```python\ndef remove_datatype(tup, param):\n    \"\"\"\n    প্রদত্ত টিউপেল থেকে নির্দিষ্ট ডেটা টাইপ উপাদানগুলি সরিয়ে ফেলে।\n    \n    Args:\n        tup: টিউপেল যেখানে উপাদান সরাবে\n        param: সরাবে উপাদানের ডেটা টাইপ (যেমন: int, str, float, list, etc.)\n    \n    Returns:\n        নির্দিষ্ট ডেটা টাইপ উপাদানগুলি সরিয়ে ফেলা টিউপেল\n    \"\"\"\n    if param not in [int, str, float, list, tuple, dict, set, bool]:\n        raise ValueError(\"Invalid data type parameter. Use one of: int, str, float, list, tuple, dict, set, bool\")\n    \n    result = []\n    for item in tup:\n        if not isinstance(item, param):\n            result.append(item)\n    \n    return tuple(result)\n```"
  },
  {
    "id":334,
    "response":"```python\ndef search_literal(s, s2):\n    \"\"\"\n    একটি স্ট্রিংয়ের মধ্যে একটি আক্ষরিক স্ট্রিং (প্যাটার্ন) অনুসন্ধান করে অবস্থানটি সন্ধান করে।\n    \n    Parameters:\n    s (str): মূল স্ট্রিং\n    s2 (str): অনুসন্ধানের প্যাটার্ন স্ট্রিং\n    \n    Returns:\n    int: প্যাটার্নটির প্রথম অবস্থান (পাওয়া গেলে), অন্যথায় -1\n    \"\"\"\n    if s2 == \"\":\n        return 0\n    \n    for i in range(len(s) - len(s2) + 1):\n        if s[i:i + len(s2)] == s2:\n            return i\n    \n    return -1\n```"
  },
  {
    "id":335,
    "response":"```python\ndef topbottom_surfacearea(n):\n    \"\"\"\n    Calculate the surface area of the top and bottom of a cylinder.\n    \n    Args:\n        n: The radius of the cylinder's base (or any parameter representing the base dimension)\n    \n    Returns:\n        The combined surface area of the top and bottom circles of the cylinder.\n    \"\"\"\n    import math\n    # Area of one circular face = π * r^2\n    # Since we have both top and bottom, total area = 2 * π * r^2\n    return 2 * math.pi * n * n\n```"
  },
  {
    "id":336,
    "response":"```python\ndef nth_items(lst, n):\n    \"\"\"\n    একটি তালিকার n-তম আইটেম নির্বাচন করে।\n    \n    Args:\n        lst: তালিকা\n        n: n-তম আইটেমের ক্রম (1 থেকে শুরু করে)\n    \n    Returns:\n        n-তম আইটেম, যদি তালিকার সংখ্যা যথেষ্ট হয়, অন্যথায় কোনও মান রিটার্ন করবে না।\n    \"\"\"\n    if n <= 0 or len(lst) < n:\n        return None\n    return lst[n - 1]\n```"
  },
  {
    "id":337,
    "response":"```python\ndef first_repeated_word(s):\n    \"\"\"\n    Find the first repeated word in a given string.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: The first word that appears more than once, or None if no repetition found\n    \"\"\"\n    if not s or not s.strip():\n        return None\n    \n    # Split the string into words and convert to lowercase\n    words = s.lower().split()\n    \n    # Remove punctuation from each word\n    cleaned_words = []\n    for word in words:\n        cleaned_word = ''.join(char for char in word if char.isalnum())\n        if cleaned_word:  # Only add non-empty words\n            cleaned_words.append(cleaned_word)\n    \n    # Use a set to track seen words\n    seen = set()\n    for word in cleaned_words:\n        if word in seen:\n            return word\n        seen.add(word)\n    \n    return None\n```"
  },
  {
    "id":338,
    "response":"```python\ndef string_list_to_tuple(string_list):\n    \"\"\"\n    প্রদত্ত স্ট্রিং তালিকাকে একটি টিপলে রূপান্তর করে।\n    \n    Args:\n        string_list (list): স্ট্রিং তালিকা\n        \n    Returns:\n        tuple: স্ট্রিং তালিকার রূপান্তরিত টিপল\n    \"\"\"\n    return tuple(string_list)\n```"
  },
  {
    "id":339,
    "response":"```python\ndef basesnum_coresspondingnum(lst, lst2):\n    \"\"\"\n    মানচিত্র ফাংশন ব্যবহার করে সূচকের সংশ্লিষ্ট সংখ্যার উপর ভিত্তি করে এই সংখ্যার শক্তি ধারণকারী একটি তালিকা তৈরি করে।\n    \n    Parameters:\n    lst: সূচকের তালিকা (যেমন [2, 3, 4])\n    lst2: সংশ্লিষ্ট সংখ্যার তালিকা (যেমন [4, 9, 16])\n    \n    Returns:\n    সংখ্যার শক্তি ধারণকারী তালিকা (যেমন [16, 81, 256])\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        base = lst[i]\n        power = lst2[i]\n        result.append(base ** power)\n    return result\n```"
  },
  {
    "id":340,
    "response":"```python\ndef find_Diff(lst, n):\n    \"\"\"\n    Find the difference between the maximum and minimum frequencies in the list.\n    \n    Args:\n        lst: List of elements\n        n: Not used in the function (possibly a parameter for future use)\n    \n    Returns:\n        Difference between maximum and minimum frequencies\n    \"\"\"\n    if not lst:\n        return 0\n    \n    # Count frequency of each element\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    \n    # Get frequencies\n    frequencies = list(freq.values())\n    \n    # Find max and min frequencies\n    max_freq = max(frequencies)\n    min_freq = min(frequencies)\n    \n    return max_freq - min_freq\n```"
  },
  {
    "id":341,
    "response":"```python\ndef check_abundant(n):\n    \"\"\"\n    Check if a number is abundant.\n    \n    An abundant number is a number for which the sum of its proper divisors \n    (divisors excluding the number itself) is greater than the number.\n    \n    Args:\n        n (int): The number to check\n        \n    Returns:\n        bool: True if the number is abundant, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    # Find all proper divisors and sum them\n    divisor_sum = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisor_sum += i\n            # Add the corresponding divisor (n \/\/ i) if it's different from i\n            if i != n \/\/ i and i != n:\n                divisor_sum += n \/\/ i\n    \n    # Check if sum of proper divisors is greater than n\n    return divisor_sum > n\n```"
  },
  {
    "id":342,
    "response":"```python\nimport re\n\ndef fill_spaces(s):\n    \"\"\"\n    Replace spaces, commas, and periods in a string with pipes (|).\n    \n    Args:\n        s (str): Input string to process\n        \n    Returns:\n        str: String with spaces, commas, and periods replaced by pipes\n    \"\"\"\n    return re.sub(r'[ ,.]', '|', s)\n```"
  },
  {
    "id":343,
    "response":"```python\ndef count_digits(n, n2):\n    \"\"\"যোগ করে সমষ্টির সংখ্যা মুদ্রণ করে\"\"\"\n    total = n + n2\n    print(total)\n```"
  },
  {
    "id":344,
    "response":"```python\ndef flatten_tuple(lst):\n    \"\"\"\n    একটি স্ট্রিং এ টিপল তালিকা সমতল করার জন্য একটি ফাংশন লিখুন।\n    \n    Parameters:\n    lst: একটি টিপল বা তালিকা যা সমতল করা হবে।\n    \n    Returns:\n    সমতল করা তালিকা যা স্ট্রিং হিসেবে ফেরত দেয়।\n    \"\"\"\n    result = []\n    for item in lst:\n        if isinstance(item, tuple):\n            result.extend(flatten_tuple(item))\n        else:\n            result.append(item)\n    return tuple(result)\n```"
  },
  {
    "id":345,
    "response":"```python\ndef toggle_F_and_L_bits(n):\n    \"\"\"\n    Toggle the first and last bits of a given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The number with first and last bits toggled\n    \"\"\"\n    # Handle edge case where n is 0\n    if n == 0:\n        return 1\n    \n    # Find the number of bits in n\n    bit_length = n.bit_length()\n    \n    # Get the last bit (least significant bit)\n    last_bit = n & 1\n    \n    # Get the first bit (most significant bit)\n    first_bit = (n >> (bit_length - 1)) & 1\n    \n    # Toggle the first and last bits\n    # Create a mask for the first bit position\n    first_bit_mask = 1 << (bit_length - 1)\n    \n    # Toggle first bit\n    toggled_n = n ^ first_bit_mask\n    \n    # Toggle last bit\n    toggled_n = toggled_n ^ (1 if last_bit == 0 else 0)\n    \n    return toggled_n\n```"
  },
  {
    "id":346,
    "response":"```python\ndef last_occurence_char(s, s2):\n    \"\"\"\n    একটি স্ট্রিং s-এ অক্ষর s2-এর শেষ উপস্থিতি খুঁজে বের করে।\n    \n    প্যারামিটার:\n    s (str): অক্ষর খুঁজে বের করার জন্য স্ট্রিং\n    s2 (str): খুঁজে বের করার অক্ষর\n    \n    রিটার্ন:\n    int: অক্ষরের শেষ উপস্থিতি যদি অক্ষরটি থাকে, অন্যথা -1\n    \"\"\"\n    if s2 not in s:\n        return -1\n    \n    # শেষ উপস্থিতি খুঁজে বের করা\n    return len(s) - s[::-1].index(s2) - 1\n```"
  },
  {
    "id":347,
    "response":"```python\ndef total_hamming_distance(n):\n    \"\"\"\n    Calculate the total Hamming distance between all pairs of numbers from 0 to n (inclusive).\n    \n    The Hamming distance between two numbers is the number of positions at which the binary representations\n    differ.\n    \n    Args:\n        n (int): The upper bound (inclusive) of the range [0, n].\n    \n    Returns:\n        int: The sum of Hamming distances between all pairs of numbers in the range.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    total_distance = 0\n    \n    # For each bit position (0 to 31, since n can be up to 2^31-1)\n    for bit_pos in range(32):\n        # Count how many numbers in [0, n] have the bit set at position bit_pos\n        bit_count = 0\n        power_of_2 = 1 << bit_pos\n        \n        # Count numbers with bit set at current position\n        # This is a standard bit counting trick\n        if power_of_2 <= n + 1:\n            # Complete groups of 2^k\n            full_groups = (n + 1) \/\/ (2 * power_of_2)\n            bit_count += full_groups * power_of_2\n            \n            # Remaining numbers in the incomplete group\n            remainder = (n + 1) % (2 * power_of_2)\n            bit_count += max(0, remainder - power_of_2)\n        \n        # Numbers with bit not set = (n + 1) - bit_count\n        numbers_without_bit = (n + 1) - bit_count\n        \n        # Hamming distance contribution from this bit position\n        # Each pair where one has the bit and the other doesn't contributes 1\n        total_distance += bit_count * numbers_without_bit\n    \n    return total_distance\n```"
  },
  {
    "id":348,
    "response":"```python\ndef longest_increasing_subsequence(lst):\n    if not lst:\n        return 0\n    \n    n = len(lst)\n    # dp[i] represents the length of the longest increasing subsequence ending at index i\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if lst[j] < lst[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n```"
  },
  {
    "id":349,
    "response":"```python\ndef odd_Num_Sum(n):\n    \"\"\"\n    প্রথম n অদ্ভুত প্রাকৃতিক সংখ্যার পঞ্চম ক্ষমতার যোগফল খুঁজে বের করে।\n    \n    অদ্ভুত প্রাকৃতিক সংখ্যা: 1, 3, 5, 7, 9, ...\n    পঞ্চম ক্ষমতা: x^5\n    \n    Parameters:\n    n (int): প্রথম n অদ্ভুত সংখ্যা নির্দেশ করে\n    \n    Returns:\n    int: প্রথম n অদ্ভুত সংখ্যার পঞ্চম ক্ষমতার যোগফল\n    \"\"\"\n    total = 0\n    for i in range(n):\n        odd_num = 2 * i + 1\n        total += odd_num ** 5\n    return total\n```"
  },
  {
    "id":350,
    "response":"```python\ndef find_Max(lst, n, n2):\n    \"\"\"\n    Find the maximum element in a sorted and rotated array.\n    \n    Args:\n        lst: A sorted and rotated array (list of integers)\n        n: Length of the array\n        n2: (Unused parameter, likely a typo or placeholder)\n    \n    Returns:\n        The maximum element in the array\n    \"\"\"\n    # In a sorted and rotated array, the maximum element is the last element\n    # of the original sorted array before rotation.\n    # However, in a rotated array, the maximum element is at the position\n    # where the array breaks (i.e., where lst[i] > lst[i+1]).\n    \n    # If the array has only one element, return that element\n    if n == 1:\n        return lst[0]\n    \n    # If the array is not rotated (i.e., already sorted), the maximum is at the end\n    if lst[0] <= lst[n-1]:\n        return lst[n-1]\n    \n    # Find the pivot point where the rotation occurred\n    left, right = 0, n - 1\n    \n    while left < right:\n        mid = (left + right) \/\/ 2\n        \n        # If mid element is greater than the rightmost element,\n        # the maximum is in the right half\n        if lst[mid] > lst[right]:\n            left = mid + 1\n        else:\n            # Otherwise, the maximum is in the left half (including mid)\n            right = mid\n    \n    # At this point, left == right, which is the index of the maximum element\n    return lst[left]\n```"
  },
  {
    "id":351,
    "response":"```python\ndef extract_column(lst, n):\n    \"\"\"\n    Extracts a specific column from a nested list.\n    \n    Args:\n        lst: A nested list where each inner list represents a row.\n        n: The index of the column to extract (0-based).\n    \n    Returns:\n        A list containing the values from the nth column of each row.\n    \n    Raises:\n        IndexError: If the column index n is out of bounds for any row.\n    \"\"\"\n    result = []\n    for row in lst:\n        if len(row) > n:\n            result.append(row[n])\n        else:\n            # If the row is shorter than the requested column, skip it\n            # or raise an error depending on requirements\n            pass\n    return result\n```"
  },
  {
    "id":352,
    "response":"```python\ndef Seq_Linear(lst):\n    \"\"\"\n    প্রদত্ত ক্রমটি রৈখিক কিনা তা পরীক্ষা করে।\n    রৈখিক ক্রম হল যে ক্রমের প্রতিটি উপাদান পূর্বের উপাদানের সাথে একটি স্থির পরিবর্তনের সাথে সম্পর্কিত হয়।\n    \n    উদাহরণস্বরূপ: [1, 3, 5, 7, 9] রৈখিক কারণ প্রতিটি উপাদান 2 দ্বারা বৃদ্ধি পায়।\n    \n    Parameters:\n    lst (list): ক্রমের উপাদানগুলি একটি লিস্টে দেওয়া হয়।\n    \n    Returns:\n    bool: ক্রমটি রৈখিক হলে True, না হলে False।\n    \"\"\"\n    # ক্রমের দৈর্ঘ্য একটি না হলে রৈখিক হবে না\n    if len(lst) <= 1:\n        return True\n    \n    # প্রথম দুটি উপাদান থেকে সাধারণ পার্থক্য বের করা\n    common_diff = lst[1] - lst[0]\n    \n    # প্রতিটি পরবর্তী উপাদানের সাথে পার্থক্য যাচ"
  },
  {
    "id":353,
    "response":"```python\ndef tuple_to_float(tup):\n    \"\"\"\n    প্রদত্ত টিউপলকে একটি ফ্লোটিং-পয়েন্ট সংখ্যায় রূপান্তর করে।\n    \n    প্যারামিটার:\n    tup: একটি টিউপল (তুলো হতে প্রতিটি সংখ্যা ফ্লোটে রূপান্তর হবে)\n    \n    রিটার্ন:\n    ফ্লোটিং-পয়েন্ট সংখ্যা\n    \"\"\"\n    # টিউপলের প্রতিটি সংখ্যা ফ্লোটে রূপান্তর করে এবং যোগ করে\n    return sum(float(x) for x in tup)\n```"
  },
  {
    "id":354,
    "response":"```python\ndef split(lst):\n    \"\"\"\n    একটি মিশ্র তালিকা থেকে অদ্ভুত সংখ্যা (অদ্ভুত মান যা অন্য সব মানের থেকে বিভিন্ন) খুঁজে পেতে একটি ফাংশন।\n    এখানে অদ্ভুত সংখ্যা হল যে সংখ্যা যা অন্য সব মানের থেকে বিভিন্ন হয় (যেমন সব সংখ্যা যদি জোড় হয় তবে একটি বিজোড় সংখ্যা অদ্ভুত হবে)।\n    \n    Parameters:\n    lst: মিশ্র তালিকা (সংখ্যা এবং অন্য মানের মিশ্রণ)\n    \n    Returns:\n    অদ্ভুত সংখ্যা যদি থাকে, না থাকলে None\n    \"\"\"\n    if not lst:\n        return None\n    \n    # সংখ্যা এবং অসংখ্যা মান ফেলে দেখার জন্য\n    numbers = [item for item in lst if isinstance(item, (int, float))]\n    non_numbers = [item for item in lst if not isinstance(item, (int, float))]\n    \n    # যদি সংখ্যা না থাকে\n    if not numbers:\n        return None\n    \n    # সব সংখ্যা জোড় হলে বিজ"
  },
  {
    "id":355,
    "response":"```python\ndef difference(n):\n    \"\"\"\n    Calculate the difference between the sum of cubes of first n natural numbers\n    and the sum of first n natural numbers.\n    \n    Args:\n        n (int): The number of natural numbers to consider\n        \n    Returns:\n        int: The difference between sum of cubes and sum of numbers\n    \"\"\"\n    # Sum of first n natural numbers: n*(n+1)\/2\n    sum_of_numbers = n * (n + 1) \/\/ 2\n    \n    # Sum of cubes of first n natural numbers: [n*(n+1)\/2]^2\n    sum_of_cubes = (n * (n + 1) \/\/ 2) ** 2\n    \n    # Return the difference\n    return sum_of_cubes - sum_of_numbers\n```"
  },
  {
    "id":356,
    "response":"```python\ndef find_Odd_Pair(lst, n):\n    \"\"\"\n    Find pairs of numbers in the list that have an XOR result equal to n.\n    \n    Args:\n        lst: List of integers\n        n: Target XOR value\n    \n    Returns:\n        List of tuples containing pairs (i, j) where lst[i] ^ lst[j] == n\n    \"\"\"\n    pairs = []\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] ^ lst[j] == n:\n                pairs.append((i, j))\n    return pairs\n```"
  },
  {
    "id":357,
    "response":"```python\ndef toggle_string(s):\n    \"\"\"\n    একটি স্ট্রিংয়ের অক্ষরগুলির কেস টগল করে ফেরত দেয়।\n    \n    Args:\n        s (str): কেস টগল করার জন্য দেয়া স্ট্রিং\n        \n    Returns:\n        str: কেস টগল করা স্ট্রিং\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n```"
  },
  {
    "id":358,
    "response":"```python\ndef digit_distance_nums(n, n2):\n    \"\"\"\n    Calculate the digit distance between two integers.\n    Digit distance is the sum of absolute differences between each corresponding digit.\n    \n    Args:\n        n (int): First integer\n        n2 (int): Second integer\n    \n    Returns:\n        int: Digit distance between the two numbers\n    \n    Example:\n        digit_distance_nums(123, 456) -> |1-4| + |2-5| + |3-6| = 3 + 3 + 3 = 9\n    \"\"\"\n    # Convert numbers to strings to access individual digits\n    str_n = str(abs(n))\n    str_n2 = str(abs(n2))\n    \n    # Ensure both numbers have the same length by padding with zeros on the left\n    max_len = max(len(str_n), len(str_n2))\n    str_n = str_n.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    \n    # Calculate the sum of absolute differences of corresponding digits\n    distance = 0\n    for i in range(max_len):\n        distance += abs(int(str_n[i]) - int(str_n2[i]))\n    \n    return distance\n```"
  },
  {
    "id":359,
    "response":"```python\ndef max_sub_array_sum(lst, n):\n    \"\"\"\n    Find the maximum sum of a contiguous subarray in the given array.\n    \n    Args:\n        lst: List of integers\n        n: Length of the array\n    \n    Returns:\n        Integer representing the maximum sum of a contiguous subarray\n    \"\"\"\n    if not lst or n == 0:\n        return 0\n    \n    max_sum = lst[0]\n    current_sum = lst[0]\n    \n    for i in range(1, n):\n        current_sum = max(lst[i], current_sum + lst[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```"
  },
  {
    "id":360,
    "response":"```python\ndef union_elements(tup, tup2):\n    \"\"\"\n    Returns the union of elements from two tuples.\n    \n    Args:\n        tup: First tuple\n        tup2: Second tuple\n    \n    Returns:\n        A tuple containing the union of elements from both tuples\n    \"\"\"\n    # Convert tuples to sets to find union, then convert back to tuple\n    return tuple(set(tup) | set(tup2))\n```"
  },
  {
    "id":361,
    "response":"```python\ndef assign_elements(lst):\n    \"\"\"\n    Assigns each element to its paired element in a list of tuples.\n    Each element is paired with another element from the list.\n    \n    Args:\n        lst: A list of tuples, where each tuple contains two elements.\n             The list is expected to have an even number of elements.\n    \n    Returns:\n        A dictionary mapping each element to its paired element.\n    \"\"\"\n    if not lst or len(lst) % 2 != 0:\n        raise ValueError(\"List must have an even number of elements\")\n    \n    result = {}\n    for i in range(0, len(lst), 2):\n        pair = lst[i]\n        if len(pair) != 2:\n            raise ValueError(f\"Each tuple must contain exactly two elements. Found {len(pair)} elements.\")\n        result[pair[0]] = pair[1]\n    \n    return result\n```"
  },
  {
    "id":362,
    "response":"```python\ndef Find_Max_Length(lst):\n    \"\"\"\n    Find the maximum length among all sublists in a list of lists.\n    \n    Args:\n        lst: A list of lists (or sublists)\n    \n    Returns:\n        int: The maximum length of any sublist in the input list\n    \"\"\"\n    if not lst:\n        return 0\n    \n    max_length = 0\n    for sublist in lst:\n        max_length = max(max_length, len(sublist))\n    \n    return max_length\n```"
  },
  {
    "id":363,
    "response":"```python\ndef extract_values(s):\n    \"\"\"\n    Extract values from a string that is enclosed in quotes.\n    \n    Args:\n        s (str): Input string containing quoted values\n        \n    Returns:\n        list: List of extracted values (strings) from within quotes\n    \"\"\"\n    values = []\n    i = 0\n    n = len(s)\n    \n    while i < n:\n        # Look for opening quote\n        if s[i] in ['\"', \"'\"]:\n            quote = s[i]\n            i += 1\n            value = \"\"\n            \n            # Collect characters until closing quote\n            while i < n and s[i] != quote:\n                value += s[i]\n                i += 1\n            \n            # Skip the closing quote\n            if i < n and s[i] == quote:\n                i += 1\n                \n            values.append(value)\n        \n        else:\n            i += 1\n    \n    return values\n```"
  },
  {
    "id":364,
    "response":"```python\ndef count_Pairs(lst, n):\n    \"\"\"\n    Count the number of odd pairs in the given list.\n    \n    Args:\n        lst: List of integers\n        n: Target sum for pairs (not used in current implementation)\n    \n    Returns:\n        Number of pairs where both elements are odd\n    \"\"\"\n    # Count odd numbers in the list\n    odd_count = sum(1 for x in lst if x % 2 == 1)\n    \n    # Number of ways to choose 2 odd numbers from odd_count\n    # This is C(odd_count, 2) = odd_count * (odd_count - 1) \/ 2\n    if odd_count < 2:\n        return 0\n    \n    return odd_count * (odd_count - 1) \/\/ 2\n```"
  },
  {
    "id":365,
    "response":"```python\ndef split(s):\n    \"\"\"\n    একটি স্ট্রিংকে অক্ষরে বিভক্ত করে ফেরত দেয়।\n    \n    Args:\n        s (str): বিভক্ত করার জন্য স্ট্রিং\n        \n    Returns:\n        list: অক্ষরগুলির একটি তালিকা\n    \"\"\"\n    return list(s)\n```"
  },
  {
    "id":366,
    "response":"```python\ndef sum_digits(n):\n    \"\"\"\n    একটি অ-নতিবাচক পূর্ণসংখ্যার যোগফল পেতে একটি ফাংশন লিখুন।\n    \n    উদাহরণ: sum_digits(123) এর প্রতিক্রিয়া 1+2+3 = 6\n    \n    প্যারামিটার:\n        n (int): অ-নতিবাচক পূর্ণসংখ্যা\n    \n    রিটার্ন:\n        int: সংখ্যার অঙ্কগুলির যোগফল\n    \"\"\"\n    total = 0\n    while n > 0:\n        total += n % 10\n        n \/\/= 10\n    return total\n```"
  },
  {
    "id":367,
    "response":"```python\ndef issort_list(lst):\n    \"\"\"\n    একটি তালিকা সাজানো আছে কিনা তা পরীক্ষা করে।\n    \n    Parameters:\n    lst (list): তালিকা যার সাজানো আছে কিনা তা পরীক্ষা করা হবে।\n    \n    Returns:\n    bool: যদি তালিকা সাজানো আছে তবে True, অন্যথায় False।\n    \"\"\"\n    if len(lst) <= 1:\n        return True\n    \n    for i in range(1, len(lst)):\n        if lst[i] < lst[i-1]:\n            return False\n    return True\n```"
  },
  {
    "id":368,
    "response":"```python\ndef empty_list(n):\n    \"\"\"\n    খালি অভিধানের একটি তালিকা তৈরি করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    n (int): তালিকার দৈর্ঘ্য নির্ধারণের জন্য প্রয়োজন।\n    \n    ফেরত দেয়:\n    list: খালি তালিকা।\n    \"\"\"\n    return []\n```"
  },
  {
    "id":369,
    "response":"```python\ndef sort_sublists(lst):\n    \"\"\"\n    প্রদত্ত তালিকার প্রতিটি স্ট্রিংয়ের উপ-তালিকা বাছাই করে।\n    \n    Args:\n        lst: একটি তালিকা, যার প্রতিটি উপাংশ একটি স্ট্রিং হবে বা একটি তালিকা হবে।\n    \n    Returns:\n        প্রতিটি উপ-তালিকা বাছাই করা তালিকা।\n    \"\"\"\n    result = []\n    for item in lst:\n        if isinstance(item, list):\n            sorted_item = sorted(item)\n            result.append(sorted_item)\n        else:\n            result.append(item)\n    return result\n```"
  },
  {
    "id":370,
    "response":"```python\ndef remove_words(lst, lst2):\n    \"\"\"\n    দুটি স্ট্রিং তালিকা থেকে দ্বিতীয় তালিকার স্ট্রিংগুলি সরিয়ে ফেলে।\n    \n    Args:\n        lst: প্রথম স্ট্রিং তালিকা\n        lst2: দ্বিতীয় স্ট্রিং তালিকা (সরানো হবে)\n    \n    Returns:\n        দ্বিতীয় তালিকার স্ট্রিংগুলি সরিয়ে ফেলা প্রথম তালিকা\n    \"\"\"\n    return [word for word in lst if word not in lst2]\n```"
  },
  {
    "id":371,
    "response":"```python\ndef max_sum_pair_diff_lessthan_K(lst, k, n, n2):\n    \"\"\"\n    Find the maximum sum of pairs where the absolute difference between elements in each pair is less than k.\n    \n    Args:\n        lst: List of integers\n        k: Threshold value for the difference between elements in a pair\n        n: First parameter (not used in current logic)\n        n2: Second parameter (not used in current logic)\n    \n    Returns:\n        Maximum sum of pairs where |a - b| < k\n    \"\"\"\n    # Since n and n2 are not used in the problem description, we'll ignore them\n    # We need to find pairs (i, j) such that |lst[i] - lst[j]| < k and maximize the sum of such pairs\n    \n    # If list has less than 2 elements, no pairs possible\n    if len(lst) < 2:\n        return 0\n    \n    # Sort the list to make it easier to find pairs with difference < k\n    sorted_lst = sorted(lst)\n    n = len(sorted_lst)\n    max_sum = 0\n    \n    # For each element, find the largest element that satisfies |a - b| < k\n    # Since the list is sorted, we can use two pointers or binary search\n    for i in range(n):\n        # Find the largest j such that sorted_lst[j] - sorted_lst[i] < k\n        # This means sorted_lst[j] < sorted_lst[i] + k\n        left, right = i + 1, n - 1\n        best_j = -1\n        \n        while left <= right:\n            mid = (left + right) \/\/ 2\n            if sorted_lst[mid] < sorted_lst[i] + k:\n                best_j = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        # If we found a valid pair (best_j != -1 and best_j > i)\n        if best_j != -1 and best_j > i:\n            # Add the sum of the pair (i, best_j)\n            max_sum += sorted_lst[i] + sorted_lst[best_j]\n    \n    return max_sum\n```"
  },
  {
    "id":372,
    "response":"```python\ndef two_unique_nums(lst):\n    \"\"\"\n    একটি তালিকা থেকে দুটি ডুপ্লিকেট সংখ্যা অপসারণ করে দুটি আলাদা সংখ্যা ফেরত দেয়।\n    \n    যদি তালিকায় দুটি ডুপ্লিকেট থাকে, তবে এই ফাংশন তাদের অপসারণ করে আলাদা দুটি সংখ্যা ফেরত দেয়।\n    যদি ডুপ্লিকেট না থাকে, তবে সবগুলো সংখ্যা ফেরত দেয়।\n    \n    Args:\n        lst: একটি সংখ্যা বিশিষ্ট তালিকা\n        \n    Returns:\n        ডুপ্লিকেট সংখ্যা অপসারণের পর আলাদা সংখ্যাগুলো একটি তালিকা হিসাবে ফেরত দেয়।\n    \"\"\"\n    if not lst:\n        return []\n    \n    # তালিকার মধ্যে কতগুলো সংখ্যা আছে তা দেখার জন্য সেট ব্যবহার করা হয়\n    seen = set()\n    unique_nums = []\n    \n    for num in lst:\n        if num not in seen:\n            seen.add(num)\n            unique_nums.append(num)\n    \n    return unique_nums\n```"
  },
  {
    "id":373,
    "response":"```python\ndef unique_product(lst):\n    \"\"\"\n    Calculate the product of unique numbers in a list.\n    \n    Args:\n        lst: A list of numbers (integers or floats)\n    \n    Returns:\n        The product of all unique numbers in the list.\n        If there are no unique numbers, returns 1 (multiplicative identity).\n    \"\"\"\n    if not lst:\n        return 1\n    \n    # Convert list to set to get unique numbers\n    unique_numbers = set(lst)\n    \n    # Calculate the product of unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    \n    return product\n```"
  },
  {
    "id":374,
    "response":"```python\ndef surfacearea_cylinder(radius, height):\n    \"\"\"\n    Calculate the surface area of a cylinder.\n    \n    Args:\n        radius (float): The radius of the cylinder's base.\n        height (float): The height of the cylinder.\n    \n    Returns:\n        float: The surface area of the cylinder.\n    \"\"\"\n    import math\n    return 2 * math.pi * radius * (radius + height)\n```"
  },
  {
    "id":375,
    "response":"```python\ndef count_no(n, n2, n3, n4):\n    \"\"\"\n    একটি অনুক্রমের মধ্যে n-তম সংখ্যা খুঁজে বের করে।\n    প্রদত্ত সংখ্যাগুলি হল অনুক্রমের প্রথম চারটি সংখ্যা।\n    \n    যদি n এর মান 1 হয়, তবে প্রথম সংখ্যা রেটার হবে।\n    যদি n এর মান 2 হয়, তবে দ্বিতীয় সংখ্যা রেটার হবে।\n    এবং এভাবে চলবে।\n    \n    Parameters:\n    n (int): অনুক্রমের কোন স্থানে সংখ্যা খুঁজবেন।\n    n2 (int): অনুক্রমের দ্বিতীয় সংখ্যা।\n    n3 (int): অনুক্রমের তৃতীয় সংখ্যা।\n    n4 (int): অনুক্রমের চতুর্থ সংখ্যা।\n    \n    Returns:\n    int: n-তম সংখ্যা।\n    \"\"\"\n    # যদি n এর মান 1 হয়, তবে প্রথম সংখ্যা রেটার হবে।\n    if n == 1:\n        return n\n    # যদি n"
  },
  {
    "id":376,
    "response":"```python\ndef is_Sub_Array(lst, lst2, n, n2):\n    \"\"\"\n    Check if lst2 is a subarray of lst.\n    \n    Args:\n        lst: The main list to search in.\n        lst2: The potential subarray.\n        n: Length of the main list.\n        n2: Length of the potential subarray.\n    \n    Returns:\n        True if lst2 is a subarray of lst, False otherwise.\n    \"\"\"\n    # If lst2 is longer than lst, it can't be a subarray\n    if n2 > n:\n        return False\n    \n    # If lst2 is empty, it's a subarray of any list\n    if n2 == 0:\n        return True\n    \n    # Check all possible starting positions in lst\n    for i in range(n - n2 + 1):\n        # Check if lst2 matches starting at position i\n        match = True\n        for j in range(n2):\n            if lst[i + j] != lst2[j]:\n                match = False\n                break\n        if match:\n            return True\n    \n    return False\n```"
  },
  {
    "id":377,
    "response":"```python\ndef last_Digit_Factorial(n):\n    \"\"\"\n    প্রদত্ত সংখ্যার ফ্যাক্টরিয়ালের শেষ অঙ্কটি খুঁজে পায়।\n    \n    প্রতি প্রায় স্বাভাবিক সংখ্যা n >= 5 এর জন্য, n! এর শেষ অঙ্ক হবে 0 কারণ 5 এবং 2 এর গুণফল দ্বারা স্বাভাবিকভাবে শূন্য তৈরি হয়।\n    তাই শুধুমাত্র n < 5 এর জন্য ক্যালকুলেশন করা হবে।\n    \n    Parameters:\n    n (int): ফ্যাক্টরিয়াল নেওয়ার সংখ্যা\n    \n    Returns:\n    int: ফ্যাক্টরিয়ালের শেষ অঙ্ক\n    \"\"\"\n    if n < 0:\n        return None  # নেগেটিভ সংখ্যা বিবেচনা করা হয় না\n    \n    if n >= 5:\n        return 0  # 5 এর বেশি হলে ফ্যাক্টরিয়ালের শেষ অঙ্ক হবে 0\n    \n    # n < 5 হলে ক্যালকুলেশন করা হবে\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    \n    return factorial % 10\n```"
  },
  {
    "id":378,
    "response":"```python\ndef interleave_lists(lst1, lst2, lst3):\n    \"\"\"\n    একই দৈর্ঘ্যের তিনটি তালিকা কে একত্রিত করে একটি নতুন তালিকা তৈরি করে।\n    \n    Args:\n        lst1, lst2, lst3: দৈর্ঘ্য সমান তিনটি তালিকা\n        \n    Returns:\n        একটি তালিকা যা তিনটি তালিকার উপাদানগুলি প্রতিটি স্থানে একত্রিত করে।\n    \"\"\"\n    result = []\n    for i in range(len(lst1)):\n        result.append(lst1[i])\n        result.append(lst2[i])\n        result.append(lst3[i])\n    return result\n```"
  },
  {
    "id":379,
    "response":"```python\ndef find_dissimilar(tup, tup2):\n    \"\"\"\n    Find elements that are present in one tuple but not in the other.\n    \n    Args:\n        tup: First tuple\n        tup2: Second tuple\n    \n    Returns:\n        A tuple containing elements that are in one tuple but not in the other\n    \"\"\"\n    set1 = set(tup)\n    set2 = set(tup2)\n    \n    # Find elements in first tuple but not in second\n    in_first_only = set1 - set2\n    \n    # Find elements in second tuple but not in first\n    in_second_only = set2 - set1\n    \n    # Combine both sets\n    dissimilar = in_first_only.union(in_second_only)\n    \n    return tuple(dissimilar)\n```"
  },
  {
    "id":380,
    "response":"```python\ndef extract_even(tup):\n    \"\"\"\n    Extracts all even numbers from a nested mixed tuple.\n    \n    Args:\n        tup: A nested mixed tuple containing integers and other tuples\n        \n    Returns:\n        A tuple containing all even numbers found in the nested structure\n    \"\"\"\n    result = []\n    \n    def traverse(item):\n        if isinstance(item, tuple):\n            for element in item:\n                traverse(element)\n        elif isinstance(item, int):\n            if item % 2 == 0:\n                result.append(item)\n    \n    traverse(tup)\n    return tuple(result)\n```"
  },
  {
    "id":381,
    "response":"```python\ndef surface_area(n, n2):\n    \"\"\"\n    Calculate the surface area of a square pyramid.\n    \n    Parameters:\n    n (float): The side length of the square base.\n    n2 (float): The height of the pyramid.\n    \n    Returns:\n    float: The total surface area of the square pyramid.\n    \"\"\"\n    # Calculate the area of the base\n    base_area = n * n\n    \n    # Calculate the slant height of the pyramid\n    # Slant height = sqrt(height^2 + (half base side)^2)\n    slant_height = (n2**2 + (n\/2)**2)**0.5\n    \n    # Calculate the area of one triangular face\n    triangle_area = (n * slant_height) \/ 2\n    \n    # Total lateral surface area (4 triangular faces)\n    lateral_area = 4 * triangle_area\n    \n    # Total surface area = base area + lateral area\n    total_surface_area = base_area + lateral_area\n    \n    return total_surface_area\n```"
  },
  {
    "id":382,
    "response":"```python\ndef my_dict(dct):\n    \"\"\"\n    Check if a dictionary is empty.\n    \n    Args:\n        dct: The dictionary to check\n        \n    Returns:\n        bool: True if the dictionary is empty, False otherwise\n    \"\"\"\n    return len(dct) == 0\n```"
  },
  {
    "id":383,
    "response":"```python\ndef catalan_number(n):\n    \"\"\"\n    Calculate the nth Catalan number.\n    \n    The nth Catalan number is given by the formula:\n    C(n) = (2n)! \/ ((n+1)! * n!)\n    \n    Alternatively, it can be computed using the recurrence relation:\n    C(0) = 1, C(n) = sum(C(i) * C(n-1-i)) for i from 0 to n-1\n    \n    Args:\n        n (int): The index of the Catalan number to compute\n        \n    Returns:\n        int: The nth Catalan number\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    # Using the formula: C(n) = (2n)! \/ ((n+1)! * n!)\n    # This can be computed more efficiently using the recurrence relation\n    # or by using the direct formula with binomial coefficients\n    \n    # Using the direct formula with binomial coefficient\n    # C(n) = C(2n, n) \/ (n + 1)\n    \n    # Calculate binomial coefficient C(2n, n)\n    def binomial_coefficient(n, r):\n        if r > n or r < 0:\n            return 0\n        if r == 0 or r == n:\n            return 1\n        \n        # Use the property C(n,r) = C(n, n-r) to minimize calculations\n        r = min(r, n - r)\n        \n        result = 1\n        for i in range(r):\n            result = result * (n - i) \/\/ (i + 1)\n        \n        return result\n    \n    # Calculate C(2n, n) \/ (n + 1)\n    return binomial_coefficient(2 * n, n) \/\/ (n + 1)\n```"
  },
  {
    "id":384,
    "response":"```python\nimport re\n\ndef find_adverbs(s):\n    \"\"\"\n    রেজেক্স ব্যবহার করে একটি বাক্যে সমস্ত বিশেষণ এবং তাদের অবস্থান খুঁজে পেয়ে ফেরত দেয়।\n    \n    বিশেষণ হলো যে কোনো শব্দ যা সাধারণত বিশেষ করে কাজ করে বা অবস্থান নির্দেশ করে।\n    এখানে বিশেষণ হিসাবে নিচের ধরনের শব্দগুলি বিবেচিত হবে:\n    - সাধারণ বিশেষণ (যেমন: খুব, অত্যন্ত, বেশ, অতি, খুবই, খুব কম, অতি কম, সবুজ, সুস্থ)\n    - এর মধ্যে অনেক শব্দ বাক্যে বিশেষ করে ব্যবহার হয়।\n    \n    এই ফাংশনটি সহজ বিশেষণ খুঁজে পাবে যেমন: খুব, অত্যন্ত, খুবই, অতি, অতি কম, বেশ, সু, সুস্থ, সবুজ, অতি সু, খুব সু, খুব"
  },
  {
    "id":385,
    "response":"```python\ndef expensive_items(lst, n):\n    \"\"\"\n    একটি ডেটাসেট থেকে n ব্যয়বহুল মূল্যের আইটেমগুলি খুঁজে বের করে।\n    \n    প্যারামিটার:\n    lst: একটি লিস্ট যেখানে প্রতিটি আইটেমের মূল্য রয়েছে\n    n: ব্যয়বহুল মূল্যের আইটেমগুলির সংখ্যা\n    \n    রিটার্ন:\n    ব্যয়বহুল মূল্যের n টি আইটেমের লিস্ট (অবিনাম সাজানো হবে)\n    \"\"\"\n    if not lst or n <= 0:\n        return []\n    \n    # মূল্যের অনুসারে সাজানো এবং শেষের n টি আইটেম বাদ দেওয়া\n    sorted_items = sorted(lst, reverse=True)\n    return sorted_items[:n]\n```"
  },
  {
    "id":386,
    "response":"```python\ndef split_arr(lst, n, n2):\n    \"\"\"\n    একটি অ্যারেটি বিভক্ত করে প্রথম অংশটি শেষে যোগ করে।\n    \n    Parameters:\n    lst: অ্যারে\n    n: প্রথম অংশের দৈর্ঘ্য\n    n2: দ্বিতীয় অংশের দৈর্ঘ্য (অথবা শেষের অংশের দৈর্ঘ্য)\n    \n    Returns:\n    প্রথম অংশটি শেষে যোগ করা অ্যারে\n    \"\"\"\n    if n <= 0 or n2 <= 0:\n        return lst\n    \n    # অ্যারেটি বিভক্ত করা\n    first_part = lst[:n]\n    second_part = lst[n:]\n    \n    # প্রথম অংশটি শেষে যোগ করা\n    result = second_part + first_part\n    \n    return result\n```"
  },
  {
    "id":387,
    "response":"```python\ndef list_tuple(lst):\n    \"\"\"\n    একটি তালিকাকে একটি টিপলে রূপান্তর করে।\n    \n    প্যারামিটার:\n    lst (list): রূপান্তরের জন্য তালিকা।\n    \n    রিটার্ন:\n    tuple: তালিকার রূপান্তরিত টিপল।\n    \"\"\"\n    return tuple(lst)\n```"
  },
  {
    "id":388,
    "response":"```python\ndef big_diff(lst):\n    \"\"\"\n    একটি প্রদত্ত অ্যারেতে বৃহত্তম এবং ক্ষুদ্রতম মানের মধ্যে পার্থক্য খুঁজে পায়।\n    \n    প্যারামিটার:\n    lst (list): একটি সংখ্যা বিশিষ্ট অ্যারে।\n    \n    রিটার্ন:\n    int: বৃহত্তম এবং ক্ষুদ্রতম মানের মধ্যে পার্থক্য।\n    \"\"\"\n    if not lst:\n        return 0\n    \n    return max(lst) - min(lst)\n```"
  },
  {
    "id":389,
    "response":"```python\ndef perfect_squares(n, n2):\n    \"\"\"\n    দুটি প্রদত্ত সংখ্যার মধ্যে পারফেক্ট স্কোয়ার (perfect square) খুঁজে বের করে।\n    \n    পারফেক্ট স্কোয়ার: যে সংখ্যা কোনো পূর্ণ সংখ্যার বর্গ হয়।\n    \n    Parameters:\n    n (int): প্রথম সংখ্যা\n    n2 (int): দ্বিতীয় সংখ্যা\n    \n    Returns:\n    list: দুটি সংখ্যার মধ্যে থাকা পারফেক্ট স্কোয়ারগুলির একটি তালিকা\n    \"\"\"\n    # সংখ্যাগুলি নির্দিষ্ট করা হল\n    start = min(n, n2)\n    end = max(n, n2)\n    \n    perfect_squares_list = []\n    \n    # প্রতিটি সংখ্যা বর্গ করে দেখা হবে কিনা\n    for i in range(start, end + 1):\n        # যদি সংখ্যাটি কোনো পূর্ণ সংখ্যার বর্গ হয় তবে এটি পারফেক্ট স্কোয়ার\n        sqrt_i = int(i ** 0.5)\n        if sqrt_i * sqrt_i == i:\n            perfect_squares_list.append(i)\n    \n    return perfect_squares_list\n```"
  },
  {
    "id":390,
    "response":"```python\ndef polar_rect(r, theta):\n    \"\"\"\n    পোলার কোঅর্ডিনেট (r, theta) কে আয়তক্ষেত্রাকার কোঅর্ডিনেট (x, y) রূপান্তর করে।\n    \n    প্যারামিটার:\n    r: দূরত্ব (radius)\n    theta: কোণ (রেডিয়ান বা ডিগ্রি হতে রেডিয়ানে রূপান্তর করা হবে)\n    \n    রিটার্ন:\n    একটি ক্রম যা (x, y) কে ফেরত দেয়\n    \"\"\"\n    import math\n    \n    # যদি কোণ ডিগ্রি হয়, তবে রেডিয়ানে রূপান্তর করা হবে\n    if isinstance(theta, int) or isinstance(theta, float):\n        theta_rad = math.radians(theta)\n    else:\n        theta_rad = theta\n    \n    x = r * math.cos(theta_rad)\n    y = r * math.sin(theta_rad)\n    \n    return (x, y)\n```"
  },
  {
    "id":391,
    "response":"```python\ndef swap_List(lst):\n    \"\"\"\n    একটি তালিকার প্রথম এবং শেষ উপাদান বিনিময় করে।\n    \n    Parameters:\n    lst (list): তালিকা যার প্রথম এবং শেষ উপাদান বিনিময় করা হবে।\n    \n    Returns:\n    list: প্রথম এবং শেষ উপাদান বিনিময় করা তালিকা।\n    \"\"\"\n    if len(lst) <= 1:\n        return lst[:]\n    \n    # প্রথম এবং শেষ উপাদান বিনিময় করা\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst[:]\n```"
  },
  {
    "id":392,
    "response":"```python\ndef sum_of_product(n):\n    \"\"\"\n    দ্বিপদী সহগগুলির উৎপাদনের যোগফল খুঁজে বের করে।\n    দ্বিপদী সহগগুলির যোগফল হল দ্বিপদী সূত্রের প্রতিটি সহগের যোগফল।\n    (a + b)^n এর সহগগুলির যোগফল হল 2^n।\n    \n    Parameters:\n    n (int): দ্বিপদী সূত্রের ঘাত\n    \n    Returns:\n    int: সহগগুলির যোগফল\n    \"\"\"\n    return 2 ** n\n```"
  },
  {
    "id":393,
    "response":"```python\ndef removezero_ip(s):\n    \"\"\"\n    একটি আইপি ঠিকানা থেকে শীর্ষস্থানীয় শূন্যগুলি সরিয়ে ফেলে।\n    \n    Args:\n        s (str): আইপি ঠিকানা যা শূন্যগুলি সরিয়ে ফেলা হবে।\n    \n    Returns:\n        str: শূন্যগুলি সরিয়ে ফেলা আইপি ঠিকানা।\n    \"\"\"\n    parts = s.split('.')\n    result = []\n    \n    for part in parts:\n        # শূন্যগুলি সরিয়ে ফেলে এবং শূন্য হলে অবস্থান হবে না\n        cleaned_part = part.lstrip('0')\n        if cleaned_part == '':\n            cleaned_part = '0'\n        result.append(cleaned_part)\n    \n    return '.'.join(result)\n```"
  },
  {
    "id":394,
    "response":"```python\ndef diff_even_odd(lst):\n    \"\"\"\n    Find the difference between the first even number and the first odd number in a list.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        int: Difference between first even and first odd number, or None if not found\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0:\n            if first_even is None:\n                first_even = num\n        else:\n            if first_odd is None:\n                first_odd = num\n    \n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return None\n```"
  },
  {
    "id":395,
    "response":"```python\ndef min_swaps(s, s2):\n    \"\"\"\n    Calculate the minimum number of swaps needed to convert binary string s to s2.\n    \n    Args:\n        s (str): Original binary string\n        s2 (str): Target binary string\n    \n    Returns:\n        int: Minimum number of swaps required\n    \"\"\"\n    # Count the number of positions where s and s2 differ\n    diff_count = 0\n    for i in range(len(s)):\n        if s[i] != s2[i]:\n            diff_count += 1\n    \n    # If no differences, no swaps needed\n    if diff_count == 0:\n        return 0\n    \n    # For binary strings, each differing pair can be fixed with one swap\n    # The minimum swaps needed is half the number of differing positions\n    # (since each swap fixes two positions)\n    return diff_count \/\/ 2\n```"
  },
  {
    "id":396,
    "response":"```python\ndef tuple_size(tup):\n    \"\"\"\n    প্রদত্ত টিপলের আকার (সদস্য সংখ্যা) খুঁজে বের করে।\n    \n    Args:\n        tup: একটি টিপল\n        \n    Returns:\n        int: টিপলের আকার (সদস্য সংখ্যা)\n    \"\"\"\n    return len(tup)\n```"
  },
  {
    "id":397,
    "response":"```python\ndef find_kth(lst, lst2, k):\n    \"\"\"\n    Find the k-th element from two sorted arrays.\n    \n    Args:\n        lst: First sorted list\n        lst2: Second sorted list\n        k: The k-th position (1-indexed) to find\n    \n    Returns:\n        The k-th element in the merged sorted sequence\n    \"\"\"\n    # Ensure k is valid\n    if k <= 0:\n        raise ValueError(\"k must be a positive integer\")\n    \n    # Merge the two sorted arrays using two pointers\n    i, j = 0, 0\n    count = 0\n    \n    while i < len(lst) and j < len(lst2):\n        if lst[i] <= lst2[j]:\n            if count == k - 1:\n                return lst[i]\n            i += 1\n            count += 1\n        else:\n            if count == k - 1:\n                return lst2[j]\n            j += 1\n            count += 1\n    \n    # If we've reached the end of one array, get the remaining elements\n    while i < len(lst):\n        if count == k - 1:\n            return lst[i]\n        i += 1\n        count += 1\n    \n    while j < len(lst2):\n        if count == k - 1:\n            return lst2[j]\n        j += 1\n        count += 1\n    \n    # This should never happen if k is valid\n    raise IndexError(\"k is out of bounds\")\n```"
  },
  {
    "id":398,
    "response":"```python\ndef armstrong_number(n):\n    \"\"\"\n    Check if a given number is an Armstrong number.\n    \n    An Armstrong number (also known as a narcissistic number) is a number \n    that is equal to the sum of its own digits each raised to the power of \n    the total number of digits.\n    \n    Args:\n        n (int): The number to check\n        \n    Returns:\n        bool: True if the number is an Armstrong number, False otherwise\n    \"\"\"\n    # Convert number to string to easily access digits\n    str_n = str(n)\n    num_digits = len(str_n)\n    \n    # Calculate sum of each digit raised to the power of total digits\n    digit_sum = sum(int(digit) ** num_digits for digit in str_n)\n    \n    # Check if sum equals the original number\n    return digit_sum == n\n```"
  },
  {
    "id":399,
    "response":"```python\ndef sum_average(n):\n    \"\"\"\n    Calculate the sum and average of the first n natural numbers.\n    \n    Args:\n        n (int): The number of natural numbers to consider (1, 2, 3, ..., n)\n    \n    Returns:\n        tuple: (sum, average)\n    \"\"\"\n    # Sum of first n natural numbers: n * (n + 1) \/ 2\n    total_sum = n * (n + 1) \/\/ 2\n    \n    # Average = sum \/ n\n    average = total_sum \/ n\n    \n    return total_sum, average\n```"
  },
  {
    "id":400,
    "response":"```python\ndef is_Even(n):\n    \"\"\"\n    বিটওয়াইস অপারেটর ব্যবহার করে প্রদত্ত সংখ্যাটি জোড়া কিনা তা পরীক্ষা করে।\n    \n    জোড় সংখ্যা হলে সংখ্যার সবথেকে ডান বিট শূন্য (0) হয়।\n    সেটি চেক করার জন্য আমরা একটি বিটওয়াইস এ্যান্ড অপারেটর (&) ব্যবহার করি।\n    \n    যদি n & 1 == 0 হয় তবে সংখ্যাটি জোড়।\n    \n    Parameters:\n    n (int): পরীক্ষার সংখ্যা\n    \n    Returns:\n    bool: সংখ্যা জোড় হলে True, না হলে False\n    \"\"\"\n    return (n & 1) == 0\n```"
  }
]