[
  {
    "id":1,
    "response":"```python\ndef max_chain_length(lst, n):\n    \"\"\"\n    Find the length of the longest chain that can be formed from pairs in lst.\n    \n    Args:\n        lst: List of tuples (or pairs) representing the pairs.\n        n: Number of pairs to consider (optional, if not used, can be ignored).\n    \n    Returns:\n        Integer representing the length of the longest chain.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    # Sort pairs by their first element\n    sorted_pairs = sorted(lst, key=lambda x: x[0])\n    \n    # Use dynamic programming to find the longest chain\n    # dp[i] represents the length of the longest chain ending at pair i\n    dp = [1] * len(sorted_pairs)\n    \n    for i in range(1, len(sorted_pairs)):\n        for j in range(i):\n            # If current pair can follow the previous pair (second element of j >= first element of i)\n            if sorted_pairs[j][1] <= sorted_pairs[i][0]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp) if dp else 0\n```"
  },
  {
    "id":2,
    "response":"```python\ndef first_repeated_char(s):\n    \"\"\"\n    Find the first repeated character in a string.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: The first character that appears more than once, or None if no repetition exists\n    \"\"\"\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None\n```"
  },
  {
    "id":3,
    "response":"```python\ndef get_ludic(n):\n    \"\"\"\n    Return a list of ludic numbers less than or equal to n.\n    \n    Ludic numbers are generated by a sieve-like process:\n    1. Start with the sequence of natural numbers: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...\n    2. Remove every second number (index 1, 3, 5, ...), leaving: 1, 3, 5, 7, 9, 11, ...\n    3. Remove every third number (index 2, 5, 8, ...), leaving: 1, 3, 7, 9, 13, 15, ...\n    4. Continue this process: at step k, remove every k-th number from the current list.\n    \n    This function returns all ludic numbers <= n.\n    \"\"\"\n    if n < 1:\n        return []\n    \n    # Start with the sequence of natural numbers\n    ludic = list(range(1, n + 1))\n    \n    # Generate ludic numbers using the ludic sieve process\n    i = 0\n    while i < len(ludic):\n        if i == 0:\n            # First step: remove every second number (index 1, 3, 5, ...)\n            # We remove elements at indices 1, 3, 5, ...\n            j = 1\n            while j < len(ludic):\n                ludic.pop(j)\n                j += 2\n        else:\n            # At step i, remove every (i+1)-th number\n            step = i + 1\n            j = step - 1\n            while j < len(ludic):\n                ludic.pop(j)\n                j += step\n        \n        # If no more numbers to remove, break\n        if len(ludic) <= i:\n            break\n            \n        i += 1\n    \n    return ludic\n```"
  },
  {
    "id":4,
    "response":"```python\ndef reverse_words(s):\n    \"\"\"\n    Reverse the words in a string, keeping the words themselves intact.\n    \n    Args:\n        s (str): Input string with words separated by spaces\n        \n    Returns:\n        str: String with words in reverse order\n    \"\"\"\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words\n```"
  },
  {
    "id":5,
    "response":"```python\ndef prime_num(n):\n    \"\"\"\n    প্রদত্ত পূর্ণসংখ্যা একটি মৌলিক সংখ্যা কিনা তা পরীক্ষা করে।\n    \n    প্যারামিটার:\n    n (int): পরীক্ষা করা হবে একটি পূর্ণসংখ্যা\n    \n    রিটার্ন:\n    bool: যদি n মৌলিক হয় তবে True, নাহলে False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    # মৌলিক সংখ্যা হিসাবে পরীক্ষা করার জন্য সীমা হবে √n\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    \n    return True\n```"
  },
  {
    "id":6,
    "response":"```python\ndef radian_degree(n):\n    \"\"\"\n    রেডিয়ান কে ডিগ্রিতে রূপান্তর করে।\n    \n    প্যারামিটার:\n    n (float): রেডিয়ানের মান\n    \n    রিটার্ন:\n    float: ডিগ্রিতে রূপান্তরিত মান\n    \"\"\"\n    return n * (180 \/ 3.141592653589793)\n```"
  },
  {
    "id":7,
    "response":"```python\nimport re\n\ndef find_literals(s, s2):\n    \"\"\"\n    রেজেক্স ব্যবহার করে মূল স্ট্রিং-এর মধ্যে প্যাটার্ন অনুসন্ধান করে অবস্থান খুঁজে বের করে।\n    \n    Parameters:\n    s (str): মূল স্ট্রিং\n    s2 (str): অনুসন্ধানের প্যাটার্ন স্ট্রিং\n    \n    Returns:\n    list: প্যাটার্নের প্রতিটি অবস্থানের সূচী (ইনডেক্স) এর একটি তালিকা।\n          অবস্থান অনুসারে সাজানো হয়।\n    \"\"\"\n    pattern = re.escape(s2)  # প্যাটার্নে কোন অবস্থান বিশেষ সিম্বল থাকলে সেগুলি স্কিপ করে\n    matches = []\n    start = 0\n    \n    while True:\n        match = re.search(pattern, s, start)\n        if match is None:\n            break\n        matches.append(match.start())\n        start = match.end()\n    \n    return matches\n```"
  },
  {
    "id":8,
    "response":"```python\ndef bell_number(n):\n    \"\"\"\n    Calculate the nth Bell number.\n    \n    The Bell number B(n) counts the number of ways to partition a set of n elements.\n    \n    Args:\n        n (int): The index of the Bell number to compute (non-negative integer)\n    \n    Returns:\n        int: The nth Bell number\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    # Create a triangle to compute Bell numbers using dynamic programming\n    # bell[i][j] represents the number of ways to partition i elements into j non-empty subsets\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case: there's one way to partition 0 elements (empty set)\n    bell[0][0] = 1\n    \n    # Fill the bell table\n    for i in range(1, n + 1):\n        # Each element can be added to any of the existing subsets\n        # or form a new subset\n        for j in range(i + 1):\n            if j == 0:\n                bell[i][j] = 0\n            elif j == 1:\n                bell[i][j] = 1\n            else:\n                # Bell number recurrence: sum of Stirling numbers of the second kind\n                bell[i][j] = bell[i-1][j-1] + bell[i-1][j]\n    \n    # The nth Bell number is the sum of all entries in the nth row\n    result = 0\n    for j in range(n + 1):\n        result += bell[n][j]\n    \n    return result\n```"
  },
  {
    "id":9,
    "response":"```python\ndef floor_Min(n, n2, n3):\n    \"\"\"\n    প্রদত্ত তিনটি সংখ্যার মধ্যে সর্বনিম্ন মান খুঁজে পায়।\n    \n    Parameters:\n    n, n2, n3: পর্যায়ক্রমিক ফাংশনের মানগুলি (সংখ্যা)\n    \n    Returns:\n    সর্বনিম্ন মান\n    \"\"\"\n    return min(n, n2, n3)\n```"
  },
  {
    "id":10,
    "response":"```python\ndef remove_kth_element(lst, n):\n    \"\"\"\n    Remove the n-th element (1-indexed) from the list and return the modified list.\n    \n    Args:\n        lst: List from which to remove the n-th element\n        n: The position of the element to remove (1-indexed)\n    \n    Returns:\n        List with the n-th element removed\n    \n    Raises:\n        IndexError: If n is out of bounds (less than 1 or greater than len(lst))\n    \"\"\"\n    if n < 1 or n > len(lst):\n        raise IndexError(\"n is out of bounds\")\n    \n    # Create a new list without the n-th element (1-indexed)\n    # So we remove index n-1\n    return lst[:n-1] + lst[n:]\n```"
  },
  {
    "id":11,
    "response":"```python\ndef max_of_nth(lst, n):\n    \"\"\"\n    প্রদত্ত টিপল তালিকা থেকে n-তম কলামের সর্বোচ্চ সংখ্যা খুঁজে বের করে।\n    \n    প্যারামিটার:\n    lst: একটি টিপল তালিকা, যার প্রতিটি উপাদান একটি কলামের সংখ্যা হবে\n    n: n-তম কলামের নম্বর (1 থেকে শুরু করে)\n    \n    রিটার্ন:\n    n-তম কলামের সর্বোচ্চ সংখ্যা। যদি n-তম কলাম নেই তবে None রিটার্ন করবে।\n    \"\"\"\n    if not lst or n <= 0:\n        return None\n    \n    # n-তম কলামের সংখ্যা খুঁজে বের করা হবে (1 থেকে শুরু করে)\n    # তাই ইনডেক্স হবে n-1\n    nth_column = [item[n-1] for item in lst if n-1 < len(item)]\n    \n    if not nth_column:\n        return None\n    \n    return max(nth_column)\n```"
  },
  {
    "id":12,
    "response":"```python\ndef merge(lst):\n    \"\"\"\n    প্রথম এবং শেষ উপাদানগুলিকে আলাদাভাবে তালিকার তালিকায় একত্রিত করে।\n    \n    Args:\n        lst: একটি তালিকা\n        \n    Returns:\n        প্রথম এবং শেষ উপাদানগুলি একত্রিত করে তালিকা\n    \"\"\"\n    if not lst:\n        return []\n    \n    if len(lst) == 1:\n        return [lst[0]]\n    \n    return [lst[0]] + [lst[-1]]\n```"
  },
  {
    "id":13,
    "response":"```python\ndef maximum_value(lst):\n    \"\"\"\n    Find the maximum value among all tuples in a list of tuples.\n    \n    Args:\n        lst: A list of tuples where each tuple contains numeric values.\n    \n    Returns:\n        The maximum value found across all tuples in the list.\n    \n    Raises:\n        ValueError: If the input list is empty or contains no numeric values.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list is empty\")\n    \n    max_val = None\n    for tup in lst:\n        if not isinstance(tup, tuple):\n            raise ValueError(f\"Expected tuple, got {type(tup)}\")\n        for item in tup:\n            if not isinstance(item, (int, float)):\n                raise ValueError(f\"Expected numeric value, got {type(item)}\")\n            if max_val is None or item > max_val:\n                max_val = item\n    \n    return max_val\n```"
  },
  {
    "id":14,
    "response":"```python\ndef cumulative_sum(lst):\n    \"\"\"\n    Return a list containing the cumulative sum of elements in the input list.\n    \n    Args:\n        lst: A list of numbers\n        \n    Returns:\n        A list where each element is the sum of all previous elements including itself\n    \"\"\"\n    if not lst:\n        return []\n    \n    result = []\n    total = 0\n    for num in lst:\n        total += num\n        result.append(total)\n    \n    return result\n```"
  },
  {
    "id":15,
    "response":"```python\ndef average_tuple(tup):\n    \"\"\"\n    Calculate the average of all numbers in a tuple of tuples.\n    \n    Args:\n        tup: A tuple of tuples containing numbers.\n    \n    Returns:\n        float: The average of all numbers in the nested tuples.\n    \n    Raises:\n        ValueError: If the tuple is empty or contains no numbers.\n    \"\"\"\n    if not tup:\n        raise ValueError(\"Tuple is empty\")\n    \n    total = 0\n    count = 0\n    \n    for inner_tuple in tup:\n        for item in inner_tuple:\n            if isinstance(item, (int, float)):\n                total += item\n                count += 1\n    \n    if count == 0:\n        raise ValueError(\"No numbers found in the tuple\")\n    \n    return total \/ count\n```"
  },
  {
    "id":16,
    "response":"```python\ndef tuple_modulo(tup, tup2):\n    \"\"\"\n    দুটি টুপলের উপাদানগুলির মডুলো সম্পাদন করে একটি নতুন টুপল রিটার্ন করে।\n    \n    Parameters:\n    tup: প্রথম টুপল\n    tup2: দ্বিতীয় টুপল (মডুলো করার জন্য)\n    \n    Returns:\n    মডুলো সম্পাদনের পর তৈরি করা টুপল\n    \"\"\"\n    if len(tup) != len(tup2):\n        raise ValueError(\"টুপলের দৈর্ঘ্য সমান হতে হবে\")\n    \n    result = ()\n    for a, b in zip(tup, tup2):\n        if b == 0:\n            raise ZeroDivisionError(\"মডুলো করার জন্য শূন্য হতে পারবে না\")\n        result += (a % b,)\n    \n    return result\n```"
  },
  {
    "id":17,
    "response":"```python\ndef min_Jumps(n, n2, n3):\n    \"\"\"\n    Calculate the minimum number of jumps required to reach a point (d, 0) \n    from the origin (0, 0) in a 2D plane, where each jump has a fixed length.\n    \n    Parameters:\n    n (int): The target distance d in the x-direction.\n    n2 (int): The length of each jump in the x-direction.\n    n3 (int): The length of each jump in the y-direction (assumed to be 0 for this problem).\n    \n    Returns:\n    int: Minimum number of jumps required to reach (d, 0).\n    \"\"\"\n    # Since we need to reach (d, 0), and y-coordinate must remain 0,\n    # we only consider jumps in the x-direction.\n    # If n2 is 0, we cannot make any valid jumps.\n    if n2 == 0:\n        return float('inf')  # Impossible to reach if jump length is 0\n    \n    # Calculate minimum jumps needed to cover distance n in x-direction\n    # with jump length n2\n    jumps = (n + n2 - 1) \/\/ n2  # Ceiling division\n    \n    return jumps\n```"
  },
  {
    "id":18,
    "response":"```python\ndef div_list(lst, lst2):\n    \"\"\"\n    দুটি তালিকা ভাগ করে ফেরত দেয় যেখানে প্রথম তালিকার প্রতিটি উপাদান দ্বিতীয় তালিকার প্রতিটি উপাদানের সাথে ভাগ করা হয়।\n    এটি ল্যাম্বদা ফাংশন এবং মানচিত্র (map) ব্যবহার করে।\n    \n    Parameters:\n    lst: প্রথম তালিকা (দুটি উপাদানের জন্য ভাগের জন্য প্রয়োজন)\n    lst2: দ্বিতীয় তালিকা (ভাগের জন্য প্রয়োজন)\n    \n    Returns:\n    একটি তালিকা যেখানে প্রতিটি জোড়া উপাদানের ভাগফল রয়েছে।\n    \"\"\"\n    return list(map(lambda x, y: x \/ y, lst, lst2))\n```"
  },
  {
    "id":19,
    "response":"```python\ndef move_num(s):\n    \"\"\"\n    একটি স্ট্রিংয়ে সংখ্যাগুলোকে স্থানান্তর করে ফেরত দেয়।\n    যদি স্ট্রিংয়ে সংখ্যা থাকে, তবে সেগুলোকে স্থানান্তর করে ফেরত দেয়।\n    \n    Args:\n        s (str): সংখ্যা বিশিষ্ট স্ট্রিং\n        \n    Returns:\n        str: সংখ্যাগুলো স্থানান্তরিত স্ট্রিং\n    \"\"\"\n    # স্ট্রিংয়ে সংখ্যা স্থানান্তর করা হয়\n    result = \"\"\n    for char in s:\n        if char.isdigit():\n            result += char\n    return result\n```"
  },
  {
    "id":20,
    "response":"```python\ndef largest_subset(lst, n):\n    \"\"\"\n    Find the largest subset of pairs where each pair is divisible.\n    \n    Args:\n        lst: List of integers\n        n: Integer representing the target value or pair constraint\n    \n    Returns:\n        Integer representing the size of the largest subset where each pair is divisible\n    \"\"\"\n    if not lst or n <= 0:\n        return 0\n    \n    # Create a list of pairs (a, b) where a and b are divisible\n    pairs = []\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] % lst[j] == 0 or lst[j] % lst[i] == 0:\n                pairs.append((lst[i], lst[j]))\n    \n    # Return the count of such pairs\n    return len(pairs)\n```"
  },
  {
    "id":21,
    "response":"```python\ndef increment_numerics(lst, n):\n    \"\"\"\n    প্রদত্ত স্ট্রিং গুলিতে সংখ্যাগুলি k দ্বারা বৃদ্ধি করে।\n    \n    Args:\n        lst: স্ট্রিং এর একটি তালিকা\n        n: সংখ্যাগুলি বৃদ্ধি করার জন্য ব্যবহৃত মান\n    \n    Returns:\n        সংখ্যাগুলি k দ্বারা বৃদ্ধি পেয়ে গেছে স্ট্রিং গুলির একটি তালিকা\n    \"\"\"\n    result = []\n    for s in lst:\n        # স্ট্রিং থেকে সংখ্যা পেলে সেগুলি বৃদ্ধি করা হবে\n        new_string = \"\"\n        i = 0\n        while i < len(s):\n            char = s[i]\n            if char.isdigit():\n                # সংখ্যা পাওয়া গেলে তা বৃদ্ধি করা হবে\n                digit = int(char)\n                new_digit = digit + n\n                # যদি সংখ্যা প্রাপ্ত হয় তবে সেটি প্রদান করা হবে\n                new_string += str(new_digit)\n            else:\n                # অসংখ্যাগুলি অপরিবর্তিত রাখা হবে\n                new_string += char\n            i += 1\n        result.append(new_string)\n    return result\n```"
  },
  {
    "id":22,
    "response":"```python\ndef get_median(lst, lst2, n):\n    \"\"\"\n    Find the median of two sorted arrays of the same size.\n    \n    Args:\n        lst: First sorted array\n        lst2: Second sorted array\n        n: Size of each array\n    \n    Returns:\n        The median of the two arrays\n    \"\"\"\n    # Merge the two sorted arrays\n    merged = []\n    i = j = 0\n    \n    # Merge elements in sorted order\n    while i < n and j < n:\n        if lst[i] <= lst2[j]:\n            merged.append(lst[i])\n            i += 1\n        else:\n            merged.append(lst2[j])\n            j += 1\n    \n    # Add remaining elements from lst\n    while i < n:\n        merged.append(lst[i])\n        i += 1\n    \n    # Add remaining elements from lst2\n    while j < n:\n        merged.append(lst2[j])\n        j += 1\n    \n    # Find median\n    if n % 2 == 1:\n        # Odd length: return middle element\n        return merged[n]\n    else:\n        # Even length: return average of two middle elements\n        mid1 = merged[n \/\/ 2 - 1]\n        mid2 = merged[n \/\/ 2]\n        return (mid1 + mid2) \/ 2\n```"
  },
  {
    "id":23,
    "response":"```python\ndef nth_nums(lst, n):\n    \"\"\"\n    ল্যাম্বদা ফাংশন ব্যবহার করে তালিকার প্রতিটি উপাদানের n-তম শক্তি খুঁজে পায়।\n    \n    Args:\n        lst: একটি সংখ্যা বিশিষ্ট তালিকা\n        n: শক্তির মান (যেমন 2 হলে বর্গ করা হবে)\n    \n    Returns:\n        প্রতিটি উপাদানের n-তম শক্তি বলে একটি তালিকা\n    \"\"\"\n    return list(map(lambda x: x ** n, lst))\n```"
  },
  {
    "id":24,
    "response":"```python\ndef is_upper(s):\n    \"\"\"\n    Check if all characters in the string are uppercase.\n    \n    Args:\n        s (str): The input string to check.\n    \n    Returns:\n        bool: True if all characters are uppercase, False otherwise.\n    \"\"\"\n    return s.isupper()\n```"
  },
  {
    "id":25,
    "response":"```python\ndef swap_list(lst):\n    \"\"\"\n    প্রদত্ত তালিকার প্রথম এবং শেষ উপাদান বিনিময় করে।\n    \n    যদি তালিকা শূন্য হয় বা একটি উপাদান বিশিষ্ট হয়, তবে কিছু বিনিময় হবে না।\n    \n    Args:\n        lst: প্রদত্ত তালিকা\n        \n    Returns:\n        প্রথম এবং শেষ উপাদান বিনিময় করা তালিকা\n    \"\"\"\n    if len(lst) <= 1:\n        return lst[:]\n    \n    # প্রথম এবং শেষ উপাদান বিনিময় করা\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst[:]\n```"
  },
  {
    "id":26,
    "response":"```python\ndef triangle_area(n):\n    \"\"\"\n    Find the area of the largest triangle that can be inscribed in a semicircle of radius n.\n    \n    The largest triangle inscribed in a semicircle is a right triangle with the hypotenuse\n    as the diameter of the semicircle and the height from the right angle to the diameter\n    equal to the radius of the semicircle.\n    \n    For a semicircle of radius n, the maximum area of such a triangle is:\n    Area = (1\/2) * base * height = (1\/2) * (2n) * n = n^2\n    \n    Parameters:\n    n (float): radius of the semicircle\n    \n    Returns:\n    float: area of the largest inscribed triangle\n    \"\"\"\n    return n * n\n```"
  },
  {
    "id":27,
    "response":"```python\ndef find_first_missing(lst, n, n2):\n    \"\"\"\n    Find the smallest missing positive integer from the given list.\n    \n    Args:\n        lst: List of integers\n        n: First parameter (not used in logic)\n        n2: Second parameter (not used in logic)\n    \n    Returns:\n        The smallest positive integer that is missing from the list\n    \"\"\"\n    # We're looking for the smallest missing positive integer\n    # The smallest positive integer is 1, so we'll check from 1 onwards\n    # We can use the fact that if we have numbers 1 to k, then k+1 is missing\n    \n    # Convert list to set for O(1) lookup\n    num_set = set(lst)\n    \n    # Start checking from 1\n    missing = 1\n    while missing in num_set:\n        missing += 1\n    \n    return missing\n```"
  },
  {
    "id":28,
    "response":"```python\ndef replace_spaces(s):\n    \"\"\"\n    Replace all spaces in the given string with '%20'.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: String with spaces replaced by '%20'\n    \"\"\"\n    return s.replace(' ', '%20')\n```"
  },
  {
    "id":29,
    "response":"```python\ndef split(lst):\n    \"\"\"\n    একটি মিশ্র তালিকা থেকে সংখ্যা খুঁজে পাবে।\n    \n    এই ফাংশনটি মিশ্র তালিকার সব সংখ্যা বাদ দিয়ে অন্য সব কিছু ফেরত দেয়।\n    \n    Parameters:\n    lst (list): মিশ্র তালিকা যেখানে সংখ্যা এবং অন্য ধরনের ডাটা আছে।\n    \n    Returns:\n    list: সংখ্যা বাদ দেওয়া মিশ্র তালিকা।\n    \"\"\"\n    result = []\n    for item in lst:\n        if not isinstance(item, (int, float)):\n            result.append(item)\n    return result\n```"
  },
  {
    "id":30,
    "response":"```python\ndef get_coordinates(tup):\n    \"\"\"\n    প্রদত্ত সমন্বয় টুপলের সমস্ত সংলগ্ন সমন্বয়গুলি বের করে।\n    \n    এখানে সংলগ্ন সমন্বয় মানে হল টুপলের প্রতিটি সমন্বয়ের সাথে পরের সমন্বয়ের সংযোগ বা সংলগ্নতা।\n    যেমন (1,2,3) এর সংলগ্ন সমন্বয়গুলি হবে (1,2), (2,3)।\n    \n    Parameters:\n    tup (tuple): সমন্বয় টুপল\n    \n    Returns:\n    list: সংলগ্ন সমন্বয়গুলির একটি লিস্ট\n    \"\"\"\n    if len(tup) <= 1:\n        return []\n    \n    coordinates = []\n    for i in range(len(tup) - 1):\n        coordinates.append((tup[i], tup[i + 1]))\n    \n    return coordinates\n```"
  },
  {
    "id":31,
    "response":"```python\nimport re\n\ndef replace_spaces(s):\n    \"\"\"\n    Replace all whitespace characters in a string with an underscore.\n    \n    Args:\n        s (str): The input string\n        \n    Returns:\n        str: String with all whitespace replaced by underscore\n    \"\"\"\n    return re.sub(r'\\s+', '_', s)\n```"
  },
  {
    "id":32,
    "response":"```python\ndef move_zero(lst):\n    \"\"\"\n    একটি তালিকা দেয় এবং সব শূন্যকে তালিকার শেষে সরায়।\n    \n    Args:\n        lst: একটি পূর্ণসংখ্যা বা কোন ডাটা তালিকা\n        \n    Returns:\n        শূন্যগুলি শেষে সরানো তালিকা\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zeros_count = len(lst) - len(non_zero)\n    return non_zero + [0] * zeros_count\n```"
  },
  {
    "id":33,
    "response":"```python\ndef pair_OR_Sum(lst, n):\n    \"\"\"\n    Find the sum of XOR of all pairs in the list.\n    \n    Args:\n        lst: List of integers\n        n: Number of elements (optional, might be used for indexing)\n    \n    Returns:\n        Sum of XOR of all pairs in the list\n    \"\"\"\n    total_xor_sum = 0\n    length = len(lst)\n    \n    # Generate all possible pairs and compute XOR\n    for i in range(length):\n        for j in range(i + 1, length):\n            total_xor_sum += lst[i] ^ lst[j]\n    \n    return total_xor_sum\n```"
  },
  {
    "id":34,
    "response":"```python\ndef even_Power_Sum(n):\n    \"\"\"\n    Calculate the sum of the fourth power of the first n even numbers.\n    \n    Args:\n        n (int): The number of even numbers to consider.\n    \n    Returns:\n        int: The sum of the fourth powers of the first n even numbers.\n    \"\"\"\n    total = 0\n    for i in range(n):\n        even_number = 2 * i\n        total += even_number ** 4\n    return total\n```"
  },
  {
    "id":35,
    "response":"```python\nimport heapq\n\ndef heap_sort(lst):\n    \"\"\"\n    Sorts a list in ascending order using heap sort algorithm.\n    Converts the list into a min-heap and then extracts elements one by one.\n    \n    Args:\n        lst: List of comparable elements\n        \n    Returns:\n        A new list with elements sorted in ascending order\n    \"\"\"\n    # Create a min-heap from the list\n    heap = lst[:]\n    heapq.heapify(heap)\n    \n    # Extract elements one by one from the heap\n    sorted_list = []\n    while heap:\n        sorted_list.append(heapq.heappop(heap))\n    \n    return sorted_list\n```"
  },
  {
    "id":36,
    "response":"```python\ndef Check_Solution(n, n2, n3):\n    \"\"\"\n    Check if the roots of a quadrilateral equation are mutually exclusive (distinct).\n    \n    Args:\n        n: First root of the equation\n        n2: Second root of the equation\n        n3: Third root of the equation (Note: Quadratic equations have at most 2 roots)\n    \n    Returns:\n        bool: True if the roots are distinct (no two roots are equal), False otherwise\n    \"\"\"\n    # For a quadratic equation, there are at most 2 roots\n    # If there are 3 roots provided, they must include duplicates\n    # Check if any two roots are equal\n    \n    # If we have more than 2 roots, at least two must be equal\n    if len(set([n, n2, n3])) < 3:\n        return False\n    \n    # Check if any two roots are equal\n    if n == n2 or n == n3 or n2 == n3:\n        return False\n    \n    return True\n```"
  },
  {
    "id":37,
    "response":"```python\ndef noprofit_noloss(n, n2):\n    \"\"\"\n    Check if the given two values are equal, meaning there is no profit and no loss.\n    \n    Args:\n        n: The first value (e.g., cost price or initial amount)\n        n2: The second value (e.g., selling price or final amount)\n    \n    Returns:\n        bool: True if n equals n2 (no profit, no loss), False otherwise\n    \"\"\"\n    return n == n2\n```"
  },
  {
    "id":38,
    "response":"```python\ndef wind_chill(v, t):\n    \"\"\"\n    বায়ু শীতলতা সূচক (Wind Chill) গণনা করে।\n    \n    সূত্র: wc = 35.74 + 0.6215*t - 35.75*(v^0.16) + 0.4275*t*(v^0.16)\n    \n    প্যারামিটার:\n    v: বায়ুর বেগ (mph)\n    t: তাপমাত্রা (ফারেনহাইট)\n    \n    রিটার্ন:\n    বায়ু শীতলতা সূচক (ফারেনহাইট)\n    \"\"\"\n    if v < 3:\n        return t  # বায়ু বেগ 3 mph এর নিচে হলে শীতলতা সূচক হিসাব করা হয় না\n    \n    wind_chill_value = 35.74 + 0.6215 * t - 35.75 * (v ** 0.16) + 0.4275 * t * (v ** 0.16)\n    return wind_chill_value\n```"
  },
  {
    "id":39,
    "response":"```python\ndef sample_nam(lst):\n    \"\"\"\n    একটি নামের তালিকা থেকে ছোট অক্ষর দিয়ে শুরু হওয়া নামগুলি সরিয়ে দেয় এবং বাকি নামগুলির দৈর্ঘ্যের যোগফল দেয়।\n    \n    Args:\n        lst (list): নামের তালিকা\n        \n    Returns:\n        int: ছোট অক্ষর দিয়ে শুরু হয়নি নামগুলির দৈর্ঘ্যের যোগফল\n    \"\"\"\n    total_length = 0\n    for name in lst:\n        if name and name[0].isupper():\n            total_length += len(name)\n    return total_length\n```"
  },
  {
    "id":40,
    "response":"```python\ndef remove_parenthesis(s):\n    \"\"\"\n    Remove parentheses and their contents from a string.\n    \n    Args:\n        s (str): Input string that may contain parentheses.\n    \n    Returns:\n        str: String with all parentheses and their contents removed.\n    \"\"\"\n    result = []\n    i = 0\n    while i < len(s):\n        if s[i] == '(' or s[i] == ')':\n            # Skip parentheses and their contents\n            # Find matching closing or opening parenthesis\n            if s[i] == '(':\n                # Find matching closing parenthesis\n                depth = 1\n                j = i + 1\n                while j < len(s) and depth > 0:\n                    if s[j] == '(':\n                        depth += 1\n                    elif s[j] == ')':\n                        depth -= 1\n                    j += 1\n                # Skip from i to j-1 (inclusive)\n                i = j - 1\n            else:  # s[i] == ')'\n                # Skip this closing parenthesis\n                pass\n        else:\n            result.append(s[i])\n        i += 1\n    \n    return ''.join(result)\n```"
  },
  {
    "id":41,
    "response":"```python\ndef is_nonagonal(n):\n    \"\"\"\n    Check if a given number n is a nonagonal number.\n    \n    A nonagonal number is a figurate number that represents a nine-sided polygon.\n    The k-th nonagonal number is given by the formula: n = k(7k - 5) \/ 2\n    \n    Args:\n        n (int): The number to check\n        \n    Returns:\n        bool: True if n is a nonagonal number, False otherwise\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Solve the quadratic equation: k(7k - 5) \/ 2 = n\n    # 7k^2 - 5k - 2n = 0\n    # Using quadratic formula: k = (5 + sqrt(25 + 56n)) \/ 14\n    \n    discriminant = 25 + 56 * n\n    if discriminant < 0:\n        return False\n    \n    sqrt_discriminant = int(discriminant ** 0.5)\n    if sqrt_discriminant * sqrt_discriminant != discriminant:\n        return False\n    \n    # Check if k is a positive integer\n    k = (5 + sqrt_discriminant) \/ 14\n    return k > 0 and k == int(k)\n```"
  },
  {
    "id":42,
    "response":"```python\ndef remove_similar_row(lst):\n    \"\"\"\n    Remove duplicate rows from a list of tuples (matrix).\n    \n    Args:\n        lst: A list of tuples representing rows of a matrix.\n    \n    Returns:\n        A new list of tuples with duplicate rows removed.\n    \"\"\"\n    seen = set()\n    result = []\n    for row in lst:\n        row_tuple = tuple(row)\n        if row_tuple not in seen:\n            seen.add(row_tuple)\n            result.append(row_tuple)\n    return result\n```"
  },
  {
    "id":43,
    "response":"```python\ndef text_match_wordz_middle(s):\n    \"\"\"\n    Check if any word in the string has 'z' in the middle (not at the beginning or end).\n    \n    Args:\n        s (str): Input string to check\n        \n    Returns:\n        bool: True if there's a word with 'z' in the middle, False otherwise\n    \"\"\"\n    # Split the string into words\n    words = s.split()\n    \n    for word in words:\n        # Remove punctuation from the word\n        cleaned_word = ''.join(char for char in word if char.isalnum())\n        \n        # Check if the word has at least 3 characters\n        if len(cleaned_word) >= 3:\n            # Check if 'z' is in the middle (not at start or end)\n            if cleaned_word[1:-1].find('z') != -1:\n                return True\n    \n    return False\n```"
  },
  {
    "id":44,
    "response":"```python\ndef reverse_Array_Upto_K(lst, k):\n    \"\"\"\n    Reverse the first k elements of the array.\n    \n    Args:\n        lst: List of elements\n        k: Number of elements from the start to reverse\n    \n    Returns:\n        Modified list with first k elements reversed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst[:]\n    \n    # Create a copy to avoid modifying the original list\n    result = lst[:]\n    # Reverse the first k elements\n    result[:k] = reversed(result[:k])\n    return result\n```"
  },
  {
    "id":45,
    "response":"```python\ndef find_k_product(lst, k):\n    \"\"\"\n    Find the product of the kth element from each tuple in the list.\n    \n    Args:\n        lst: A list of tuples\n        k: The index (0-based) of the element to extract from each tuple\n    \n    Returns:\n        The product of the kth elements from each tuple\n    \n    Raises:\n        IndexError: If k is out of range for any tuple\n        TypeError: If lst is not a list of tuples\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    \n    product = 1\n    for item in lst:\n        if not isinstance(item, tuple):\n            raise TypeError(\"All elements in the list must be tuples\")\n        if k >= len(item):\n            raise IndexError(f\"Index {k} is out of range for tuple {item}\")\n        product *= item[k]\n    \n    return product\n```"
  },
  {
    "id":46,
    "response":"```python\ndef no_of_cubes(n, k):\n    \"\"\"\n    Calculate the number of k-sized cubes that can fit in an n-sized cube.\n    \n    Args:\n        n (int): The side length of the larger cube.\n        k (int): The side length of the smaller cube.\n    \n    Returns:\n        int: The number of k-sized cubes that can fit in an n-sized cube.\n    \n    Example:\n        no_of_cubes(3, 1) returns 27\n        no_of_cubes(4, 2) returns 8\n    \"\"\"\n    if k > n:\n        return 0\n    return (n \/\/ k) ** 3\n```"
  },
  {
    "id":47,
    "response":"```python\ndef split_upperstring(s):\n    \"\"\"\n    একটি স্ট্রিংকে বড় অক্ষরে বিভক্ত করে ফেরত দেয়।\n    বড় অক্ষরের প্রতিটি অক্ষর একটি আলাদা স্ট্রিং হিসেবে বিভক্ত হয়।\n    \n    Args:\n        s (str): ইনপুট স্ট্রিং\n        \n    Returns:\n        list: বড় অক্ষরগুলি বিভক্ত করে ফেরত দেয়\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isupper():\n            result.append(char)\n    return result\n```"
  },
  {
    "id":48,
    "response":"```python\ndef exchange_elements(lst):\n    \"\"\"\n    Exchange elements at positions n and n+1 in a list.\n    For each n, swap the element at index n with the element at index n+1.\n    If the list has odd length, the last element remains unchanged.\n    \n    Args:\n        lst: List of elements\n        \n    Returns:\n        Modified list with elements swapped in adjacent pairs\n    \"\"\"\n    if len(lst) <= 1:\n        return lst[:]\n    \n    result = lst[:]\n    for i in range(0, len(lst) - 1, 2):\n        result[i], result[i + 1] = result[i + 1], result[i]\n    \n    return result\n```"
  },
  {
    "id":49,
    "response":"```python\ndef sum_range_list(lst, n, n2):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range [n, n2].\n    \n    Args:\n        lst: List of numbers\n        n: Starting index (inclusive)\n        n2: Ending index (inclusive)\n    \n    Returns:\n        Sum of numbers in the range [n, n2] of the list\n    \"\"\"\n    # Ensure the range is valid\n    start = max(0, n)\n    end = min(len(lst) - 1, n2)\n    \n    # Calculate sum of elements in the specified range\n    return sum(lst[start:end + 1])\n```"
  },
  {
    "id":50,
    "response":"```python\ndef are_equal(lst, lst2, n, n2):\n    \"\"\"\n    Check if two arrays are equal.\n    \n    Args:\n        lst: First list to compare\n        lst2: Second list to compare\n        n: Length of first list\n        n2: Length of second list\n    \n    Returns:\n        True if both lists are equal in length and contain the same elements,\n        False otherwise\n    \"\"\"\n    # Check if lengths are equal\n    if n != n2:\n        return False\n    \n    # Check if elements are the same\n    for i in range(n):\n        if lst[i] != lst2[i]:\n            return False\n    \n    return True\n```"
  },
  {
    "id":51,
    "response":"```python\ndef check_subset(tup, tup2):\n    \"\"\"\n    Check if tup is a subset of tup2.\n    \n    Args:\n        tup: The tuple to check if it's a subset.\n        tup2: The tuple to check against.\n    \n    Returns:\n        bool: True if tup is a subset of tup2, False otherwise.\n    \"\"\"\n    return set(tup).issubset(set(tup2))\n```"
  },
  {
    "id":52,
    "response":"```python\ndef matrix_to_list(matrix):\n    \"\"\"\n    Convert a tuple matrix (list of tuples) into a flat list where each tuple represents a column.\n    \n    Args:\n        matrix: A tuple of tuples, where each inner tuple represents a row.\n    \n    Returns:\n        A tuple of tuples, where each inner tuple contains elements from the same column.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return ()\n    \n    # Get the number of rows\n    num_rows = len(matrix)\n    # Get the number of columns\n    num_cols = len(matrix[0])\n    \n    # Create result tuples for each column\n    result = []\n    for col in range(num_cols):\n        column = tuple(matrix[row][col] for row in range(num_rows))\n        result.append(column)\n    \n    return tuple(result)\n```"
  },
  {
    "id":53,
    "response":"```python\ndef grouping_dictionary(lst):\n    \"\"\"\n    একটি কী-মান জোড়ার ক্রম (list of tuples) গ্রহণ করে এবং এটিকে একটি তালিকার অভিধানে (dictionary of lists) গোষ্ঠীভুক্ত করে।\n    \n    Parameters:\n    lst (list of tuples): কী-মান জোড়ার ক্রম। যেমন: [(1, 'a'), (2, 'b'), (1, 'c')]\n    \n    Returns:\n    dict: কী হিসেবে অভিধানের কী এবং মান হিসেবে তালিকা।\n    \"\"\"\n    result = {}\n    for key, value in lst:\n        if key not in result:\n            result[key] = []\n        result[key].append(value)\n    return result\n```"
  },
  {
    "id":54,
    "response":"```python\ndef rectangle_perimeter(n, n2):\n    \"\"\"\n    একটি আয়তক্ষেত্রের পরিধি বের করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    n (int\/float): আয়তক্ষেত্রের দৈর্ঘ্য\n    n2 (int\/float): আয়তক্ষেত্রের প্রস্থ\n    \n    রিটার্ন:\n    int\/float: আয়তক্ষেত্রের পরিধি (2 * (দৈর্ঘ্য + প্রস্থ))\n    \"\"\"\n    return 2 * (n + n2)\n```"
  },
  {
    "id":55,
    "response":"```python\ndef fifth_Power_Sum(n):\n    \"\"\"\n    Calculate the sum of the fifth powers of the first n natural numbers.\n    \n    Args:\n        n (int): The number of natural numbers to consider (1 to n).\n    \n    Returns:\n        int: The sum of fifth powers from 1^5 to n^5.\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total += i ** 5\n    return total\n```"
  },
  {
    "id":56,
    "response":"```python\ndef find_Min_Sum(lst, lst2, n):\n    \"\"\"\n    Find the minimum sum of absolute differences between elements of two arrays.\n    \n    Args:\n        lst: First list of integers\n        lst2: Second list of integers\n        n: Length of each list (assumed to be same)\n    \n    Returns:\n        Minimum sum of absolute differences between paired elements\n    \"\"\"\n    # Sort both arrays to minimize the sum of absolute differences\n    lst.sort()\n    lst2.sort()\n    \n    # Calculate the sum of absolute differences between paired elements\n    min_sum = 0\n    for i in range(n):\n        min_sum += abs(lst[i] - lst2[i])\n    \n    return min_sum\n```"
  },
  {
    "id":57,
    "response":"```python\ndef first_digit(n):\n    \"\"\"\n    প্রদত্ত সংখ্যার ফ্যাক্টরিয়ালের প্রথম অঙ্কটি খুঁজে পায়।\n    \n    প্যারামিটার:\n    n (int): ফ্যাক্টরিয়াল গণনা করা হবে এই সংখ্যার জন্য।\n    \n    রিটার্ন:\n    int: ফ্যাক্টরিয়ালের প্রথম অঙ্ক।\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"ফ্যাক্টরিয়াল নেগেটিভ সংখ্যা জন্য নির্ধারিত নয়।\")\n    \n    if n == 0 or n == 1:\n        return 1\n    \n    # ফ্যাক্টরিয়াল গণনা\n    factorial = 1\n    for i in range(2, n + 1):\n        factorial *= i\n    \n    # প্রথম অঙ্ক খুঁজে পাওয়া\n    first = int(str(factorial)[0])\n    \n    return first\n```"
  },
  {
    "id":58,
    "response":"```python\ndef max_occurrences(lst):\n    \"\"\"\n    প্রদত্ত তালিকায় সর্বোচ্চ সংখ্যক বার প্রদর্শিত আইটেমটি খুঁজে বের করে।\n    \n    Args:\n        lst: একটি তালিকা (list)\n    \n    Returns:\n        সর্বোচ্চ সংখ্যক বার প্রদর্শিত আইটেম। যদি তালিকা খালি হয় তবে None রিটার্ন করে।\n    \"\"\"\n    if not lst:\n        return None\n    \n    # আইটেমগুলির সংখ্যা গণনা করা\n    count_dict = {}\n    for item in lst:\n        count_dict[item] = count_dict.get(item, 0) + 1\n    \n    # সর্বোচ্চ সংখ্যক বার প্রদর্শিত আইটেম খুঁজে বের করা\n    max_item = max(count_dict, key=count_dict.get)\n    \n    return max_item\n```"
  },
  {
    "id":59,
    "response":"```python\ndef repeat(lst):\n    \"\"\"\n    পূর্ণসংখ্যার তালিকা থেকে ডুপ্লিকেট মুদ্রণ করে।\n    \n    এই ফাংশনটি একটি তালিকার মধ্যে প্রতিটি ডুপ্লিকেট সংখ্যা মুদ্রণ করে।\n    \n    Args:\n        lst: পূর্ণসংখ্যার তালিকা\n        \n    Returns:\n        ডুপ্লিকেট সংখ্যাগুলির একটি তালিকা\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    \n    for item in lst:\n        if item in seen:\n            duplicates.add(item)\n        else:\n            seen.add(item)\n    \n    return list(duplicates)\n```"
  },
  {
    "id":60,
    "response":"```python\ndef find_Points(n, n2, n3, n4):\n    \"\"\"\n    Find a point that lies in neither of the two ranges.\n    \n    Parameters:\n    n, n2: The start and end of the first range (inclusive)\n    n3, n4: The start and end of the second range (inclusive)\n    \n    Returns:\n    A point that is not in either range, or None if every point is in at least one range.\n    \"\"\"\n    # Define the ranges\n    range1 = set(range(n, n2 + 1))\n    range2 = set(range(n3, n4 + 1))\n    \n    # Find the union of both ranges\n    union = range1.union(range2)\n    \n    # Find a point outside both ranges\n    # Start from a low value and go upwards\n    point = n - 1\n    while point in union:\n        point += 1\n    \n    # If we find a point outside both ranges, return it\n    if point >= 0:\n        return point\n    else:\n        return None\n```"
  },
  {
    "id":61,
    "response":"```python\ndef max_sum_of_three_consecutive(lst, n):\n    \"\"\"\n    Find the maximum sum of three consecutive elements in the list.\n    \n    Args:\n        lst: List of integers\n        n: Length of the list\n    \n    Returns:\n        Maximum sum of three consecutive elements, or None if not possible\n    \"\"\"\n    if n < 3:\n        return None\n    \n    max_sum = float('-inf')\n    \n    # Iterate through the list to find all possible triplets\n    for i in range(n - 2):\n        current_sum = lst[i] + lst[i + 1] + lst[i + 2]\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```"
  },
  {
    "id":62,
    "response":"```python\ndef sorted_dict(dct):\n    \"\"\"\n    একটি অভিধানের কী-ভারিয়েবলগুলি বাছাই করে একটি নতুন অভিধান তৈরি করে।\n    \n    Args:\n        dct (dict): বাছাই করার জন্য দেওয়া অভিধান\n        \n    Returns:\n        dict: কী বাছাই করে তৈরি করা অভিধান\n    \"\"\"\n    return {k: dct[k] for k in sorted(dct.keys())}\n```"
  },
  {
    "id":63,
    "response":"```python\ndef find_max_val(n, n2, n3):\n    \"\"\"\n    Find the maximum possible value of k such that k mod x = y.\n    Given n, n2, n3, we interpret this as finding k where k mod n = n2 and k mod n2 = n3.\n    However, the problem statement is ambiguous.\n    \n    Since the example is not clearly defined, we assume:\n    We want the maximum k such that k mod n = n2 and k mod n2 = n3.\n    \n    But this is not standard. A more likely interpretation:\n    We want the maximum k such that k mod x = y, where x and y are derived from n, n2, n3.\n    \n    Given the ambiguity, we interpret the problem as:\n    Find the maximum k such that k mod n = n2 and k mod n2 = n3.\n    \n    This is a system of congruences. Using the Chinese Remainder Theorem, we can solve it.\n    However, if n, n2, n3 are given, and we want k such that:\n    k ≡ n2 (mod n)\n    k ≡ n3 (mod n2)\n    \n    But the problem says \"k mod x = y\", so perhaps x and y are n, n2, n3 respectively?\n    \n    Let's assume: find maximum k such that k mod n = n2 and k mod n2 = n3.\n    \n    However, if k mod n = n2, then n2 must be less than n. Similarly, n3 < n2.\n    \n    Since we are looking for maximum k, and there are infinitely many solutions, \n    we interpret the problem as finding the maximum k less than some bound.\n    \n    But no bound is given. So we assume the problem is to find the maximum k \n    satisfying k mod n = n2 and k mod n2 = n3, with k being positive.\n    \n    Actually, the solutions to such congruences are periodic. The general solution \n    will be of the form k = k0 + LCM(n, n2) * t for integer t.\n    \n    So there is no maximum unless we bound k.\n    \n    Therefore, we assume the problem is to find the maximum k such that k mod n = n2 \n    and k mod n2 = n3, with k < n * n2 (or some reasonable bound).\n    \n    But without a clear problem statement, we return a default value.\n    \n    Given the ambiguity, we return the largest possible value of k that satisfies \n    k mod n = n2 and k mod n2 = n3, within a reasonable range.\n    \n    If no such k exists, return -1.\n    \"\"\"\n    # Check if n2 < n and n3 < n2 (necessary for k mod n = n2 and k mod n2 = n3)\n    if n2 >= n or n3 >= n2:\n        return -1\n    \n    # We are solving:\n    # k ≡ n2 (mod n)\n    # k ≡ n3 (mod n2)\n    \n    # Find a solution using Chinese Remainder Theorem\n    # k = n2 + a*n for some a\n    # So: n2 + a*n ≡ n3 (mod n2)\n    # a*n ≡ (n3 - n2) (mod n2)\n    \n    # Solve for a: a*n ≡ (n3 - n2) (mod n2)\n    # This is a linear congruence in a\n    \n    # If gcd(n, n2) divides (n3 - n2), then solution exists\n    \n    import math\n    \n    g = math.gcd(n, n2)\n    diff = (n3 - n2) % n2\n    \n    if diff % g != 0:\n        return -1\n    \n    # Solve a*n ≡ diff (mod n2)\n    # We can solve this using extended Euclidean algorithm\n    \n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b \/\/ a) * x1\n        y = x1\n        return gcd, x, y\n    \n    gcd_val, x_val, y_val = extended_gcd(n, n2)\n    # x_val is a solution to n*x_val ≡ 1 (mod n2) if gcd_val = 1\n    # But we need to scale\n    \n    # We want a such that a*n ≡ diff (mod n2)\n    # a ≡ diff * (n^{-1} mod n2\/gcd) (mod n2\/gcd)"
  },
  {
    "id":64,
    "response":"```python\ndef average_even(n):\n    \"\"\"\n    একটি নির্দিষ্ট সংখ্যার মধ্যবর্তী সংখ্যার গড় খুঁজে বের করে।\n    \n    প্যারামিটার:\n    n (int): মধ্যবর্তী সংখ্যা হিসাবে নির্দেশিত সংখ্যা।\n    \n    ফাংশনটি প্রদত্ত n এর মধ্যে সব জোড় সংখ্যার গড় বের করে।\n    যদি n জোড় হয়, তবে মধ্যবর্তী সংখ্যা হবে n এর মধ্যে সব জোড় সংখ্যা।\n    যদি n বিজোড় হয়, তবে মধ্যবর্তী সংখ্যা হবে n-1 এর মধ্যে সব জোড় সংখ্যা।\n    \n    ফলাফল:\n    float: জোড় সংখ্যার গড়।\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # জোড় সংখ্যা হিসাবে মধ্যবর্তী সংখ্যা বের করা\n    # যদি n জোড় হয়, তবে মধ্যবর্তী সংখ্যা হবে n এর মধ্যে সব জোড় সংখ্যা\n    # যদি n বিজোড় হয়, তবে মধ্যবর্তী সংখ্যা হবে n-1 এর মধ্যে সব জোড় সংখ্যা\n    \n    if n % 2 == 0:\n        # n জোড় হলে, জোড় সংখ্যা হবে 2, 4, ..., n\n        first_even = 2\n        last_even = n\n        count = (n \/\/ 2)\n    else:\n        # n বিজোড় হলে, জোড় সংখ্যা হবে 2, 4, ..., n-1\n        first_even = 2\n        last_even = n - 1\n        count = (n - 1) \/\/ 2\n    \n    if count == 0:\n        return 0\n    \n    # জোড় সংখ্যার গড় = (প্রথম + শেষ) \/ 2\n    return (first_even + last_even) \/ 2\n```"
  },
  {
    "id":65,
    "response":"```python\ndef move_last(lst):\n    \"\"\"\n    Move the last element of the list to the front.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A new list with the last element moved to the front\n    \"\"\"\n    if len(lst) <= 1:\n        return lst[:]\n    \n    last_element = lst[-1]\n    return [last_element] + lst[:-1]\n```"
  },
  {
    "id":66,
    "response":"```python\ndef count_char(s, s2):\n    \"\"\"\n    Count the occurrences of characters in s2 within string s.\n    \n    Args:\n        s (str): The main string to search in.\n        s2 (str): The character(s) to count in s.\n    \n    Returns:\n        dict: A dictionary with characters as keys and their counts as values.\n    \"\"\"\n    char_count = {}\n    for char in s2:\n        count = s.count(char)\n        char_count[char] = count\n    return char_count\n```"
  },
  {
    "id":67,
    "response":"```python\ndef count_vowels(s):\n    \"\"\"\n    Count the number of vowels in a given string.\n    \n    Args:\n        s (str): The input string to check for vowels.\n    \n    Returns:\n        int: The number of vowels in the string.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count\n```"
  },
  {
    "id":68,
    "response":"```python\ndef replace(s, s2):\n    \"\"\"\n    Replace each character in string s with the corresponding character in s2.\n    If s2 is shorter than s, only the first len(s2) characters are used.\n    If s2 is longer, extra characters in s2 are ignored.\n    \n    Args:\n        s (str): The input string to process\n        s2 (str): The replacement string\n    \n    Returns:\n        str: The resulting string after replacement\n    \"\"\"\n    if not s:\n        return \"\"\n    \n    min_len = min(len(s), len(s2))\n    result = \"\"\n    for i in range(min_len):\n        result += s2[i]\n    \n    return result\n```"
  },
  {
    "id":69,
    "response":"```python\nimport re\n\ndef check_IP(s):\n    \"\"\"\n    রেজেক্স ব্যবহার করে প্রদত্ত আইপি ঠিকানাটি বৈধ কিনা তা পরীক্ষা করে।\n    \n    Args:\n        s (str): আইপি ঠিকানা স্ট্রিং\n        \n    Returns:\n        bool: যদি আইপি ঠিকানা বৈধ হয় তবে True, নাহলে False\n    \"\"\"\n    # বৈধ আইপি ঠিকানা এর জন্য রেজেক্স প্যাটার্ন\n    pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'\n    \n    return bool(re.match(pattern, s))\n```"
  },
  {
    "id":70,
    "response":"```python\ndef decreasing_trend(lst):\n    \"\"\"\n    Check if a list of numbers is in decreasing trend.\n    \n    Args:\n        lst: A list of numbers\n        \n    Returns:\n        True if the list is in decreasing trend, False otherwise\n    \"\"\"\n    if len(lst) <= 1:\n        return True\n    \n    for i in range(1, len(lst)):\n        if lst[i] >= lst[i-1]:\n            return False\n    \n    return True\n```"
  },
  {
    "id":71,
    "response":"```python\ndef set_right_most_unset_bit(n):\n    \"\"\"\n    ডানদিকে সবচেয়ে বেশি বিট সেট না করার জন্য একটি পাইথন ফাংশন।\n    এটি প্রদত্ত সংখ্যার ডানদিকে সবচেয়ে বেশি বিট সেট করে না করে তার সবচেয়ে ডানে অসেট বিটটি সেট করে।\n    \n    Parameters:\n    n (int): প্রদত্ত সংখ্যা\n    \n    Returns:\n    int: ডানদিকে সবচেয়ে বেশি বিট সেট না করে সবচেয়ে ডানে অসেট বিটটি সেট করে সংখ্যা\n    \"\"\"\n    # ডানদিকে সবচেয়ে বেশি বিট সেট করা হবে না, তাই আমরা সবচেয়ে ডানে অসেট বিটটি সেট করব\n    # প্রথমে সব বিট কে একটি বিট ম্যাসক দিয়ে কাজ করব\n    # এটি করার জন্য আমরা প্রদত্ত সংখ্যার সাথে একটি ম্যাসক ব্যবহার করব\n    # যেখানে সব বিট সেট হয়ে থাকে এবং সব বিট অসেট হয়ে থাকে তা দেখা যাবে\n    \n    # সব বিট সেট হওয়া সংখ্যা হল (n | (n + 1)) না, তবে আমরা চাই যে সব বিট সেট হয় না\n    # আমরা চাই যে সব বিট অসেট হয় এবং সব বিট সেট হয় না\n    \n    # সব বিট অসেট হওয়া সংখ্যা হল (n & (n + 1)) না, তবে আমরা চাই যে সব বিট সেট হয় না\n    # আমরা চাই যে সব বিট অসেট হয় এবং সব বিট সেট হয় না\n    \n    # সব বিট অসেট হওয়া সংখ্যা হল (n ^ (n + 1)) না, তবে আমরা চাই যে সব বিট সেট হয় না\n    \n    # আমরা চাই যে সব বিট সেট হয় না, তাই আমরা সব বিট অসেট হওয়া সংখ্যা পেতে চাই\n    # সব বি�"
  },
  {
    "id":72,
    "response":"```python\ndef max_of_three(n, n2, n3):\n    \"\"\"\n    তিনটি সংখ্যা থেকে সর্বোচ্চ সংখ্যা পাওয়া যায়।\n    \n    Parameters:\n    n, n2, n3: তিনটি সংখ্যা\n    \n    Returns:\n    সর্বোচ্চ সংখ্যা\n    \"\"\"\n    return max(n, n2, n3)\n```"
  },
  {
    "id":73,
    "response":"```python\ndef convert(lst):\n    \"\"\"\n    Convert a list of integers into a single integer by concatenating their string representations.\n    \n    Args:\n        lst (list of int): A list of integers\n        \n    Returns:\n        int: A single integer formed by concatenating the digits of the input list\n    \"\"\"\n    if not lst:\n        return 0\n    \n    result = \"\"\n    for num in lst:\n        result += str(num)\n    \n    return int(result)\n```"
  },
  {
    "id":74,
    "response":"```python\ndef remove_duplicate(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিং থেকে ডুপ্লিকেট শব্দ অপসারণ করে।\n    \n    Args:\n        s (str): ডুপ্লিকেট শব্দ থাকা স্ট্রিং\n        \n    Returns:\n        str: ডুপ্লিকেট শব্দ বিহীন স্ট্রিং\n    \"\"\"\n    # শব্দগুলি সেটে রাখে যাতে ডুপ্লিকেট হয় না\n    words = s.split()\n    unique_words = list(set(words))\n    # শব্দগুলি আবার স্ট্রিং হিসেবে ফেরত দেয়\n    return ' '.join(unique_words)\n```"
  },
  {
    "id":75,
    "response":"```python\ndef sum_nums(n, n2, n3, n4):\n    \"\"\"\n    দুটি পূর্ণসংখ্যার যোগ করে ফেরত দেয়।\n    যদি যোগফল প্রদত্ত পরিসরের মধ্যে থাকে তবে 20 প্রদান করে।\n    \n    Parameters:\n    n, n2, n3, n4: পূর্ণসংখ্যা (যদিও কেবল দুটি প্রয়োজন)\n    \n    Returns:\n    যোগফল বা 20 (যদি যোগফল পরিসরের মধ্যে থাকে)\n    \"\"\"\n    # দুটি পূর্ণসংখ্যা নিয়ে যোগ করা হবে\n    total = n + n2\n    \n    # পরিসর নির্ধারণ করা হয়েছে না, তাই এখানে পরিসর দেওয়া হয়নি।\n    # যদি পরিসর দেওয়া থাকে তবে এটি চেক করা হবে।\n    # এখানে পরিসর না থাকলে ফলাফল 20 হবে।\n    \n    # কারণ: যদি যোগফল পরিসরের মধ্যে থাকে তবে 20 প্রদান করবে।\n    # কিন্তু পরিসর না দেওয়া হয়েছে, তাই এখানে একটি সহজ কাজ হিসাবে ফলাফল 20 রাখা হবে।\n    \n    return 20\n```"
  },
  {
    "id":76,
    "response":"```python\nimport re\n\ndef remove_extra_char(s):\n    \"\"\"\n    Remove all non-alphanumeric characters from a string using regex.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: String containing only alphanumeric characters\n    \"\"\"\n    return re.sub(r'[^a-zA-Z0-9]', '', s)\n```"
  },
  {
    "id":77,
    "response":"```python\ndef validity_triangle(n, n2, n3):\n    \"\"\"\n    ত্রিভুজের বৈধতা পরীক্ষা করে।\n    \n    ত্রিভুজের তিন পক্ষের দৈর্ঘ্য দেওয়া হলে, এগুলি একটি বৈধ ত্রিভুজ গঠন করে কিনা তা চেক করে।\n    ত্রিভুজের নিয়ম: যেকোন দুটি পক্ষের সমষ্টি তৃতীয় পক্ষের চেয়ে বড় হতে হবে।\n    \n    Parameters:\n    n, n2, n3 (float): ত্রিভুজের তিনটি পক্ষের দৈর্ঘ্য\n    \n    Returns:\n    bool: যদি ত্রিভুজ বৈধ হয় তবে True, না হয় তবে False\n    \"\"\"\n    # পক্ষগুলি নেগেটিভ হওয়া উচিত না\n    if n <= 0 or n2 <= 0 or n3 <= 0:\n        return False\n    \n    # ত্রিভুজের নিয়ম: যেকোন দুটি পক্ষের সমষ্টি তৃতীয় পক্ষের চেয়ে বড় হতে হবে\n    return (n + n2 > n3) and (n + n3 > n2) and (n2 + n3 > n)\n```"
  },
  {
    "id":78,
    "response":"```python\ndef remove_spaces(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিং থেকে স্পেস অপসারণ করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    s (str): স্পেস অপসারণের জন্য দেয়া স্ট্রিং\n    \n    রিটার্ন:\n    str: স্পেস বিহীন স্ট্রিং\n    \"\"\"\n    return s.replace(\" \", \"\")\n```"
  },
  {
    "id":79,
    "response":"```python\ndef access_key(dct, n):\n    \"\"\"\n    ডিকশনারি কী এর উপাদানগুলিকে সূচক অনুসারে অ্যাক্সেস করে।\n    \n    প্যারামিটার:\n    dct (dict): ডিকশনারি যার কী এর উপাদানগুলি অ্যাক্সেস করা হবে\n    n (int): সূচক, যা কী এর সূচিত ক্রম নির্দেশ করে\n    \n    রিটার্ন:\n    দেওয়া কীর মান যদি সূচক সংখ্যা কী এর সূচিত হয়, অন্যথায় None\n    \"\"\"\n    if n < 0 or n >= len(dct):\n        return None\n    keys = list(dct.keys())\n    return dct[keys[n]]\n```"
  },
  {
    "id":80,
    "response":"```python\ndef increasing_trend(lst):\n    \"\"\"\n    Check if a list of numbers is in an increasing trend.\n    \n    Args:\n        lst: A list of numbers\n        \n    Returns:\n        bool: True if the list is in increasing trend (each element is strictly greater than the previous one),\n              False otherwise\n    \"\"\"\n    if len(lst) <= 1:\n        return True\n    \n    for i in range(1, len(lst)):\n        if lst[i] <= lst[i-1]:\n            return False\n    \n    return True\n```"
  },
  {
    "id":81,
    "response":"```python\ndef smallest_divisor(n):\n    \"\"\"\n    একটি সংখ্যার ক্ষুদ্রতম অক্ষরের বিভাজক খুঁজে বের করে।\n    \n    প্রমাণ: যদি n একটি সংখ্যা হয়, তবে এর ক্ষুদ্রতম বিভাজক (যদি এটি নিজের চেয়ে ছোট হয়) খুঁজে বের করা হবে।\n    ক্ষুদ্রতম বিভাজক হবে যদি n প্রাইম হয়, তবে তার ক্ষুদ্রতম বিভাজক হবে 1।\n    \n    Parameters:\n    n (int): ক্ষুদ্রতম বিভাজক খুঁজে বের করার জন্য সংখ্যা।\n    \n    Returns:\n    int: ক্ষুদ্রতম বিভাজক।\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    # 1 থেকে শুরু করে ক্ষুদ্রতম বিভাজক খুঁজে বের করা হবে\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return i\n    \n    # যদি কোন বিভাজক পাওয়া যায় না, তবে সংখ্যাটি প্রাইম হয়\n    return n\n```"
  },
  {
    "id":82,
    "response":"```python\ndef mul_list(lst, lst2):\n    \"\"\"\n    দুটি তালিকার গুণ করে একটি নতুন তালিকা তৈরি করে।\n    মানচিত্র এবং ল্যাম্বদা ফাংশন ব্যবহার করে।\n    \n    Args:\n        lst: প্রথম তালিকা\n        lst2: দ্বিতীয় তালিকা\n    \n    Returns:\n        দুটি তালিকার সংশ্লিষ্ট উপাদানের গুণফলের তালিকা\n    \"\"\"\n    return list(map(lambda x, y: x * y, lst, lst2))\n```"
  },
  {
    "id":83,
    "response":"```python\ndef sum_square(n):\n    \"\"\"\n    Check if a given number can be expressed as the sum of two squares.\n    \n    Args:\n        n (int): The number to check.\n    \n    Returns:\n        bool: True if n can be expressed as the sum of two squares, False otherwise.\n    \"\"\"\n    # Check all possible pairs of integers (a, b) such that a^2 + b^2 = n\n    # We only need to check up to sqrt(n) for both a and b\n    import math\n    \n    sqrt_n = int(math.sqrt(n))\n    \n    for a in range(sqrt_n + 1):\n        b_squared = n - a * a\n        b = int(math.sqrt(b_squared))\n        \n        # Check if b_squared is a perfect square\n        if b * b == b_squared:\n            return True\n    \n    return False\n```"
  },
  {
    "id":84,
    "response":"```python\ndef count_Char(s, s2):\n    \"\"\"\n    Count the occurrences of characters in string s2 within string s.\n    \n    Args:\n        s (str): The main string to search in.\n        s2 (str): The string containing characters to count.\n    \n    Returns:\n        dict: A dictionary with characters from s2 as keys and their counts in s as values.\n    \"\"\"\n    char_count = {}\n    for char in s2:\n        count = s.count(char)\n        char_count[char] = count\n    return char_count\n```"
  },
  {
    "id":85,
    "response":"```python\ndef sum_of_primes(n):\n    \"\"\"\n    Calculate the sum of all prime numbers from 1 to n (inclusive).\n    \n    Args:\n        n (int): The upper limit (inclusive).\n    \n    Returns:\n        int: The sum of all prime numbers from 1 to n.\n    \"\"\"\n    if n < 2:\n        return 0\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num ** 0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    prime_sum = 0\n    for num in range(2, n + 1):\n        if is_prime(num):\n            prime_sum += num\n    \n    return prime_sum\n```"
  },
  {
    "id":86,
    "response":"```python\ndef freq_element(tup):\n    \"\"\"\n    Calculate the frequency of each element in the given tuple.\n    \n    Args:\n        tup: A tuple containing elements (can be of any hashable type)\n    \n    Returns:\n        A dictionary where keys are the elements from the tuple and values are their frequencies\n    \"\"\"\n    freq = {}\n    for element in tup:\n        freq[element] = freq.get(element, 0) + 1\n    return freq\n```"
  },
  {
    "id":87,
    "response":"```python\ndef recur_gcd(n, n2):\n    \"\"\"\n    পুনরাবৃত্তি ব্যবহার করে দুটি পূর্ণসংখ্যার বৃহত্তম সাধারণ বিভাজক (GCD) খুঁজে বের করে।\n    \n    প্রয়োজনীয় শর্ত: n এবং n2 উভয়ই পূর্ণসংখ্যা হতে হবে এবং দুটি সংখ্যার মধ্যে কম সংখ্যাটি হবে।\n    \n    প্রদত্ত প্রতিটি সংখ্যার জন্য যদি সংখ্যা একটি সংখ্যা হয় তবে সেটি হবে সংখ্যার জন্য সংখ্যা হবে।\n    \n    প্রয়োজনীয় প্রক্রিয়া: যদি n2 == 0 হয় তবে n হবে বৃহত্তম সাধারণ বিভাজক।\n    যদি n2 != 0 হয় তবে আমরা পুনরাবৃত্তি করব এবং নতুন সংখ্যা হবে gcd(n2, n % n2)।\n    \n    প্রতিটি সংখ্যার জন্য পুনরাবৃত্তি করা হবে যতক্ষণ না n2 == 0 হয়।\n    \"\"\"\n    if n2 == 0:\n        return n\n    else:\n        return recur_gcd(n2, n % n2)\n```"
  },
  {
    "id":88,
    "response":"```python\ndef len_complex(n, n2):\n    \"\"\"\n    জটিল সংখ্যার দৈর্ঘ্য পেতে একটি ফাংশন।\n    জটিল সংখ্যা হল একটি বাস্তব সংখ্যা এবং একটি কাল্পনিক সংখ্যা (i) এর সমন্বয়।\n    এখানে দৈর্ঘ্য হল জটিল সংখ্যার মান (magnitude) অর্থাৎ sqrt(a^2 + b^2) যেখানে a হল বাস্তব অংশ এবং b হল কাল্পনিক অংশ।\n    \n    Parameters:\n    n: জটিল সংখ্যার বাস্তব অংশ (real part)\n    n2: জটিল সংখ্যার কাল্পনিক অংশ (imaginary part)\n    \n    Returns:\n    জটিল সংখ্যার দৈর্ঘ্য (magnitude)\n    \"\"\"\n    import math\n    return math.sqrt(n**2 + n2**2)\n```"
  },
  {
    "id":89,
    "response":"```python\ndef min_jumps(lst, n):\n    \"\"\"\n    Find the minimum number of jumps needed to reach the end of the array.\n    Each element at index i represents the maximum jump length from that position.\n    \n    Args:\n        lst: List of integers representing the maximum jump length from each index\n        n: Length of the array\n    \n    Returns:\n        Minimum number of jumps required to reach the end, or -1 if impossible\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    if lst[0] == 0:\n        return -1\n    \n    jumps = 1\n    current_reach = lst[0]\n    next_reach = 0\n    \n    for i in range(1, n - 1):\n        next_reach = max(next_reach, i + lst[i])\n        \n        if i == current_reach:\n            jumps += 1\n            current_reach = next_reach\n            \n            # If we can reach the end\n            if current_reach >= n - 1:\n                break\n    \n    return jumps if current_reach >= n - 1 else -1\n```"
  },
  {
    "id":90,
    "response":"```python\ndef mul_consecutive_nums(lst):\n    \"\"\"\n    প্রদত্ত তালিকার পরপর সংখ্যাগুলির গুণফল নির্ণয় করে ফেরত দেয়।\n    \n    Args:\n        lst: একটি সংখ্যা বিশিষ্ট তালিকা\n        \n    Returns:\n        পরপর সংখ্যাগুলির গুণফলের মান\n    \"\"\"\n    if not lst:\n        return 1\n    \n    result = 1\n    for num in lst:\n        result *= num\n    return result\n```"
  },
  {
    "id":91,
    "response":"```python\ndef group_element(lst):\n    \"\"\"\n    Group the first elements of tuples based on the second elements.\n    \n    Args:\n        lst: A list of tuples where each tuple has at least two elements.\n    \n    Returns:\n        A dictionary where keys are the second elements of the tuples,\n        and values are lists of first elements that correspond to those second elements.\n    \"\"\"\n    result = {}\n    for item in lst:\n        second_element = item[1]\n        first_element = item[0]\n        if second_element not in result:\n            result[second_element] = []\n        result[second_element].append(first_element)\n    return result\n```"
  },
  {
    "id":92,
    "response":"```python\ndef last_Two_Digits(n):\n    \"\"\"\n    Return the last two digits of n! (n factorial).\n    \n    If n is greater than 10, the factorial will have trailing zeros,\n    so we compute n! modulo 100 to get the last two digits.\n    For n <= 10, we compute the factorial directly.\n    \"\"\"\n    if n < 0:\n        return None\n    \n    if n == 0 or n == 1:\n        return 1\n    \n    # For n >= 10, n! will have at least two trailing zeros\n    # So we compute n! mod 100 to get the last two digits\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % 100\n    \n    return result\n```"
  },
  {
    "id":93,
    "response":"```python\nimport re\n\ndef remove_multiple_spaces(s):\n    \"\"\"\n    রেজেক্স ব্যবহার করে স্ট্রিংয়ে একাধিক স্পেস অপসারণ করে।\n    \n    Args:\n        s (str): স্ট্রিং ইনপুট\n        \n    Returns:\n        str: স্পেস অপসারণ করে প্রাপ্ত স্ট্রিং\n    \"\"\"\n    return re.sub(r'\\s+', ' ', s).strip()\n```"
  },
  {
    "id":94,
    "response":"```python\ndef extract_unique(dct):\n    \"\"\"\n    অভিধানের মান থেকে অনন্য মান বের করে একটি সেট রিটার্ন করে।\n    \n    Args:\n        dct (dict): অভিধান\n        \n    Returns:\n        set: অনন্য মানের সেট\n    \"\"\"\n    return set(dct.values())\n```"
  },
  {
    "id":95,
    "response":"```python\ndef check_greater(tup, tup2):\n    \"\"\"\n    Check if each element in the second tuple is greater than the corresponding element in the first tuple.\n    \n    Args:\n        tup: First tuple\n        tup2: Second tuple\n    \n    Returns:\n        A list of boolean values indicating whether each element in tup2 is greater than the corresponding element in tup.\n    \"\"\"\n    result = []\n    for i in range(len(tup)):\n        if i < len(tup2):\n            result.append(tup2[i] > tup[i])\n        else:\n            result.append(False)\n    return result\n```"
  },
  {
    "id":96,
    "response":"```python\ndef zip_list(lst, lst2):\n    \"\"\"\n    দুইটি তালিকাকে একসাথে সংযুক্ত করে এবং প্রতিটি জোড়াকে একটি তালিকায় রাখে।\n    \n    Args:\n        lst: প্রথম তালিকা\n        lst2: দ্বিতীয় তালিকা\n    \n    Returns:\n        দুইটি তালিকার জোড়া হিসাবে তৈরি করা তালিকা\n    \"\"\"\n    return list(zip(lst, lst2))\n```"
  },
  {
    "id":97,
    "response":"```python\ndef count_even(lst):\n    return len(list(filter(lambda x: x % 2 == 0, lst)))\n```"
  },
  {
    "id":98,
    "response":"```python\ndef sort_dict_item(dct):\n    \"\"\"\n    একটি অভিধানের জন্য টিপল কীগুলির টুপল পণ্য দ্বারা অভিধানের আইটেমগুলি বাছাই করে।\n    \n    Parameters:\n    dct (dict): অভিধান যার কীগুলি বাছাই করা হবে।\n    \n    Returns:\n    tuple: বাছাইকৃত কী-বেলু টুপল।\n    \"\"\"\n    if not dct:\n        return ()\n    \n    # কীগুলি টুপল হিসাবে নেয় এবং তাদের অনুসারে আইটেমগুলি বাছাই করে\n    keys = tuple(dct.keys())\n    # কীগুলির টুপল পণ্য দ্বারা আইটেমগুলি বাছাই করা হয়\n    return tuple((key, dct[key]) for key in keys)\n```"
  },
  {
    "id":99,
    "response":"```python\ndef min_swaps(s, s2):\n    \"\"\"\n    Calculate the minimum number of swaps needed to convert binary string s to s2.\n    \n    Args:\n        s (str): Original binary string\n        s2 (str): Target binary string\n    \n    Returns:\n        int: Minimum number of swaps required\n    \n    Note:\n        This problem is equivalent to counting the number of positions where s and s2 differ.\n        Each differing position requires a swap operation. Since each swap can fix two positions,\n        the minimum number of swaps is the number of differing positions divided by 2 (rounded up).\n    \"\"\"\n    # Count the number of positions where s and s2 differ\n    diff_count = sum(1 for i in range(len(s)) if s[i] != s2[i])\n    \n    # Each swap can fix two differing positions\n    # So minimum swaps is ceil(diff_count \/ 2)\n    return (diff_count + 1) \/\/ 2\n```"
  },
  {
    "id":100,
    "response":"```python\ndef count_range_in_list(lst, n, n2):\n    \"\"\"\n    একটি নির্দিষ্ট পরিসরের মধ্যে থাকা একটি তালিকার উপাদানগুলির সংখ্যা গণনা করে।\n    \n    Parameters:\n    lst (list): তালিকা\n    n (int\/float): পরিসরের নিচের সীমা\n    n2 (int\/float): পরিসরের উপরের সীমা\n    \n    Returns:\n    int: পরিসরের মধ্যে থাকা উপাদানগুলির সংখ্যা\n    \"\"\"\n    count = 0\n    for item in lst:\n        if n <= item <= n2:\n            count += 1\n    return count\n```"
  },
  {
    "id":101,
    "response":"```python\ndef equilibrium_index(lst):\n    \"\"\"\n    Find the equilibrium index of a list.\n    An equilibrium index is an index where the sum of elements at lower indices\n    is equal to the sum of elements at higher indices.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        int: The equilibrium index, or -1 if no such index exists\n    \"\"\"\n    if not lst:\n        return -1\n    \n    n = len(lst)\n    \n    # Calculate total sum of the array\n    total_sum = sum(lst)\n    \n    left_sum = 0\n    \n    for i in range(n):\n        # Subtract current element from total sum to get right sum\n        right_sum = total_sum - left_sum - lst[i]\n        \n        # Check if left sum equals right sum\n        if left_sum == right_sum:\n            return i\n        \n        # Add current element to left sum for next iteration\n        left_sum += lst[i]\n    \n    return -1\n```"
  },
  {
    "id":102,
    "response":"```python\ndef removals(lst, n, n2):\n    \"\"\"\n    এমন একটি ফাংশন যা অ্যামাক্স-অ্যামিন <= কে এর মতো সরিয়ে ফেলা উচিত এমন উপাদানগুলির সর্বনিম্ন সংখ্যা খুঁজে পায়।\n    \n    Parameters:\n    lst: একটি লিস্ট যার উপাদানগুলি পরীক্ষা করা হবে\n    n: একটি সংখ্যা, যা সরিয়ে ফেলার জন্য নির্দেশ করে\n    n2: একটি সংখ্যা, যা সরিয়ে ফেলার জন্য নির্দেশ করে\n    \n    Returns:\n    সরিয়ে ফেলা উপাদানগুলির সর্বনিম্ন সংখ্যা\n    \"\"\"\n    # অ্যামাক্স-অ্যামিন <= কে এর মতো সরিয়ে ফেলা উচিত এমন উপাদানগুলির সংখ্যা খুঁজে পাবে\n    # এখানে ধরা হয়েছে যে যদি উপাদানগুলি n এবং n2 এর সমান হয় তবে সেগুলি সরিয়ে ফেলা হবে\n    count = 0\n    for item in lst:\n        if item == n or item == n2:\n            count += 1\n    return count\n```"
  },
  {
    "id":103,
    "response":"```python\ndef is_key_present(dct, n):\n    \"\"\"\n    Check if a key exists in the given dictionary.\n    \n    Args:\n        dct (dict): The dictionary to search in.\n        n: The key to check for existence.\n    \n    Returns:\n        bool: True if the key exists, False otherwise.\n    \"\"\"\n    return n in dct\n```"
  },
  {
    "id":104,
    "response":"```python\ndef harmonic_sum(n):\n    \"\"\"\n    Calculate the harmonic sum of n-1, which is the sum of reciprocals from 1 to n-1.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        float: The harmonic sum of n-1\n    \"\"\"\n    if n <= 1:\n        return 0.0\n    \n    harmonic = 0.0\n    for i in range(1, n):\n        harmonic += 1.0 \/ i\n    \n    return harmonic\n```"
  },
  {
    "id":105,
    "response":"```python\ndef sort_sublists(lst, by_length=True):\n    \"\"\"\n    Sort a list of sublists based on either length or value.\n    \n    Args:\n        lst: A list of sublists (lists or tuples)\n        by_length: If True, sort by length of sublists. If False, sort by the first element (value) of sublists.\n    \n    Returns:\n        A new list of sublists sorted according to the specified criteria.\n    \"\"\"\n    if by_length:\n        # Sort by length of sublists\n        return sorted(lst, key=len)\n    else:\n        # Sort by the first element of each sublist (assuming sublists have at least one element)\n        return sorted(lst, key=lambda x: x[0] if x else float('inf'))\n```"
  },
  {
    "id":106,
    "response":"```python\ndef is_subset(lst, n, lst2, n2):\n    \"\"\"\n    Check if the first array (lst) is a subset of the second array (lst2).\n    \n    Args:\n        lst: First list to check\n        n: Length of first list\n        lst2: Second list to check against\n        n2: Length of second list\n    \n    Returns:\n        True if lst is a subset of lst2, False otherwise\n    \"\"\"\n    # Convert lists to sets for efficient subset checking\n    set1 = set(lst[:n])\n    set2 = set(lst2[:n2])\n    \n    # Check if set1 is a subset of set2\n    return set1.issubset(set2)\n```"
  },
  {
    "id":107,
    "response":"```python\ndef count_Set_Bits(n):\n    \"\"\"\n    Count the total number of set bits (1s) in binary representation\n    of all numbers from 1 to n (inclusive).\n    \n    Args:\n        n (int): The upper limit of the range (1 to n)\n    \n    Returns:\n        int: Total count of set bits in the range 1 to n\n    \"\"\"\n    total_bits = 0\n    for i in range(1, n + 1):\n        # Count set bits in the current number\n        set_bits = bin(i).count('1')\n        total_bits += set_bits\n    return total_bits\n```"
  },
  {
    "id":108,
    "response":"```python\ndef convert(s):\n    \"\"\"\n    Convert a string into a list of characters.\n    \n    Args:\n        s (str): The input string\n        \n    Returns:\n        list: A list containing each character of the string\n    \"\"\"\n    return list(s)\n```"
  },
  {
    "id":109,
    "response":"```python\ndef get_unique(lst):\n    \"\"\"\n    টিপলের প্রতিটি মানের জন্য অনন্য কী গণনা করে একটি ডিকশনারি রিটার্ন করে।\n    যেমন: (1, 2, 2, 3) -> {1: 1, 2: 2, 3: 1}\n    \"\"\"\n    unique_count = {}\n    for item in lst:\n        unique_count[item] = unique_count.get(item, 0) + 1\n    return unique_count\n```"
  },
  {
    "id":110,
    "response":"```python\ndef front_and_rear(tup):\n    \"\"\"\n    Return the first and last elements of a tuple.\n    \n    Args:\n        tup: A tuple containing elements.\n    \n    Returns:\n        A tuple containing (first_element, last_element).\n        If the tuple is empty, returns (None, None).\n    \"\"\"\n    if not tup:\n        return (None, None)\n    return (tup[0], tup[-1])\n```"
  },
  {
    "id":111,
    "response":"```python\ndef product_equal(n):\n    \"\"\"\n    Check if the product of digits of a number is equal to the number itself.\n    This function checks whether the product of all digits in the number equals the number.\n    \n    Args:\n        n (int): The number to check.\n    \n    Returns:\n        bool: True if the product of digits equals the number, False otherwise.\n    \"\"\"\n    # Convert number to string to access individual digits\n    digits = str(n)\n    \n    # Calculate product of digits\n    product = 1\n    for digit_char in digits:\n        digit = int(digit_char)\n        product *= digit\n    \n    # Check if product equals the original number\n    return product == n\n```"
  },
  {
    "id":112,
    "response":"```python\ndef remove_duplicate(lst):\n    \"\"\"\n    তালিকা থেকে ডুপ্লিকেট অপসারণ করে এবং একটি নতুন তালিকা রিটার্ন করে।\n    \n    Args:\n        lst: ডুপ্লিকেট বিশিষ্ট তালিকা\n        \n    Returns:\n        ডুপ্লিকেট বিহীন তালিকা\n    \"\"\"\n    return list(dict.fromkeys(lst))\n```"
  },
  {
    "id":113,
    "response":"```python\ndef check_valid(tup):\n    \"\"\"\n    Check if all elements in the given tuple are valid (i.e., not None or empty).\n    \n    Args:\n        tup: A tuple containing elements to be validated.\n    \n    Returns:\n        bool: True if all elements are valid, False otherwise.\n    \"\"\"\n    if not tup:\n        return True  # Empty tuple is considered valid\n    \n    for element in tup:\n        if element is None or (isinstance(element, (str, list, tuple)) and len(element) == 0):\n            return False\n    \n    return True\n```"
  },
  {
    "id":114,
    "response":"```python\ndef count_Fac(n):\n    \"\"\"\n    প্রদত্ত সংখ্যার প্রধান ফ্যাক্টরের স্বতন্ত্র শক্তির সংখ্যা গণনা করে।\n    \n    উদাহরণ: \n    - 12 = 2^2 * 3^1 → প্রধান ফ্যাক্টরের স্বতন্ত্র শক্তির সংখ্যা = 2\n    - 18 = 2^1 * 3^2 → প্রধান ফ্যাক্টরের স্বতন্ত্র শক্তির সংখ্যা = 2\n    \n    Parameters:\n    n (int): প্রদত্ত সংখ্যা\n    \n    Returns:\n    int: প্রধান ফ্যাক্টরের স্বতন্ত্র শক্তির সংখ্যা\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    count = 0\n    i = 2\n    \n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n        i += 1\n    \n    return count\n```"
  },
  {
    "id":115,
    "response":"```python\ndef str_to_tuple(s):\n    \"\"\"\n    পূর্ণসংখ্যার প্রদত্ত স্ট্রিংকে একটি টিপলে রূপান্তর করে।\n    \n    Args:\n        s (str): পূর্ণসংখ্যা দেখানো স্ট্রিং (উদাহরণ: \"1,2,3\" বা \"1 2 3\")\n    \n    Returns:\n        tuple: পূর্ণসংখ্যা সংযুক্ত টিপল\n    \"\"\"\n    if not s or s.isspace():\n        return ()\n    \n    # স্ট্রিংকে স্পেস বা কমা দ্বারা ভাগ করে পূর্ণসংখ্যা পাবে\n    import re\n    numbers = re.split(r'[,\\s]+', s.strip())\n    \n    # প্রতিটি স্ট্রিং পূর্ণসংখ্যা হিসাবে পরিবর্তন করে\n    tuple_numbers = tuple(int(num) for num in numbers if num)\n    \n    return tuple_numbers\n```"
  },
  {
    "id":116,
    "response":"```python\ndef rombus_perimeter(n):\n    \"\"\"\n    রম্বসের পরিধি বের করে ফেরত দেয়।\n    \n    প্রমাণ: রম্বসের চারটি বাহু সমান, তাই পরিধি = 4 * একটি বাহুর দৈর্ঘ্য।\n    \n    Parameters:\n    n (int or float): রম্বসের একটি বাহুর দৈর্ঘ্য\n    \n    Returns:\n    int or float: রম্বসের পরিধি\n    \"\"\"\n    return 4 * n\n```"
  },
  {
    "id":117,
    "response":"```python\nimport math\n\ndef sd_calc(lst):\n    \"\"\"\n    Calculate the standard deviation of a list of numbers.\n    \n    Args:\n        lst: A list of numbers\n        \n    Returns:\n        The standard deviation as a float\n    \"\"\"\n    if len(lst) == 0:\n        return 0\n    \n    # Calculate the mean\n    mean = sum(lst) \/ len(lst)\n    \n    # Calculate the sum of squared differences from the mean\n    squared_diff_sum = sum((x - mean) ** 2 for x in lst)\n    \n    # Calculate variance (divide by n for population standard deviation)\n    variance = squared_diff_sum \/ len(lst)\n    \n    # Return standard deviation (square root of variance)\n    return math.sqrt(variance)\n```"
  },
  {
    "id":118,
    "response":"```python\ndef alternate_elements(lst):\n    \"\"\"\n    একটি তালিকা তৈরি করে যা অন্য তালিকা থেকে বিকল্প উপাদান গ্রহণ করে।\n    \n    Args:\n        lst: উপাদানগুলি থেকে বিকল্প উপাদান নিতে হবে এমন একটি তালিকা।\n    \n    Returns:\n        বিকল্প উপাদানগুলি থেকে তৈরি হওয়া তালিকা।\n    \"\"\"\n    result = []\n    for i in range(0, len(lst), 2):\n        result.append(lst[i])\n    return result\n```"
  },
  {
    "id":119,
    "response":"```python\ndef text_match(s):\n    \"\"\"\n    Check if a string contains 'a' followed by zero or more 'b's.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string has 'a' followed by zero or more 'b's, False otherwise.\n    \"\"\"\n    import re\n    pattern = r'a(b*)'\n    return bool(re.search(pattern, s))\n```"
  },
  {
    "id":120,
    "response":"```python\ndef add_dict_to_tuple(tup, dct):\n    \"\"\"\n    একটি টিপলে একটি অভিধান যোগ করে একটি নতুন টিপল রিটার্ন করে।\n    \n    Parameters:\n    tup: টিপল\n    dct: অভিধান\n    \n    Returns:\n    টিপলে অভিধান যোগ করা টিপল\n    \"\"\"\n    return tup + (dct,)\n```"
  },
  {
    "id":121,
    "response":"```python\ndef maxAverageOfPath(lst, n):\n    \"\"\"\n    Find the path in an n*n matrix that has the maximum average value.\n    \n    Args:\n        lst: A 2D list (n*n matrix) of numbers.\n        n: The size of the matrix (n*n).\n    \n    Returns:\n        A list representing the path that has the maximum average value.\n    \"\"\"\n    if not lst or n <= 0:\n        return []\n    \n    # Convert the 2D list to a matrix for easier access\n    matrix = [row[:] for row in lst]\n    \n    # We'll use DFS to explore all possible paths from top-left to bottom-right\n    # Since we want the maximum average, we need to consider all possible paths\n    # and find the one with the highest average.\n    \n    # For simplicity, we'll assume that we're looking for a path from (0,0) to (n-1, n-1)\n    # and we want to maximize the average of the values along the path.\n    \n    def dfs(row, col, path):\n        \"\"\"DFS to explore all paths from (0,0) to (n-1, n-1)\"\"\"\n        if row == n - 1 and col == n - 1:\n            # Found the destination, calculate average\n            avg = sum(path) \/ len(path)\n            return avg, path[:]\n        \n        max_avg = float('-inf')\n        best_path = []\n        \n        # Try moving right\n        if col + 1 < n:\n            new_path = path + [matrix[row][col + 1]]\n            avg, path_result = dfs(row, col + 1, new_path)\n            if avg > max_avg:\n                max_avg = avg\n                best_path = path_result\n        \n        # Try moving down\n        if row + 1 < n:\n            new_path = path + [matrix[row + 1][col]]\n            avg, path_result = dfs(row + 1, col, new_path)\n            if avg > max_avg:\n                max_avg = avg\n                best_path = path_result\n        \n        return max_avg, best_path\n    \n    # Start DFS from (0,0)\n    initial_path = [matrix[0][0]]\n    max_avg, result_path = dfs(0, 0, initial_path)\n    \n    return result_path\n```"
  },
  {
    "id":122,
    "response":"```python\ndef filter_data(dct, n, n2):\n    \"\"\"\n    শিক্ষার্থীদের উচ্চতা এবং প্রস্থ ফিল্টার করে যা একটি অভিধানে সংরক্ষিত থাকে।\n    \n    Parameters:\n    dct (dict): শিক্ষার্থীদের তথ্য সংরক্ষিত অভিধান। ধরে নেওয়া হয় যে কোন শিক্ষার্থীর উচ্চতা এবং প্রস্থ অভিধানের কী হিসাবে থাকবে।\n    n (int\/float): উচ্চতা ফিল্টারের নিম্ন সীমা।\n    n2 (int\/float): উচ্চতা ফিল্টারের উচ্চ সীমা।\n    \n    Returns:\n    dict: উচ্চতা এবং প্রস্থের মধ্যে ফিল্টার করা শিক্ষার্থীদের অভিধান।\n    \"\"\"\n    filtered_dct = {}\n    for key, value in dct.items():\n        height = value.get('height')\n        width = value.get('width')\n        if height is not None and n <= height <= n2:\n            filtered_dct[key] = value\n    return filtered_dct\n```"
  },
  {
    "id":123,
    "response":"```python\ndef count_same_pair(lst, lst2):\n    \"\"\"\n    Count the number of pairs that appear in both lists.\n    \n    Args:\n        lst: First list of elements\n        lst2: Second list of elements\n    \n    Returns:\n        int: Number of common pairs (elements that appear in both lists)\n    \"\"\"\n    set1 = set(lst)\n    set2 = set(lst2)\n    return len(set1.intersection(set2))\n```"
  },
  {
    "id":124,
    "response":"```python\ndef power_base_sum(n, n2):\n    \"\"\"\n    বেসের সমস্ত অঙ্কের যোগফলকে নির্দিষ্ট শক্তিতে গণনা করে।\n    \n    উদাহরণ: \n    যদি n = 123 এবং n2 = 2 হয়, তবে বেসের অঙ্কগুলি (1, 2, 3) এর যোগফল 6 হবে,\n    এবং এটি শক্তি n2 = 2 এর জন্য হবে। তাই ফাংশনটি প্রতিটি অঙ্কের যোগফলকে শক্তি দেয়।\n    \n    তবে এখানে বোঝা যায় যে এটি সম্ভবত অস্পষ্ট। সম্ভবত এটি বেসের অঙ্কগুলির যোগফলকে শক্তি দেয়।\n    \n    যেমন: অঙ্কগুলির যোগফল = 1+2+3 = 6, এবং 6^2 = 36 হবে।\n    \n    তাই ফাংশনটি কাজ করবে এভাবে:\n    1. বেসের অঙ্কগুলি ধরে নেয়\n    2. অঙ্কগুলির যোগফল নেয়\n    3. সেই যোগফলকে নির্দিষ্ট শক্তিতে উন্নত করে\n    \"\"\"\n    # বেসের অঙ্কগুলি পাওয়া\n    digits = [int(d) for d in str(n)]\n    \n    # অঙ্কগুলির যোগফল নেয়\n    digit_sum = sum(digits)\n    \n    # যোগফলকে শক্তিতে উন্নত করে\n    result = digit_sum ** n2\n    \n    return result\n```"
  },
  {
    "id":125,
    "response":"```python\nimport re\n\ndef extract_quotation(s):\n    \"\"\"\n    রেজেক্স ব্যবহার করে প্রদত্ত স্ট্রিংয়ের উদ্ধৃতি চিহ্নের মধ্যে মানগুলি বের করে।\n    \n    Args:\n        s (str): প্রদত্ত স্ট্রিং\n        \n    Returns:\n        list: উদ্ধৃতি চিহ্নের মধ্যে মানগুলির একটি তালিকা\n    \"\"\"\n    # উদ্ধৃতি চিহ্নের মধ্যে মানগুলি বের করার জন্য রেজেক্স প্যাটার্ন\n    pattern = r'\"([^\"]*)\"' \n    matches = re.findall(pattern, s)\n    return matches\n```"
  },
  {
    "id":126,
    "response":"```python\ndef multiply_elements(tup):\n    \"\"\"\n    প্রদত্ত টিপলের সংলগ্ন উপাদানগুলিকে গুণ করে একটি সংখ্যা রিটার্ন করে।\n    \n    Args:\n        tup: একটি টিপল যার উপাদানগুলি গুণ করা হবে\n        \n    Returns:\n        টিপলের সকল উপাদানের গুণফল\n        \n    Example:\n        multiply_elements((2, 3, 4)) -> 24\n    \"\"\"\n    result = 1\n    for element in tup:\n        result *= element\n    return result\n```"
  },
  {
    "id":127,
    "response":"```python\nimport re\n\ndef remove_char(s):\n    \"\"\"\n    রেজেক্স ব্যবহার করে অক্ষর এবং সংখ্যা ছাড়া সমস্ত অক্ষর সরানোর জন্য ফাংশন।\n    এটি অক্ষর এবং সংখ্যা ছাড়া শুধুমাত্র অক্ষর সরাবে।\n    তবে প্রশ্নে বলা হয়েছে \"অক্ষর এবং সংখ্যা ছাড়া সমস্ত অক্ষর সরানোর জন্য\" যা অস্পষ্ট।\n    সম্ভবত মানে হয় অক্ষর এবং সংখ্যা ছাড়া অন্যান্য চিহ্ন রাখা।\n    তবে যদি মানে হয় অক্ষর এবং সংখ্যা ছাড়া সব অক্ষর সরানো, তবে এটি অসম্ভব।\n    সম্ভবত মানে হয় অক্ষর এবং সংখ্যা ছাড়া অন্যান্য চিহ্ন রাখা।\n    তাই এখানে অক্ষর এবং সংখ্যা ছাড়া অন্যান্য চিহ্ন রাখা হবে।\n    \"\"\"\n    # অক্ষর এবং সংখ্যা ছাড়া অন্যান্য চিহ্ন রাখা\n    return re.sub(r'[a-zA-Z0-9]', '', s)\n```"
  },
  {
    "id":128,
    "response":"```python\ndef sum_list(lst, lst2):\n    \"\"\"\n    দুটি তালিকার উপাদান যোগ করে একটি নতুন তালিকা তৈরি করে।\n    \n    Args:\n        lst: প্রথম তালিকা\n        lst2: দ্বিতীয় তালিকা\n    \n    Returns:\n        দুটি তালিকার উপাদান যোগের ফলাফল হিসাবে একটি তালিকা\n    \"\"\"\n    return [a + b for a, b in zip(lst, lst2)]\n```"
  },
  {
    "id":129,
    "response":"```python\ndef add_list(lst, lst2):\n    \"\"\"\n    দুটি তালিকা যোগ করে একটি নতুন তালিকা রিটার্ন করে।\n    \n    Args:\n        lst: প্রথম তালিকা\n        lst2: দ্বিতীয় তালিকা\n    \n    Returns:\n        দুটি তালিকার যোগফল হিসাবে একটি তালিকা\n    \"\"\"\n    return lst + lst2\n```"
  },
  {
    "id":130,
    "response":"```python\ndef consecutive_duplicates(lst):\n    \"\"\"\n    Remove consecutive duplicates from a list.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A new list with consecutive duplicates removed\n    \"\"\"\n    if not lst:\n        return []\n    \n    result = [lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i] != lst[i-1]:\n            result.append(lst[i])\n    \n    return result\n```"
  },
  {
    "id":131,
    "response":"```python\ndef lateralsurface_cone(n, n2):\n    \"\"\"\n    Calculate the lateral surface area of a cone.\n    \n    Parameters:\n    n (float): The radius of the base of the cone.\n    n2 (float): The height of the cone.\n    \n    Returns:\n    float: The lateral surface area of the cone.\n    \"\"\"\n    import math\n    # Calculate the slant height of the cone\n    slant_height = math.sqrt(n**2 + n2**2)\n    # Calculate the lateral surface area: π * r * l\n    lateral_area = math.pi * n * slant_height\n    return lateral_area\n```"
  },
  {
    "id":132,
    "response":"```python\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, and periods with colons.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: String with spaces, commas, and periods replaced by colons\n    \"\"\"\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')\n```"
  },
  {
    "id":133,
    "response":"```python\ndef find_first_occurrence(lst, n):\n    \"\"\"\n    সাজানো অ্যারেতে প্রদত্ত সংখ্যার প্রথম উপস্থিতির সূচক খুঁজে পায়।\n    \n    Parameters:\n    lst (list): সাজানো অ্যারে\n    n (int\/float): খুঁজে বের করার সংখ্যা\n    \n    Returns:\n    int: প্রথম উপস্থিতির সূচক, যদি উপস্থিত না থাকে তবে -1 রিটার্ন করে\n    \"\"\"\n    left, right = 0, len(lst) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) \/\/ 2\n        if lst[mid] == n:\n            result = mid\n            right = mid - 1  # আরও প্রথম উপস্থিতি খুঁজে নেব\n        elif lst[mid] < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n```"
  },
  {
    "id":134,
    "response":"```python\ndef sum_Of_Subarray_Prod(lst, n):\n    \"\"\"\n    Calculate the sum of products of all possible subarrays.\n    \n    Args:\n        lst: List of integers\n        n: Length of the list\n    \n    Returns:\n        Sum of products of all subarrays\n    \"\"\"\n    total_sum = 0\n    \n    # Iterate through all possible starting positions\n    for i in range(n):\n        current_product = 1\n        # Iterate through all possible ending positions from i\n        for j in range(i, n):\n            current_product *= lst[j]\n            total_sum += current_product\n    \n    return total_sum\n```"
  },
  {
    "id":135,
    "response":"```python\ndef toggle_middle_bits(n):\n    \"\"\"\n    Toggle all bits of a number except the first and last bits.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The number with middle bits toggled, first and last bits unchanged\n    \"\"\"\n    # Handle edge cases\n    if n == 0:\n        return 0\n    \n    # Get the number of bits in the number\n    bit_length = n.bit_length()\n    \n    # If only 1 bit (i.e., 0 or 1), no middle bits to toggle\n    if bit_length <= 2:\n        return n\n    \n    # Create a mask to toggle middle bits\n    # First bit (MSB) and last bit (LSB) are preserved\n    # All other bits are toggled\n    \n    # Create a mask with all bits set except first and last\n    mask = 0\n    for i in range(1, bit_length - 1):\n        mask |= (1 << i)\n    \n    # Toggle the middle bits using XOR\n    result = n ^ mask\n    \n    return result\n```"
  },
  {
    "id":136,
    "response":"```python\ndef left_insertion(lst, n):\n    \"\"\"\n    একটি নির্দিষ্ট মানের বাম সন্নিবেশ পয়েন্ট সনাক্ত করে।\n    \n    এই ফাংশনটি একটি লিস্টে দেওয়া মান n এর বাম সন্নিবেশ পয়েন্ট (leftmost insertion point) খুঁজে বের করে।\n    বাম সন্নিবেশ পয়েন্ট হল যে স্থানে মানটি যোগ করলে লিস্টটি ক্রমবর্ধমান থাকবে।\n    \n    Parameters:\n    lst (list): ক্রমবর্ধমান লিস্ট\n    n: যোগ করার জন্য মান\n    \n    Returns:\n    int: বাম সন্নিবেশ পয়েন্টের স্থান (0 থেকে শুরু করে)\n    \"\"\"\n    if not lst:\n        return 0\n    \n    left, right = 0, len(lst)\n    \n    while left < right:\n        mid = (left + right) \/\/ 2\n        if lst[mid] < n:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n```"
  },
  {
    "id":137,
    "response":"```python\ndef check_str(s):\n    \"\"\"\n    Check if the given string starts with a vowel.\n    \n    Args:\n        s (str): The string to check.\n        \n    Returns:\n        bool: True if the string starts with a vowel, False otherwise.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    if s and s[0] in vowels:\n        return True\n    return False\n```"
  },
  {
    "id":138,
    "response":"```python\ndef geometric_sum(n):\n    \"\"\"\n    Calculate the geometric sum of n-1 terms with common ratio 1.\n    For a geometric series with ratio 1, the sum is simply n-1.\n    \n    Args:\n        n (int): The number of terms (n-1 terms are summed)\n    \n    Returns:\n        int: The sum of the geometric series\n    \"\"\"\n    if n <= 1:\n        return 0\n    return n - 1\n```"
  },
  {
    "id":139,
    "response":"```python\ndef find_Index(n):\n    \"\"\"\n    Find the smallest triangular number with n digits.\n    \n    A triangular number is of the form T_k = k*(k+1)\/2.\n    This function finds the smallest k such that T_k has at least n digits.\n    \n    Args:\n        n (int): Number of digits required in the triangular number\n        \n    Returns:\n        int: The index k such that T_k is the smallest triangular number with n digits\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # We need to find the smallest k such that k*(k+1)\/2 >= 10^(n-1)\n    # This means k^2 + k >= 2*10^(n-1)\n    # Solving the quadratic inequality: k >= (-1 + sqrt(1 + 8*10^(n-1))) \/ 2\n    \n    # Calculate the minimum k using the quadratic formula\n    min_value = 10 ** (n - 1)\n    k = int((-1 + (1 + 8 * min_value) ** 0.5) \/ 2)\n    \n    # Ensure we have at least n digits, so we might need to increment\n    while k * (k + 1) \/\/ 2 < min_value:\n        k += 1\n        \n    return k\n```"
  },
  {
    "id":140,
    "response":"```python\ndef tuple_to_dict(tup):\n    \"\"\"\n    দেওয়া টিপলকে সংলগ্ন উপাদান ব্যবহার করে একটি কী-মান অভিধানে রূপান্তর করে।\n    \n    যদি টিপলের উপাদানগুলি জোড়া (key, value) হয়, তবে এটি একটি ডিকশনারি তৈরি করে।\n    \n    Args:\n        tup: কী-মান জোড়া বা সংলগ্ন উপাদান বিশিষ্ট টিপল\n        \n    Returns:\n        dict: রূপান্তরিত কী-মান অভিধান\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    \n    result = {}\n    for i in range(0, len(tup), 2):\n        if i + 1 < len(tup):\n            result[tup[i]] = tup[i + 1]\n        else:\n            # যদি টিপলের সংখ্যা জোড় হয় না, তবে একটি মান বাদ দেওয়া হবে\n            pass\n    \n    return result\n```"
  },
  {
    "id":141,
    "response":"```python\ndef all_characters_same(s):\n    \"\"\"\n    Check if all characters in the string are the same.\n    \n    Args:\n        s (str): The input string to check.\n    \n    Returns:\n        bool: True if all characters are the same, False otherwise.\n    \"\"\"\n    if len(s) <= 1:\n        return True\n    \n    return all(char == s[0] for char in s)\n```"
  },
  {
    "id":142,
    "response":"```python\nimport math\n\ndef area_tetrahedron(n):\n    \"\"\"\n    একটি টেট্রাহেড্রনের ক্ষেত্রফল নির্ণয়ের জন্য ফাংশন।\n    \n    এই ফাংশনটি একটি সমবাহু টেট্রাহেড্রনের ক্ষেত্রফল নির্ণয় করে, \n    যার প্রতিটি ফালের দৈর্ঘ্য n।\n    \n    সমবাহু টেট্রাহেড্রনের একটি ফালের ক্ষেত্রফল = (√3\/4) * n²\n    টেট্রাহেড্রনের মোট ক্ষেত্রফল = 4 * একটি ফালের ক্ষেত্রফল\n    \n    Parameters:\n    n (float): টেট্রাহেড্রনের প্রতিটি ফালের দৈর্ঘ্য\n    \n    Returns:\n    float: টেট্রাহেড্রনের মোট ক্ষেত্রফল\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"দৈর্ঘ্য শূন্য বা নেগেটিভ হওয়া উচিত নয়।\")\n    \n    face_area = (math.sqrt(3) \/ 4) * n * n\n    total_area = 4 * face_area\n    \n    return total_area\n```"
  },
  {
    "id":143,
    "response":"```python\ndef rotate_right(lst, n, n2):\n    \"\"\"\n    Rotate a list to the right by n positions, with n2 as an optional parameter.\n    If n2 is provided, it may be used for additional logic (e.g., modulo operation).\n    \n    Args:\n        lst: List to be rotated\n        n: Number of positions to rotate right\n        n2: Optional parameter (can be used for additional logic)\n    \n    Returns:\n        Rotated list\n    \"\"\"\n    if not lst:\n        return lst\n    \n    # Use n2 if provided, otherwise use n\n    positions = n % len(lst) if n2 is None else n2 % len(lst)\n    \n    # Perform right rotation\n    return lst[-positions:] + lst[:-positions]\n```"
  },
  {
    "id":144,
    "response":"```python\ndef check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n    \n    Args:\n        tup: A tuple to check for None values.\n        \n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in tup\n```"
  },
  {
    "id":145,
    "response":"```python\ndef divisible_by_digits(n, n2):\n    \"\"\"\n    Check if a number in the range [n, n2] is divisible by each of its digits.\n    \n    Args:\n        n (int): The start of the range (inclusive).\n        n2 (int): The end of the range (inclusive).\n    \n    Returns:\n        list: A list of numbers in the range [n, n2] that are divisible by each of their digits.\n    \"\"\"\n    result = []\n    \n    for num in range(n, n2 + 1):\n        # Convert number to string to access individual digits\n        num_str = str(num)\n        \n        # Skip numbers containing 0 (division by zero)\n        if '0' in num_str:\n            continue\n            \n        # Check if the number is divisible by each of its digits\n        is_divisible = True\n        for digit_char in num_str:\n            digit = int(digit_char)\n            if num % digit != 0:\n                is_divisible = False\n                break\n                \n        if is_divisible:\n            result.append(num)\n    \n    return result\n```"
  },
  {
    "id":146,
    "response":"```python\ndef sector_area(n, n2):\n    \"\"\"\n    Calculate the area of a sector given the radius and angle in degrees.\n    \n    Parameters:\n    n (float): Radius of the circle\n    n2 (float): Central angle of the sector in degrees\n    \n    Returns:\n    float: Area of the sector\n    \"\"\"\n    import math\n    \n    # Convert angle from degrees to radians\n    angle_rad = math.radians(n2)\n    \n    # Calculate sector area using formula: (theta\/360) * pi * r^2\n    area = (angle_rad \/ (2 * math.pi)) * math.pi * n ** 2\n    \n    return area\n```"
  },
  {
    "id":147,
    "response":"```python\ndef lcs_of_three(s, s2, s3):\n    \"\"\"\n    Find the longest common subsequence (LCS) of three strings.\n    \n    Args:\n        s (str): First string\n        s2 (str): Second string\n        s3 (str): Third string\n    \n    Returns:\n        str: The longest common subsequence of the three strings\n    \"\"\"\n    m, n, p = len(s), len(s2), len(s3)\n    \n    # Create a 3D DP table to store LCS lengths\n    # dp[i][j][k] represents the length of LCS of s[0:i], s2[0:j], s3[0:k]\n    dp = [[[0 for _ in range(p + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, p + 1):\n                if s[i-1] == s2[j-1] == s3[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(\n                        dp[i-1][j][k],\n                        dp[i][j-1][k],\n                        dp[i][j][k-1]\n                    )\n    \n    # Reconstruct the LCS string\n    result = []\n    i, j, k = m, n, p\n    while i > 0 and j > 0 and k > 0:\n        if s[i-1] == s2[j-1] == s3[k-1]:\n            result.append(s[i-1])\n            i -= 1\n            j -= 1\n            k -= 1\n        elif dp[i-1][j][k] >= dp[i][j-1][k] and dp[i-1][j][k] >= dp[i][j][k-1]:\n            i -= 1\n        elif dp[i][j-1][k] >= dp[i-1][j][k] and dp[i][j-1][k] >= dp[i][j][k-1]:\n            j -= 1\n        else:\n            k -= 1\n    \n    # Reverse the result since we built it backwards\n    result.reverse()\n    \n    return ''.join(result) if result else \"\"\n```"
  },
  {
    "id":148,
    "response":"```python\ndef capital_words_spaces(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিং-এ বড় অক্ষর দিয়ে শুরু হওয়া শব্দের মধ্যে স্পেস রাখে।\n    \n    Args:\n        s (str): প্রদত্ত স্ট্রিং\n        \n    Returns:\n        str: বড় অক্ষর দিয়ে শুরু হওয়া শব্দের মধ্যে স্পেস রাখা স্ট্রিং\n    \"\"\"\n    result = []\n    i = 0\n    while i < len(s):\n        if s[i].isupper():\n            if result:\n                result.append(' ')\n            result.append(s[i])\n            i += 1\n        else:\n            result.append(s[i])\n            i += 1\n    return ''.join(result)\n```"
  },
  {
    "id":149,
    "response":"```python\ndef sort_numeric_strings(lst):\n    \"\"\"\n    Sort a list of strings that represent numbers in numerical order.\n    \n    Args:\n        lst (list): A list of strings representing numbers.\n    \n    Returns:\n        list: A list of strings sorted in numerical order.\n    \"\"\"\n    def parse_number(s):\n        \"\"\"Convert string to number for comparison.\"\"\"\n        return float(s)\n    \n    return sorted(lst, key=parse_number)\n```"
  },
  {
    "id":150,
    "response":"```python\ndef add_tuple(lst, tup):\n    \"\"\"\n    প্রদত্ত তালিকায় প্রদত্ত টিউপেল যোগ করে।\n    \n    প্রদত্ত টিউপেল তালিকার প্রতিটি উপাদানের সাথে যুক্ত করে এবং নতুন তালিকা প্রদান করে।\n    \n    Parameters:\n    lst (list): যোগ করার জন্য তালিকা\n    tup (tuple): যোগ করা হবে টিউপেল\n    \n    Returns:\n    list: যোগ করা তালিকা\n    \"\"\"\n    return lst + list(tup)\n```"
  },
  {
    "id":151,
    "response":"```python\ndef check_min_heap(lst, n):\n    \"\"\"\n    Check if the given list represents a min heap.\n    \n    A min heap property requires that for every node at index i:\n    - lst[i] <= lst[2*i + 1] (left child)\n    - lst[i] <= lst[2*i + 2] (right child)\n    \n    Args:\n        lst: List representing the heap (0-indexed)\n        n: Number of elements in the heap\n    \n    Returns:\n        True if the list represents a min heap, False otherwise\n    \"\"\"\n    # Check each node from 0 to (n-2)\/\/2 (last non-leaf node)\n    for i in range((n \/\/ 2) - 1):\n        left_child = 2 * i + 1\n        right_child = 2 * i + 2\n        \n        # Check if current node is less than or equal to both children\n        if left_child < n and lst[i] > lst[left_child]:\n            return False\n        if right_child < n and lst[i] > lst[right_child]:\n            return False\n    \n    return True\n```"
  },
  {
    "id":152,
    "response":"```python\ndef jacobsthal_num(n):\n    \"\"\"\n    Calculate the nth Jacobsthal number.\n    \n    The Jacobsthal numbers are defined by the recurrence relation:\n    J(0) = 0, J(1) = 1, J(n) = J(n-1) + 2*J(n-2) for n >= 2.\n    \n    Args:\n        n (int): The index of the Jacobsthal number to compute (non-negative integer)\n    \n    Returns:\n        int: The nth Jacobsthal number\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for i in range(2, n + 1):\n        a, b = b, a + 2 * b\n    \n    return b\n```"
  },
  {
    "id":153,
    "response":"```python\ndef min_k(lst, k):\n    \"\"\"\n    টুপল তালিকা থেকে সর্বনিম্ন k রেকর্ড পাওয়া যায়।\n    \n    প্যারামিটার:\n    lst: টুপল তালিকা (যেমন: ((1,2), (3,4), (5,6), ...))\n    k: সর্বনিম্ন রেকর্ডের সংখ্যা\n    \n    রিটার্ন:\n    সর্বনিম্ন k রেকর্ডের একটি টুপল তালিকা\n    \"\"\"\n    if k <= 0:\n        return ()\n    \n    # টুপল তালিকার প্রতিটি রেকর্ডের প্রথম উপাদান ব্যবহার করে সর্বনিম্ন করা হবে\n    # যদি কোন উপাদান না থাকে তবে কিছু রেকর্ড নেয়া যাবে না\n    if not lst:\n        return ()\n    \n    # প্রতিটি রেকর্ডের প্রথম উপাদান নেয়া হয়\n    first_elements = [item[0] for item in lst]\n    \n    # সর্বনিম্ন k উপাদান নেয়া হয়\n    sorted_first = sorted(first_elements)[:k]\n    \n    # সর্বনিম্ন k রেকর্ড পাওয়া হয়\n    result = []\n    for item in lst:\n        if item[0] in sorted_first:\n            result.append(item)\n    \n    # সর্বনিম্ন k রেকর্ড প্রতিটি রেকর্ডের প্রথম উপাদান অনুসারে সাজানো হয়\n    result.sort(key=lambda x: x[0])\n    \n    return tuple(result)\n```"
  },
  {
    "id":154,
    "response":"```python\ndef extract_index_list(lst1, lst2, lst3):\n    \"\"\"\n    Find common elements across three lists and return their indices in the first list.\n    \n    Args:\n        lst1, lst2, lst3: Three lists to compare\n        \n    Returns:\n        List of indices from lst1 where elements are present in all three lists\n    \"\"\"\n    # Create sets of elements for efficient lookup\n    set2 = set(lst2)\n    set3 = set(lst3)\n    \n    # Find common elements across all three lists\n    common_elements = set(lst1) & set2 & set3\n    \n    # Return indices of common elements in lst1\n    indices = []\n    for i, element in enumerate(lst1):\n        if element in common_elements:\n            indices.append(i)\n    \n    return indices\n```"
  },
  {
    "id":155,
    "response":"```python\ndef second_smallest(lst):\n    \"\"\"\n    একটি তালিকার দ্বিতীয় ক্ষুদ্রতম সংখ্যা খুঁজে বের করে।\n    \n    Args:\n        lst: একটি সংখ্যা বিশিষ্ট তালিকা\n        \n    Returns:\n        দ্বিতীয় ক্ষুদ্রতম সংখ্যা, যদি দ্বিতীয় ক্ষুদ্রতম সংখ্যা না থাকে তবে None রিটার্ন করে।\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # সংখ্যাগুলি ক্রমানুসারে সাজানো\n    unique_sorted = sorted(set(lst))\n    \n    # দ্বিতীয় ক্ষুদ্রতম সংখ্যা থাকলে ফিরে আসা\n    if len(unique_sorted) >= 2:\n        return unique_sorted[1]\n    else:\n        return None\n```"
  },
  {
    "id":156,
    "response":"```python\ndef text_match_zero_one(s):\n    \"\"\"\n    Check if a string contains either a '0' or a 'b' (case-sensitive).\n    \n    Args:\n        s (str): The input string to check.\n    \n    Returns:\n        bool: True if the string contains '0' or 'b', False otherwise.\n    \"\"\"\n    return '0' in s or 'b' in s\n```"
  },
  {
    "id":157,
    "response":"```python\ndef count_reverse_pairs(lst):\n    \"\"\"\n    Count the number of reverse pairs in a list of strings.\n    A reverse pair consists of two strings where one is the reverse of the other.\n    \n    Args:\n        lst: List of strings\n        \n    Returns:\n        int: Number of reverse pairs\n    \"\"\"\n    if not lst or len(lst) < 2:\n        return 0\n    \n    count = 0\n    n = len(lst)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    \n    return count\n```"
  },
  {
    "id":158,
    "response":"```python\ndef unique_sublists(lst):\n    \"\"\"\n    Count the number of unique sublists in a given list.\n    \n    Args:\n        lst: A list of lists (sublists)\n    \n    Returns:\n        int: The number of unique sublists\n    \"\"\"\n    if not lst:\n        return 0\n    \n    # Convert each sublist to a tuple (hashable) and use a set to store unique ones\n    unique_sublists_set = set()\n    for sublist in lst:\n        # Convert sublist to tuple for hashing\n        unique_sublists_set.add(tuple(sublist))\n    \n    return len(unique_sublists_set)\n```"
  },
  {
    "id":159,
    "response":"```python\ndef is_decimal(s):\n    \"\"\"\n    Check if a string represents a decimal number with 2 decimal places.\n    \n    Args:\n        s (str): The string to check.\n        \n    Returns:\n        bool: True if the string represents a decimal number with exactly 2 decimal places, False otherwise.\n    \"\"\"\n    # Remove leading\/trailing whitespace\n    s = s.strip()\n    \n    # Check if string is empty\n    if not s:\n        return False\n    \n    # Check if string contains only digits and at most one decimal point\n    if '.' not in s:\n        return False\n    \n    parts = s.split('.')\n    \n    # Must have exactly two parts: integer and decimal\n    if len(parts) != 2:\n        return False\n    \n    integer_part, decimal_part = parts\n    \n    # Integer part should be non-negative and contain only digits\n    if not integer_part or not integer_part.isdigit():\n        return False\n    \n    # Decimal part should have exactly 2 digits\n    if len(decimal_part) != 2 or not decimal_part.isdigit():\n        return False\n    \n    return True\n```"
  },
  {
    "id":160,
    "response":"```python\ndef unique_element(lst, n):\n    \"\"\"\n    Check if there is exactly one unique element in the array.\n    \n    Args:\n        lst: List of elements to check\n        n: Size of the list (optional, for clarity)\n    \n    Returns:\n        True if there is exactly one unique element, False otherwise\n    \"\"\"\n    # Count frequency of each element\n    freq = {}\n    for element in lst:\n        freq[element] = freq.get(element, 0) + 1\n    \n    # Check if exactly one element has frequency 1 (unique)\n    unique_count = sum(1 for count in freq.values() if count == 1)\n    \n    return unique_count == 1\n```"
  },
  {
    "id":161,
    "response":"```python\nimport math\n\ndef arc_length(r, theta):\n    \"\"\"\n    Calculate the arc length of a circle given radius and central angle in radians.\n    \n    Parameters:\n    r (float): radius of the circle\n    theta (float): central angle in radians\n    \n    Returns:\n    float: arc length\n    \"\"\"\n    return r * theta\n```"
  },
  {
    "id":162,
    "response":"```python\ndef check_month_number(n):\n    \"\"\"\n    Check if the given month number has 30 days.\n    \n    Args:\n        n (int): The month number (1-12)\n    \n    Returns:\n        bool: True if the month has 30 days, False otherwise\n    \"\"\"\n    # Months with 30 days: April (4), June (6), September (9), November (11)\n    months_with_30_days = {4, 6, 9, 11}\n    \n    return n in months_with_30_days\n```"
  },
  {
    "id":163,
    "response":"```python\ndef find_Min_Diff(arr, n):\n    \"\"\"\n    Find the minimum difference between any two elements in an array.\n    \n    Args:\n        arr: List of integers\n        n: Length of the array\n    \n    Returns:\n        Integer representing the minimum difference between any two elements\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    # Sort the array to make it easier to find minimum difference\n    arr.sort()\n    \n    min_diff = float('inf')\n    \n    # Check difference between adjacent elements after sorting\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        min_diff = min(min_diff, diff)\n    \n    return min_diff\n```"
  },
  {
    "id":164,
    "response":"```python\ndef number_ctr(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিং-এ সংখ্যাসূচক মান (0-9) গণনা করে ফেরত দেয়।\n    \n    Args:\n        s (str): স্ট্রিং ইনপুট\n        \n    Returns:\n        int: সংখ্যাসূচক মানের সংখ্যা\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count\n```"
  },
  {
    "id":165,
    "response":"```python\ndef is_polite(n):\n    \"\"\"\n    Check if a number n is a polite number.\n    A polite number is a positive integer that can be written as the sum of two or more consecutive positive integers.\n    \n    Args:\n        n (int): The number to check.\n        \n    Returns:\n        bool: True if n is a polite number, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    # A number is polite if and only if it is not a power of 2\n    # Powers of 2 cannot be expressed as sum of consecutive positive integers\n    # This is because powers of 2 have only one odd divisor (1)\n    # All other numbers have at least one odd divisor greater than 1\n    \n    # Check if n is a power of 2\n    # A number is a power of 2 if (n & (n-1)) == 0\n    return (n & (n - 1)) != 0\n```"
  },
  {
    "id":166,
    "response":"```python\ndef pair_wise(lst):\n    \"\"\"\n    Return a list of tuples containing consecutive pairs from the input list.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A list of tuples where each tuple contains two consecutive elements from the input list\n    \"\"\"\n    if len(lst) <= 1:\n        return []\n    \n    result = []\n    for i in range(len(lst) - 1):\n        result.append((lst[i], lst[i + 1]))\n    \n    return result\n```"
  },
  {
    "id":167,
    "response":"```python\ndef get_Pairs_Count(lst, sum_val):\n    \"\"\"\n    জোড়ার সংখ্যা গণনা করে যার যোগফল sum_val এর সমান।\n    \n    Parameters:\n    lst (list of int): সংখ্যা গুলির একটি তালিকা\n    sum_val (int): যোগফল যা পাওয়া হবে\n    \n    Returns:\n    int: যোগফল sum_val এর সমান জোড়ার সংখ্যা\n    \"\"\"\n    count = 0\n    n = len(lst)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if lst[i] + lst[j] == sum_val:\n                count += 1\n    \n    return count\n```"
  },
  {
    "id":168,
    "response":"```python\ndef check_Odd_Parity(n):\n    \"\"\"\n    Check if a number has odd parity (i.e., has an odd number of 1s in its binary representation).\n    \n    Args:\n        n (int): The integer to check for odd parity.\n    \n    Returns:\n        bool: True if the number has odd parity, False otherwise.\n    \"\"\"\n    # Count the number of 1s in the binary representation\n    ones_count = bin(n).count('1')\n    \n    # Return True if the count is odd, False if even\n    return ones_count % 2 == 1\n```"
  },
  {
    "id":169,
    "response":"```python\ndef diff(lst, lst2):\n    \"\"\"\n    Return the difference between two lists.\n    Returns elements that are in the first list but not in the second list.\n    \n    Args:\n        lst: First list\n        lst2: Second list\n    \n    Returns:\n        List containing elements that are in lst but not in lst2\n    \"\"\"\n    return [item for item in lst if item not in lst2]\n```"
  },
  {
    "id":170,
    "response":"```python\ndef odd_Num_Sum(n):\n    \"\"\"\n    প্রথম n অদ্ভুত প্রাকৃতিক সংখ্যার চতুর্থ ক্ষমতার যোগফল খুঁজে বের করে।\n    \n    অদ্ভুত প্রাকৃতিক সংখ্যা হল অযোগ্য সংখ্যা, যেমন 1, 3, 5, 7, 9, ...\n    \n    Parameters:\n    n (int): প্রথম n অদ্ভুত সংখ্যা নির্দেশ করে।\n    \n    Returns:\n    int: প্রথম n অদ্ভুত সংখ্যার চতুর্থ ক্ষমতা (n^4) এর যোগফল।\n    \"\"\"\n    total = 0\n    for i in range(n):\n        odd_num = 2 * i + 1\n        total += odd_num ** 4\n    return total\n```"
  },
  {
    "id":171,
    "response":"```python\ndef check_expression(s):\n    \"\"\"\n    Check if the given expression is balanced (has matching parentheses, brackets, and braces).\n    \n    Args:\n        s (str): The expression string to check.\n    \n    Returns:\n        bool: True if the expression is balanced, False otherwise.\n    \"\"\"\n    stack = []\n    # Define mapping of closing to opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        # If it's an opening bracket, push to stack\n        if char in '({[':\n            stack.append(char)\n        # If it's a closing bracket\n        elif char in ')}]':\n            # If stack is empty or the top doesn't match, it's unbalanced\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    \n    # If stack is empty, all brackets were matched\n    return len(stack) == 0\n```"
  },
  {
    "id":172,
    "response":"```python\ndef remove_length(s, k):\n    \"\"\"\n    প্রদত্ত স্ট্রিংয়ের k দৈর্ঘ্যের সমস্ত শব্দকে সরিয়ে দেয়।\n    \n    এই ফাংশনটি স্ট্রিংয়ের সব শব্দকে পরিমাপ করে এবং যার দৈর্ঘ্য k হয় সেগুলি সরিয়ে দেয়।\n    \n    Parameters:\n    s (str): প্রদত্ত স্ট্রিং\n    k (int): দৈর্ঘ্যের মান যার শব্দগুলি সরাবে\n    \n    Returns:\n    str: k দৈর্ঘ্যের শব্দগুলি সরিয়ে দেওয়া স্ট্রিং\n    \"\"\"\n    words = s.split()\n    filtered_words = [word for word in words if len(word) != k]\n    return ' '.join(filtered_words)\n```"
  },
  {
    "id":173,
    "response":"```python\ndef occurrence_substring(s, s2):\n    \"\"\"\n    একটি স্ট্রিংয়ের মধ্যে অন্য একটি স্ট্রিং (সাবস্ট্রিং) এর উপস্থিতি এবং অবস্থান খুঁজে পায়।\n    \n    Parameters:\n    s (str): মূল স্ট্রিং\n    s2 (str): সাবস্ট্রিং (অন্তর্ভুক্ত হওয়া স্ট্রিং)\n    \n    Returns:\n    list: সাবস্ট্রিং এর সব অবস্থান (ইনডেক্স) এর একটি লিস্ট। যদি সাবস্ট্রিং না থাকে তবে একটি খালি লিস্ট রিটার্ন হবে।\n    \"\"\"\n    positions = []\n    start = 0\n    \n    while True:\n        pos = s.find(s2, start)\n        if pos == -1:\n            break\n        positions.append(pos)\n        start = pos + 1\n    \n    return positions\n```"
  },
  {
    "id":174,
    "response":"```python\ndef check_email(s):\n    \"\"\"\n    Check if a string is a valid email address without using regular expressions.\n    \n    Args:\n        s (str): The string to validate as an email address.\n    \n    Returns:\n        bool: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Check if the string is empty or None\n    if not s or not isinstance(s, str):\n        return False\n    \n    # Split the string by '@' to get local and domain parts\n    parts = s.split('@')\n    \n    # Must have exactly one '@' symbol\n    if len(parts) != 2:\n        return False\n    \n    local, domain = parts\n    \n    # Both local and domain parts must be non-empty\n    if not local or not domain:\n        return False\n    \n    # Domain must contain at least one dot\n    if '.' not in domain:\n        return False\n    \n    # Domain must have at least one character before and after the dot\n    domain_parts = domain.split('.')\n    if len(domain_parts) < 2:\n        return False\n    \n    # Check that domain parts are not empty\n    for part in domain_parts:\n        if not part:\n            return False\n    \n    # Local part can contain letters, digits, dots, underscores, and hyphens\n    # But cannot start or end with a dot or hyphen\n    if local.startswith('.') or local.endswith('.'):\n        return False\n    if local.startswith('-') or local.endswith('-'):\n        return False\n    \n    # Check for valid characters in local part\n    for char in local:\n        if not (char.isalnum() or char in '._-'):\n            return False\n    \n    # Domain part must not start or end with a dot\n    if domain.startswith('.') or domain.endswith('.'):\n        return False\n    \n    # Domain part must not have consecutive dots\n    if '..' in domain:\n        return False\n    \n    # Domain part must have at least one valid segment\n    return True\n```"
  },
  {
    "id":175,
    "response":"```python\ndef odd_position(lst):\n    \"\"\"\n    Check if every element at an odd position (1-indexed) in the list is odd.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        bool: True if every element at odd positions (1-indexed) is odd, False otherwise\n    \"\"\"\n    # Iterate through the list, checking elements at odd positions (1-indexed)\n    # In 0-indexed terms, odd positions are at indices 1, 3, 5, ...\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:  # If the element at odd position is even\n            return False\n    return True\n```"
  },
  {
    "id":176,
    "response":"```python\ndef count_vowels(s):\n    \"\"\"\n    Count the number of vowels in a given string.\n    \n    Args:\n        s (str): The input string to count vowels in.\n    \n    Returns:\n        int: The number of vowels in the string.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count\n```"
  },
  {
    "id":177,
    "response":"```python\ndef find_Sum(lst, n):\n    \"\"\"\n    প্রদত্ত অ্যারেতে পুনরাবৃত্তি না হওয়া উপাদানগুলির যোগফল খুঁজে পায়।\n    \n    প্রাথমিক ধারণা: যদি অ্যারেতে কোন উপাদান পুনরাবৃত্তি হয়, তবে তা একবার শুধুমাত্র গণনা করা হবে।\n    \n    Parameters:\n    lst (list): প্রদত্ত অ্যারে\n    n (int): অ্যারের দৈর্ঘ্য\n    \n    Returns:\n    int: পুনরাবৃত্তি না হওয়া উপাদানগুলির যোগফল\n    \"\"\"\n    seen = set()\n    total_sum = 0\n    \n    for num in lst:\n        if num not in seen:\n            seen.add(num)\n            total_sum += num\n    \n    return total_sum\n```"
  },
  {
    "id":178,
    "response":"```python\ndef pack_consecutive_duplicates(lst):\n    \"\"\"\n    Pack consecutive duplicate elements in a list into sublists.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A list of sublists, where each sublist contains consecutive duplicate elements\n    \"\"\"\n    if not lst:\n        return []\n    \n    result = []\n    current_group = [lst[0]]\n    \n    for i in range(1, len(lst)):\n        if lst[i] == lst[i-1]:\n            current_group.append(lst[i])\n        else:\n            result.append(current_group)\n            current_group = [lst[i]]\n    \n    # Don't forget the last group\n    result.append(current_group)\n    \n    return result\n```"
  },
  {
    "id":179,
    "response":"```python\ndef unique_sublists(lst):\n    \"\"\"\n    একটি তালিকার মধ্যে অনন্য তালিকার সংখ্যা গণনা করে।\n    \n    এই ফাংশনটি দেয় যে কতগুলো অনন্য তালিকা (sublist) থাকে যা তালিকার মধ্যে অবস্থিত।\n    এটি সাধারণত তালিকার সব সম্ভাব্য উপসমূহ (sublists) গণনা করে এবং যেগুলো অনন্য হয় তাদের সংখ্যা দেয়।\n    \n    Parameters:\n    lst (list): যে তালিকার অনন্য উপসমূহ গণনা করা হবে।\n    \n    Returns:\n    int: অনন্য উপসমূহের সংখ্যা।\n    \"\"\"\n    if not lst:\n        return 0\n    \n    # সব উপসমূহ তৈরি করা হয়\n    sublists = []\n    n = len(lst)\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            sublists.append(lst[i:j])\n    \n    # অনন্য উপসমূহ কে সেটে রাখা হয়\n    unique_sublists_set = set(tuple(sublist) for sublist in sublists)\n    \n    return len(unique_sublists_set)\n```"
  },
  {
    "id":180,
    "response":"```python\ndef find_combinations(lst):\n    \"\"\"\n    Find all possible combinations of tuples from the given list of tuples.\n    \n    Args:\n        lst: A list of tuples\n        \n    Returns:\n        A list of tuples, where each tuple represents a combination of elements\n        from the original list.\n    \"\"\"\n    from itertools import combinations\n    \n    result = []\n    n = len(lst)\n    \n    # Generate all possible combinations of the tuples\n    for r in range(1, n + 1):\n        for combo in combinations(lst, r):\n            result.append(combo)\n    \n    return result\n```"
  },
  {
    "id":181,
    "response":"```python\ndef count_divisors(n):\n    \"\"\"\n    একটি সংখ্যার বিভাজকগুলির সংখ্যা গণন করে এবং তা জোড় কিনা অজোড় কিনা চেক করে।\n    \n    Parameters:\n    n (int): বিভাজকগুলির জন্য দেওয়া সংখ্যা\n    \n    Returns:\n    str: \"জোড়\" অথবা \"অজোড়\" যদি বিভাজকের সংখ্যা জোড় অথবা অজোড় হয়\n    \"\"\"\n    if n <= 0:\n        return \"অজোড়\"\n    \n    # বিভাজকগুলির সংখ্যা গণন করা\n    divisor_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                divisor_count += 1  # পূর্ণবর্গ হলে একবার গণনা\n            else:\n                divisor_count += 2  # দুটি বিভাজক হয় (i এবং n\/\/i)\n    \n    # বিভাজকের সংখ্যা জোড় কিনা চেক\n    if divisor_count % 2 == 0:\n        return \"জোড়\"\n    else:\n        return \"অজোড়\"\n```"
  },
  {
    "id":182,
    "response":"```python\ndef Odd_Length_Sum(lst):\n    \"\"\"\n    Calculate the sum of all subarray sums where the subarray length is odd.\n    \n    Args:\n        lst: List of integers\n        \n    Returns:\n        int: Sum of all subarray sums with odd lengths\n    \"\"\"\n    total_sum = 0\n    n = len(lst)\n    \n    # Iterate through all possible odd lengths\n    for length in range(1, n + 1, 2):  # 1, 3, 5, ... (odd numbers)\n        # For each odd length, iterate through all possible starting positions\n        for start in range(n - length + 1):\n            # Calculate sum of subarray from start to start + length - 1\n            subarray_sum = sum(lst[start:start + length])\n            total_sum += subarray_sum\n    \n    return total_sum\n```"
  },
  {
    "id":183,
    "response":"```python\ndef rgb_to_hsv(r, g, b):\n    \"\"\"\n    Convert RGB color to HSV color.\n    \n    Parameters:\n    r, g, b: Integers from 0 to 255 representing the red, green, and blue components.\n    \n    Returns:\n    A tuple (h, s, v) where:\n    - h is the hue in degrees (0-360)\n    - s is the saturation (0-100)\n    - v is the value (0-100)\n    \"\"\"\n    # Normalize RGB values to 0-1 range\n    r, g, b = r \/ 255.0, g \/ 255.0, b \/ 255.0\n    \n    # Find maximum and minimum values\n    max_val = max(r, g, b)\n    min_val = min(r, g, b)\n    diff = max_val - min_val\n    \n    # Calculate value (V)\n    v = max_val * 100\n    \n    # If all values are equal, saturation is 0\n    if diff == 0:\n        h = 0\n        s = 0\n    else:\n        # Calculate saturation (S)\n        s = (diff \/ max_val) * 100\n        \n        # Calculate hue (H)\n        if max_val == r:\n            h = (60 * ((g - b) \/ diff) % 6)\n        elif max_val == g:\n            h = (60 * ((b - r) \/ diff) + 2)\n        else:  # max_val == b\n            h = (60 * ((r - g) \/ diff) + 4)\n    \n    return (h, s, v)\n```"
  },
  {
    "id":184,
    "response":"```python\ndef mul_even_odd(lst):\n    \"\"\"\n    Find the product of the first even number and the first odd number in the list.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        The product of the first even and first odd number, or None if either\n        even or odd number is not found.\n    \"\"\"\n    even_found = False\n    odd_found = False\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0:\n            if not even_found:\n                first_even = num\n                even_found = True\n        else:\n            if not odd_found:\n                first_odd = num\n                odd_found = True\n                \n        # Early exit if both even and odd found\n        if even_found and odd_found:\n            break\n    \n    if even_found and odd_found:\n        return first_even * first_odd\n    else:\n        return None\n```"
  },
  {
    "id":185,
    "response":"```python\ndef tuple_str_int(s):\n    \"\"\"\n    একটি স্ট্রিং টুপল পূর্ণসংখ্যা টুপলে রূপান্তর করে।\n    \n    প্যারামিটার:\n    s (tuple of str): স্ট্রিং টুপল\n    \n    রিটার্ন:\n    tuple of int: পূর্ণসংখ্যা টুপল\n    \"\"\"\n    return tuple(int(x) for x in s)\n```"
  },
  {
    "id":186,
    "response":"```python\ndef right_insertion(lst, n):\n    \"\"\"\n    একটি নির্দিষ্ট মানের জন্য সঠিক সন্নিবেশ পয়েন্ট সনাক্ত করে।\n    \n    প্রদত্ত তালিকার মধ্যে দেওয়া মানের সাথে সংযোগ করে সঠিক স্থান খুঁজে বের করে।\n    যদি মানটি তালিকার মধ্যে না থাকে, তবে সেটি তালিকার শেষে যোগ করা হবে।\n    \n    Parameters:\n    lst (list): সংখ্যা বিশিষ্ট তালিকা\n    n (int\/float): সন্নিবেশ করার জন্য মান\n    \n    Returns:\n    int: সঠিক সন্নিবেশ পয়েন্ট (0 থেকে শুরু করে শেষ পয়েন্ট পর্যন্ত)\n    \"\"\"\n    # তালিকার মধ্যে মানটি অবস্থিত কিনা চেক করা হবে\n    if n in lst:\n        return lst.index(n)\n    \n    # যদি মানটি তালিকার মধ্যে না থাকে, তবে শেষে যোগ করা হবে\n    # সন্নিবেশ পয়েন্ট হবে শেষের পয়েন্ট\n    return len(lst)\n```"
  },
  {
    "id":187,
    "response":"```python\ndef text_match_three(s):\n    \"\"\"\n    Check if a string contains 'a' followed by exactly three 'b's.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if 'a' is followed by 'bbb', otherwise False.\n    \"\"\"\n    return 'abb' in s\n```"
  },
  {
    "id":188,
    "response":"```python\ndef new_tuple(lst, s):\n    \"\"\"\n    Create a new tuple by combining elements from the list and string.\n    \n    Args:\n        lst: A list of elements\n        s: A string\n    \n    Returns:\n        A tuple containing all elements from the list followed by each character of the string\n    \"\"\"\n    return tuple(lst + list(s))\n```"
  },
  {
    "id":189,
    "response":"```python\ndef perimeter_polygon(n, side_length):\n    \"\"\"\n    Calculate the perimeter of a regular polygon.\n    \n    Args:\n        n (int): Number of sides of the polygon\n        side_length (float): Length of each side\n    \n    Returns:\n        float: Perimeter of the regular polygon\n    \"\"\"\n    return n * side_length\n```"
  },
  {
    "id":190,
    "response":"```python\ndef even_position(lst):\n    \"\"\"\n    Check if the list contains even-indexed elements (0, 2, 4, ...).\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        bool: True if there are even-positioned elements, otherwise False\n    \"\"\"\n    # A list always has at least one element at index 0 (even position)\n    # So if the list is non-empty, it has at least one even-positioned element\n    return len(lst) > 0\n```"
  },
  {
    "id":191,
    "response":"```python\ndef remove_nested(tup):\n    \"\"\"\n    প্রদত্ত টিউপেল থেকে নেস্টেড রেকর্ড সরানোর জন্য একটি ফাংশন।\n    নেস্টেড রেকর্ড হল যে কোন টিউপেল বা লিস্ট যা অন্য টিউপেল বা লিস্টের ভেতরে আছে।\n    এই ফাংশনটি সব নেস্টেড টিউপেল বা লিস্ট কে সরিয়ে দেবে এবং শুধুমাত্র প্রাথমিক মানগুলি রাখবে।\n    \n    Args:\n        tup: নেস্টেড টিউপেল বা লিস্ট\n        \n    Returns:\n        নেস্টেড রেকর্ড সরিয়ে দেওয়া প্রাথমিক মানের টিউপেল\n    \"\"\"\n    result = []\n    for item in tup:\n        if isinstance(item, (list, tuple)):\n            # যদি এটি নেস্টেড হয়, তবে সেটি সরানো হবে\n            # কিন্তু এখানে আমরা সরাব না, তাই আমরা প্রতিটি ক্ষেত্রে প্রতিটি মান নেব\n            # আমরা এখানে নেস্টেড টিউপেল সরাব না, তাই আমরা প্রতিটি মান যোগ করব\n            # কিন্তু এখানে আমরা নেস্টেড টিউপেল সরাব না, তাই আমরা প্রতিটি মান যোগ করব\n            # আমরা নেস্টেড টিউপেল সরাব না, তাই আমরা প্রতিটি মান যোগ করব\n            # আমরা নেস্টেড টিউপেল সরাব না, তাই আমরা প্রতিটি মান যোগ করব\n            # আমরা নেস্টেড টিউপেল সরাব না, তাই আমরা প্রতিটি মান যোগ করব\n            pass\n        else:\n            result.append(item)\n    return tuple(result)\n```"
  },
  {
    "id":192,
    "response":"```python\ndef count_list(lst):\n    \"\"\"\n    একটি তালিকার দৈর্ঘ্য গণনা করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    lst: তালিকা (list)\n    \n    ফেরত দেয়:\n    তালিকার দৈর্ঘ্য (int)\n    \"\"\"\n    return len(lst)\n```"
  },
  {
    "id":193,
    "response":"```python\ndef last(lst, n, n2):\n    \"\"\"\n    একটি সাজানো অ্যারেতে একটি উপাদানটির শেষ অবস্থান খুঁজে পায়।\n    \n    Parameters:\n    lst: সাজানো অ্যারে\n    n: উপাদান যার শেষ অবস্থান খুঁজবে\n    n2: অপর একটি উপাদান (যদি প্রয়োজন হয়)\n    \n    Returns:\n    উপাদান n এর শেষ অবস্থানের ক্রমাংক, যদি না থাকে তবে -1\n    \"\"\"\n    try:\n        # যদি n এর শেষ অবস্থান খুঁজে নেওয়া হয়\n        return len(lst) - 1 - lst[::-1].index(n)\n    except ValueError:\n        return -1\n```"
  },
  {
    "id":194,
    "response":"```python\ndef text_starta_endb(s):\n    \"\"\"\n    Check if a string has 'a' followed by some characters and ending with 'b'.\n    \n    Args:\n        s (str): The input string to check.\n    \n    Returns:\n        bool: True if the string starts with 'a' and ends with 'b', False otherwise.\n    \"\"\"\n    return s.startswith('a') and s.endswith('b')\n```"
  },
  {
    "id":195,
    "response":"```python\ndef cheap_items(lst, n):\n    \"\"\"\n    একটি ডেটাসেট থেকে n সস্তা মূল্যের আইটেমগুলি খুঁজে বের করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    lst: একটি লিস্ট যার মধ্যে আইটেমের মূল্য রয়েছে\n    n: সস্তা মূল্যের আইটেমের সংখ্যা\n    \n    রিটার্ন:\n    সস্তা n মূল্যের আইটেমগুলির একটি লিস্ট (মূল্য ক্রমে বাড়ানো হয়)\n    \"\"\"\n    if not lst or n <= 0:\n        return []\n    \n    # মূল্য অনুসারে সাজানো এবং প্রথম n টি আইটেম বাদ দেওয়া\n    sorted_items = sorted(lst)\n    return sorted_items[:n]\n```"
  },
  {
    "id":196,
    "response":"```python\ndef return_sum(dct):\n    \"\"\"\n    Calculate the sum of all values in the given dictionary.\n    \n    Args:\n        dct (dict): A dictionary with numeric values.\n    \n    Returns:\n        int\/float: The sum of all values in the dictionary.\n    \"\"\"\n    return sum(dct.values())\n```"
  },
  {
    "id":197,
    "response":"```python\ndef sum_of_odd_natural_numbers(l, r):\n    \"\"\"\n    Calculate the sum of all odd natural numbers in the range [l, r] (inclusive).\n    \n    Args:\n        l (int): The lower bound of the range.\n        r (int): The upper bound of the range.\n    \n    Returns:\n        int: The sum of all odd natural numbers in the range [l, r].\n    \"\"\"\n    total = 0\n    for num in range(l, r + 1):\n        if num % 2 == 1:  # Check if the number is odd\n            total += num\n    return total\n```"
  },
  {
    "id":198,
    "response":"```python\ndef _sum(lst):\n    \"\"\"\n    একটি অ্যারের যোগফল খুঁজে পায়।\n    \n    প্যারামিটার:\n    lst (list): যোগ করা হবে একটি সংখ্যা অ্যারে।\n    \n    রিটার্ন:\n    int বা float: অ্যারের সব সংখ্যার যোগফল।\n    \"\"\"\n    return sum(lst)\n```"
  },
  {
    "id":199,
    "response":"```python\ndef left_rotate(n, n2):\n    \"\"\"\n    একটি প্রদত্ত সংখ্যার বিটগুলিকে বাম দিকে ঘোরায়।\n    \n    Parameters:\n    n (int): ঘোরানো হবে সংখ্যা\n    n2 (int): ঘোরানোর পরিমাণ (বিট সংখ্যা)\n    \n    Returns:\n    int: ঘোরানো সংখ্যা\n    \"\"\"\n    # বিটগুলি বাম দিকে ঘোরানোর জন্য বাম ঘোরানোর সূত্র\n    # প্রথমে বিটগুলি নির্ধারণ করা হয়\n    # প্রতিটি বিট ঘোরানো হয় নির্দিষ্ট সংখ্যা দ্বারা\n    \n    # সংখ্যার বিট সংখ্যা নির্ধারণ\n    num_bits = n.bit_length() if n != 0 else 1\n    \n    # ঘোরানোর পরিমাণ মানে নির্দিষ্ট সংখ্যা বামে ঘোরানো\n    # যদি n2 >= বিট সংখ্যা হয়, তবে মডিউল নেওয়া হয়\n    rotations = n2 % num_bits\n    \n    # বাম ঘোরানোর সূত্র: (n << rotations) | (n >> (num_bits - rotations))\n    if rotations == 0:\n        return n\n    \n    # বাম ঘোরানো\n    left_rotated = (n << rotations) | (n >> (num_bits - rotations))\n    \n    return left_rotated\n```"
  },
  {
    "id":200,
    "response":"```python\ndef remove_all_spaces(s):\n    \"\"\"\n    একটি স্ট্রিং থেকে সব হোয়াইটস্পেস অপসারণ করে ফেরত দেয়।\n    \n    Args:\n        s (str): হোয়াইটস্পেস অপসারণের জন্য দেয়া স্ট্রিং\n        \n    Returns:\n        str: হোয়াইটস্পেস বিহীন স্ট্রিং\n    \"\"\"\n    return s.replace(\" \", \"\")\n```"
  },
  {
    "id":201,
    "response":"```python\ndef test_three_equal(n, n2, n3):\n    \"\"\"\n    তিনটি পূর্ণসংখ্যা থেকে সমান সংখ্যার সংখ্যা গণনা করে।\n    \n    Parameters:\n    n, n2, n3: তিনটি পূর্ণসংখ্যা\n    \n    Returns:\n    সমান সংখ্যা গুলির সংখ্যা (0, 1, 2 বা 3)\n    \"\"\"\n    count = 0\n    if n == n2:\n        count += 1\n    if n == n3:\n        count += 1\n    if n2 == n3:\n        count += 1\n    \n    # যদি সব সমান হয়, তবে সংখ্যা 3 হবে\n    if n == n2 == n3:\n        return 3\n    # যদি দুটি সমান হয়, তবে সংখ্যা 2 হবে\n    elif n == n2 or n == n3 or n2 == n3:\n        return 2\n    # যদি সব ভিন্ন হয়, তবে সংখ্যা 0 হবে\n    else:\n        return 0\n```"
  },
  {
    "id":202,
    "response":"```python\ndef count_Rotation(lst, n):\n    \"\"\"\n    Calculate the number of rotations needed to make the array sorted in ascending order.\n    \n    Args:\n        lst: A list of integers representing the rotated array.\n        n: The length of the array.\n    \n    Returns:\n        The number of rotations required to sort the array in ascending order.\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    # Find the index of the minimum element (which indicates the rotation point)\n    min_index = 0\n    for i in range(1, n):\n        if lst[i] < lst[min_index]:\n            min_index = i\n    \n    # The number of rotations is the index of the minimum element\n    return min_index\n```"
  },
  {
    "id":203,
    "response":"```python\nimport math\n\ndef is_Perfect_Square(n):\n    \"\"\"\n    Check if a given number is a perfect square.\n    \n    Args:\n        n (int): The number to check\n        \n    Returns:\n        bool: True if n is a perfect square, False otherwise\n    \"\"\"\n    if n < 0:\n        return False\n    \n    if n == 0 or n == 1:\n        return True\n    \n    sqrt_n = int(math.sqrt(n))\n    return sqrt_n * sqrt_n == n\n```"
  },
  {
    "id":204,
    "response":"```python\ndef is_Product_Even(lst, n):\n    \"\"\"\n    Check if the product of the first n elements from the list is even.\n    \n    Args:\n        lst: List of integers\n        n: Number of elements to consider from the start of the list\n    \n    Returns:\n        True if the product is even, False otherwise\n    \"\"\"\n    # Handle edge cases\n    if n <= 0 or n > len(lst):\n        return False\n    \n    # Calculate the product of first n elements\n    product = 1\n    for i in range(n):\n        product *= lst[i]\n    \n    # Check if the product is even\n    return product % 2 == 0\n```"
  },
  {
    "id":205,
    "response":"```python\ndef max_sum_list(lst):\n    \"\"\"\n    Find the sublist with the maximum sum of elements.\n    \n    Args:\n        lst: A list of lists (sublists) of integers.\n    \n    Returns:\n        The sublist with the maximum sum of elements.\n        If the input list is empty, returns None.\n    \"\"\"\n    if not lst:\n        return None\n    \n    max_sum = float('-inf')\n    max_sum_list = None\n    \n    for sublist in lst:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_list = sublist\n    \n    return max_sum_list\n```"
  },
  {
    "id":206,
    "response":"```python\ndef max_run_uppercase(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিং-এ বড় অক্ষরের সর্বোচ্চ সংখ্যা খুঁজে বের করে।\n    \n    প্যারামিটার:\n    s (str): প্রদত্ত স্ট্রিং\n    \n    রিটার্ন:\n    int: বড় অক্ষরের সর্বোচ্চ সংখ্যা\n    \"\"\"\n    count = 0\n    max_count = 0\n    \n    for char in s:\n        if char.isupper():\n            count += 1\n            max_count = max(max_count, count)\n        else:\n            count = 0\n    \n    return max_count\n```"
  },
  {
    "id":207,
    "response":"```python\ndef first_odd(lst):\n    \"\"\"\n    Return the first odd number in a list of numbers.\n    \n    Args:\n        lst: A list of numbers\n        \n    Returns:\n        The first odd number in the list, or None if no odd number is found\n    \"\"\"\n    for num in lst:\n        if num % 2 != 0:\n            return num\n    return None\n```"
  },
  {
    "id":208,
    "response":"```python\ndef check_K(tup, k):\n    \"\"\"\n    Check if the element k exists in the given tuple.\n    \n    Args:\n        tup: The tuple to search in.\n        k: The element to check for.\n    \n    Returns:\n        bool: True if k is found in tup, False otherwise.\n    \"\"\"\n    return k in tup\n```"
  },
  {
    "id":209,
    "response":"```python\ndef check_smaller(tup, tup2):\n    \"\"\"\n    Check if each element in the second tuple is smaller than the corresponding element in the first tuple.\n    \n    Args:\n        tup: First tuple\n        tup2: Second tuple\n    \n    Returns:\n        bool: True if every element in tup2 is smaller than the corresponding element in tup,\n              False otherwise or if tuples have different lengths.\n    \"\"\"\n    if len(tup) != len(tup2):\n        return False\n    \n    for i in range(len(tup)):\n        if tup2[i] >= tup[i]:\n            return False\n    \n    return True\n```"
  },
  {
    "id":210,
    "response":"```python\ndef count_variable(n, n2, n3, n4):\n    \"\"\"\n    প্রদত্ত উপাদানগুলোর পুনরাবৃত্তি করে যার সংখ্যা যতবার হয়।\n    \n    Parameters:\n    n, n2, n3, n4: উপাদানগুলি যা পুনরাবৃত্তি করা হবে\n    \n    Returns:\n    পুনরাবৃত্তি করা উপাদানগুলির একটি তালিকা\n    \"\"\"\n    result = []\n    result.extend([n] * n)\n    result.extend([n2] * n2)\n    result.extend([n3] * n3)\n    result.extend([n4] * n4)\n    return result\n```"
  },
  {
    "id":211,
    "response":"```python\ndef check_identical(lst, lst2):\n    \"\"\"\n    Check if two lists contain the same elements in the same order.\n    \n    Args:\n        lst: First list to compare\n        lst2: Second list to compare\n        \n    Returns:\n        bool: True if both lists are identical, False otherwise\n    \"\"\"\n    return lst == lst2\n```"
  },
  {
    "id":212,
    "response":"```python\ndef road_rd(s):\n    \"\"\"\n    Replace all occurrences of 'road' with 'rd.' in the given string.\n    \n    Args:\n        s (str): The input string where 'road' needs to be replaced with 'rd.'\n    \n    Returns:\n        str: The string with 'road' replaced by 'rd.'\n    \"\"\"\n    return s.replace('road', 'rd.')\n```"
  },
  {
    "id":213,
    "response":"```python\ndef string_length(s):\n    \"\"\"\n    একটি স্ট্রিং এর দৈর্ঘ্য খুঁজে বের করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    s (str): দৈর্ঘ্য খুঁজে বের করার জন্য স্ট্রিং\n    \n    রিটার্ন:\n    int: স্ট্রিং এর দৈর্ঘ্য\n    \"\"\"\n    return len(s)\n```"
  },
  {
    "id":214,
    "response":"```python\ndef rombus_area(n, n2):\n    \"\"\"\n    রম্বসের ক্ষেত্রফল বের করে তোলে।\n    \n    প্যারামিটার:\n    n: রম্বসের একটি কর্ণের দৈর্ঘ্য\n    n2: রম্বসের অন্য কর্ণের দৈর্ঘ্য\n    \n    রিটার্ন:\n    রম্বসের ক্ষেত্রফল (n * n2) \/ 2\n    \"\"\"\n    return (n * n2) \/ 2\n```"
  },
  {
    "id":215,
    "response":"```python\ndef sort_by_dnf(lst):\n    \"\"\"\n    Sorts an array containing only 0, 1, and 2 using the DNF (Dutch National Flag) algorithm\n    without using any built-in sorting functions.\n    \n    Args:\n        lst: List containing only 0, 1, and 2\n        \n    Returns:\n        Sorted list with all 0s followed by 1s followed by 2s\n    \"\"\"\n    low = 0\n    mid = 0\n    high = len(lst) - 1\n    \n    while mid <= high:\n        if lst[mid] == 0:\n            lst[low], lst[mid] = lst[mid], lst[low]\n            low += 1\n            mid += 1\n        elif lst[mid] == 1:\n            mid += 1\n        else:  # lst[mid] == 2\n            lst[mid], lst[high] = lst[high], lst[mid]\n            high -= 1\n    \n    return lst\n```"
  },
  {
    "id":216,
    "response":"```python\ndef clear_tuple(tup):\n    \"\"\"\n    প্রদত্ত টুপলের মানগুলি সাফ করে দেয়।\n    এটি টুপলের সব মানকে শূন্য করে দেয় বা স্থান শূন্য করে দেয়।\n    \n    Parameters:\n    tup: একটি টুপল\n    \n    Returns:\n    শূন্য টুপল\n    \"\"\"\n    return ()\n```"
  },
  {
    "id":217,
    "response":"```python\ndef div_of_nums(lst, m, n):\n    \"\"\"\n    ল্যাম্বদা ফাংশন ব্যবহার করে সংখ্যার তালিকা থেকে m বা n দ্বারা বিভাজ্য সংখ্যা খুঁজে বের করে।\n    \n    Args:\n        lst: সংখ্যার তালিকা\n        m: প্রথম বিভাজ্য সংখ্যা\n        n: দ্বিতীয় বিভাজ্য সংখ্যা\n    \n    Returns:\n        যে সংখ্যাগুলো m বা n দ্বারা বিভাজ্য সেগুলোর তালিকা\n    \"\"\"\n    return list(filter(lambda x: x % m == 0 or x % n == 0, lst))\n```"
  },
  {
    "id":218,
    "response":"```python\ndef lower_ctr(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিংয়ে ছোট হাতের অক্ষর গণনা করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    s (str): ছোট হাতের অক্ষর গণনা করার জন্য প্রদত্ত স্ট্রিং\n    \n    রিটার্ন:\n    int: ছোট হাতের অক্ষরের সংখ্যা\n    \"\"\"\n    return sum(1 for char in s if char.islower())\n```"
  },
  {
    "id":219,
    "response":"```python\ndef count_duplic(lst):\n    \"\"\"\n    Count the frequency of consecutive duplicate elements in a list.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A list of tuples (element, frequency) for consecutive duplicates\n    \"\"\"\n    if not lst:\n        return []\n    \n    result = []\n    current_element = lst[0]\n    current_count = 1\n    \n    for i in range(1, len(lst)):\n        if lst[i] == current_element:\n            current_count += 1\n        else:\n            # Add the previous consecutive duplicate to result\n            if current_count > 1:\n                result.append((current_element, current_count))\n            # Reset for new element\n            current_element = lst[i]\n            current_count = 1\n    \n    # Don't forget the last group\n    if current_count > 1:\n        result.append((current_element, current_count))\n    \n    return result\n```"
  },
  {
    "id":220,
    "response":"```python\ndef check_monthnum_number(n):\n    \"\"\"\n    Check if the given month number has 28 days.\n    \n    Args:\n        n (int): The month number (1-12)\n    \n    Returns:\n        bool: True if the month has 28 days, False otherwise\n    \"\"\"\n    # February is the only month with exactly 28 days (in a non-leap year)\n    return n == 2\n```"
  },
  {
    "id":221,
    "response":"```python\ndef merge_dictionaries(dct, dct2):\n    \"\"\"\n    দুটি অভিধান একক অভিব্যক্তিতে একত্রিত করে।\n    \n    Args:\n        dct: প্রথম অভিধান\n        dct2: দ্বিতীয় অভিধান\n    \n    Returns:\n        একটি নতুন অভিধান যা দুটি অভিধানের সমন্বয় হয়\n    \"\"\"\n    result = dct.copy()\n    for key, value in dct2.items():\n        if key in result:\n            if isinstance(result[key], dict) and isinstance(value, dict):\n                result[key] = merge_dictionaries(result[key], value)\n            else:\n                result[key] = value\n        else:\n            result[key] = value\n    return result\n```"
  },
  {
    "id":222,
    "response":"```python\ndef pass_validity(s):\n    \"\"\"\n    Check if the password is valid.\n    \n    A valid password must:\n    - Be at least 8 characters long\n    - Contain at least one uppercase letter\n    - Contain at least one lowercase letter\n    - Contain at least one digit\n    - Contain at least one special character (e.g., !@#$%^&*())\n    \n    Args:\n        s (str): The password to validate\n        \n    Returns:\n        bool: True if the password is valid, False otherwise\n    \"\"\"\n    if len(s) < 8:\n        return False\n    \n    has_upper = any(c.isupper() for c in s)\n    has_lower = any(c.islower() for c in s)\n    has_digit = any(c.isdigit() for c in s)\n    has_special = any(not c.isalnum() for c in s)\n    \n    return has_upper and has_lower and has_digit and has_special\n```"
  },
  {
    "id":223,
    "response":"```python\nimport re\n\ndef check_substring(s, s2):\n    \"\"\"\n    Check if string s starts with substring s2 using regex.\n    \n    Args:\n        s (str): The main string to check\n        s2 (str): The substring to check if it starts with\n    \n    Returns:\n        bool: True if s starts with s2, False otherwise\n    \"\"\"\n    # Create a regex pattern that matches s2 at the beginning of s\n    pattern = f'^{re.escape(s2)}'\n    return bool(re.match(pattern, s))\n```"
  },
  {
    "id":224,
    "response":"```python\ndef remove_even(lst):\n    \"\"\"\n    প্রদত্ত তালিকার থেকে সম সংখ্যা অপসারণ করে এবং বিজোড় সংখ্যা বাড়ানো হয়।\n    \n    Args:\n        lst: একটি সংখ্যা বিশিষ্ট তালিকা\n        \n    Returns:\n        সম সংখ্যা অপসারণের পরে বাকি থাকা বিজোড় সংখ্যা বিশিষ্ট তালিকা\n    \"\"\"\n    return [x for x in lst if x % 2 != 0]\n```"
  },
  {
    "id":225,
    "response":"```python\ndef access_elements(lst, indices):\n    \"\"\"\n    নির্দিষ্ট তালিকা থেকে নির্দিষ্ট সূচকের একাধিক উপাদান অ্যাক্সেস করে।\n    \n    প্যারামিটার:\n    lst: অ্যাক্সেস করার জন্য তালিকা\n    indices: সূচকের তালিকা (সূচকগুলি সূচক হতে হবে)\n    \n    রিটার্ন:\n    সূচকগুলির উপাদানগুলির তালিকা\n    \"\"\"\n    return [lst[i] for i in indices if 0 <= i < len(lst)]\n```"
  },
  {
    "id":226,
    "response":"```python\ndef check_Type_Of_Triangle(n, n2, n3):\n    \"\"\"\n    ত্রিভুজের ধরন খুঁজে বের করে।\n    \n    প্যারামিটার:\n    n, n2, n3: ত্রিভুজের তিনটি বাহুর দৈর্ঘ্য\n    \n    রিটার্ন:\n    ত্রিভুজের ধরন (যেমন: \"সমবাহু\", \"সমদ্বিবাহু\", \"বিষমবাহু\", \"অসম্ভব\")\n    \"\"\"\n    # ত্রিভুজের সম্ভাবনা পরীক্ষা (ত্রিভুজ নিয়ম: যেকোন দুটি বাহুর সমষ্টি তৃতীয় বাহুর চেয়ে বড় হতে হবে)\n    if (n + n2 <= n3) or (n + n3 <= n2) or (n2 + n3 <= n):\n        return \"অসম্ভব\"\n    \n    # সমবাহু ত্রিভুজ: সব বাহু সমান\n    if n == n2 == n3:\n        return \"সমবাহু\"\n    \n    # সমদ্বিবাহু ত্রিভুজ: দুটি বাহু সমান\n    elif n == n2 or n == n3 or n2 == n3:\n        return \"সমদ্বিবাহু\"\n    \n    # বিষমবাহু ত্রিভুজ: সব বাহু বিভিন্ন\n    else:\n        return \"বিষমবাহু\"\n```"
  },
  {
    "id":227,
    "response":"```python\ndef sum_column(lst, n):\n    \"\"\"\n    Calculate the sum of a specific column in a list of lists.\n    \n    Args:\n        lst: A list of lists, where each inner list represents a row.\n        n: The index of the column to sum (0-based indexing).\n    \n    Returns:\n        The sum of the specified column.\n    \n    Raises:\n        IndexError: If the column index is out of bounds.\n        ValueError: If the input list is empty or contains empty rows.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list is empty\")\n    \n    total = 0\n    for row in lst:\n        if len(row) <= n:\n            raise IndexError(f\"Column index {n} is out of bounds for row {row}\")\n        total += row[n]\n    \n    return total\n```"
  },
  {
    "id":228,
    "response":"```python\ndef count_alpha_dig_spl(s):\n    \"\"\"\n    Count the number of alphabets, digits, and special characters in a given string.\n    \n    Args:\n        s (str): The input string to analyze.\n    \n    Returns:\n        tuple: A tuple containing (count_of_alphabets, count_of_digits, count_of_special_chars)\n    \"\"\"\n    alpha_count = 0\n    dig_count = 0\n    spl_count = 0\n    \n    for char in s:\n        if char.isalpha():\n            alpha_count += 1\n        elif char.isdigit():\n            dig_count += 1\n        else:\n            spl_count += 1\n    \n    return alpha_count, dig_count, spl_count\n```"
  },
  {
    "id":229,
    "response":"```python\ndef second_frequent(lst):\n    \"\"\"\n    Find the second most frequent string in a list.\n    \n    Args:\n        lst: A list of strings\n        \n    Returns:\n        The second most frequent string, or None if there is no second frequency\n    \"\"\"\n    if not lst:\n        return None\n    \n    # Count frequency of each string\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    \n    # Sort by frequency in descending order\n    sorted_items = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n    \n    # Return the second most frequent string (if exists)\n    if len(sorted_items) >= 2:\n        return sorted_items[1][0]\n    else:\n        return None\n```"
  },
  {
    "id":230,
    "response":"```python\ndef round_up(n, n2):\n    \"\"\"\n    একটি সংখ্যাকে নির্দিষ্ট সংখ্যায় গোলাকার করে ফেরত দেয়।\n    \n    Parameters:\n    n (float or int): গোলাকার করার জন্য সংখ্যা\n    n2 (float or int): গোলাকারের জন্য নির্দিষ্ট সংখ্যা (যে সংখ্যার সাথে সংখ্যাটি গোলাকার হবে)\n    \n    Returns:\n    float or int: গোলাকার সংখ্যা\n    \"\"\"\n    return int(n \/ n2) + 1 if n % n2 != 0 else int(n \/ n2)\n```"
  },
  {
    "id":231,
    "response":"```python\ndef count_Pairs(lst, n):\n    \"\"\"\n    Count the number of pairs in the list where the sum of the pair equals n.\n    \n    Args:\n        lst: List of integers\n        n: Target sum for the pairs\n    \n    Returns:\n        Integer count of pairs that sum to n\n    \"\"\"\n    count = 0\n    seen = set()\n    \n    for num in lst:\n        complement = n - num\n        if complement in seen:\n            count += 1\n        seen.add(num)\n    \n    return count\n```"
  },
  {
    "id":232,
    "response":"```python\nimport re\n\ndef extract_max(s):\n    \"\"\"\n    রেজেক্স ব্যবহার করে একটি স্ট্রিং থেকে সর্বোচ্চ সংখ্যাসূচক মান বের করে ফেরত দেয়।\n    \n    Args:\n        s (str): স্ট্রিং ইনপুট\n        \n    Returns:\n        int or float or None: সর্বোচ্চ সংখ্যা, যদি কোনো সংখ্যা না থাকে তবে None\n    \"\"\"\n    # সংখ্যা উদ্ধার করার জন্য রেজেক্স প্যাটার্ন\n    numbers = re.findall(r'-?\\d+\\.?\\d*', s)\n    \n    # সংখ্যা সংগ্রহ করা হয়েছে, যদি কোনো সংখ্যা না থাকে তবে None রিটার্ন করা হবে\n    if not numbers:\n        return None\n    \n    # সংখ্যা স্ট্রিং থেকে পরিবর্তন করে সংখ্যা মানে পরিবর্তন করা হয়\n    try:\n        numbers = [float(num) for num in numbers]\n        return max(numbers)\n    except (ValueError, TypeError):\n        return None\n```"
  },
  {
    "id":233,
    "response":"```python\ndef get_key(dct):\n    \"\"\"\n    Return the first key from a dictionary.\n    \n    Args:\n        dct (dict): The dictionary from which to get the key.\n    \n    Returns:\n        The first key of the dictionary, or None if the dictionary is empty.\n    \"\"\"\n    if not dct:\n        return None\n    return next(iter(dct.keys()))\n```"
  },
  {
    "id":234,
    "response":"```python\ndef generate_matrix(n):\n    \"\"\"\n    Generate a square matrix of size n x n filled with numbers from 1 to n*n\n    in a spiral order, starting from the top-left corner and moving clockwise.\n    \n    Args:\n        n (int): The size of the square matrix (n x n)\n    \n    Returns:\n        list[list[int]]: A square matrix filled in spiral order\n    \"\"\"\n    # Initialize the matrix with zeros\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Define the boundaries of the spiral\n    top, bottom = 0, n - 1\n    left, right = 0, n - 1\n    \n    # Current number to fill in the matrix\n    num = 1\n    \n    while top <= bottom and left <= right:\n        # Fill top row from left to right\n        for col in range(left, right + 1):\n            matrix[top][col] = num\n            num += 1\n        top += 1\n        \n        # Fill right column from top to bottom\n        for row in range(top, bottom + 1):\n            matrix[row][right] = num\n            num += 1\n        right -= 1\n        \n        # Fill bottom row from right to left (if there's still a row)\n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                matrix[bottom][col] = num\n                num += 1\n            bottom -= 1\n        \n        # Fill left column from bottom to top (if there's still a column)\n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                matrix[row][left] = num\n                num += 1\n            left += 1\n    \n    return matrix\n```"
  },
  {
    "id":235,
    "response":"```python\ndef slope(n, n2, n3, n4):\n    \"\"\"\n    Calculate the slope of a line given four points.\n    This function assumes the line is defined by two points (n, n2) and (n3, n4).\n    Slope = (y2 - y1) \/ (x2 - x1)\n    \"\"\"\n    return (n4 - n2) \/ (n3 - n)\n```"
  },
  {
    "id":236,
    "response":"```python\ndef max_sub_array_sum(lst, n):\n    \"\"\"\n    Find the maximum sum of a contiguous subarray and its length.\n    \n    Args:\n        lst: List of integers\n        n: Length of the list\n    \n    Returns:\n        A tuple (max_sum, length) where max_sum is the maximum sum of any subarray\n        and length is the length of that subarray.\n    \"\"\"\n    if not lst or n == 0:\n        return (0, 0)\n    \n    max_sum = lst[0]\n    current_sum = lst[0]\n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, n):\n        # If current sum becomes negative, start a new subarray from current element\n        if current_sum < 0:\n            current_sum = lst[i]\n            current_length = 1\n        else:\n            current_sum += lst[i]\n            current_length += 1\n        \n        # Update max_sum and max_length if current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_length = current_length\n    \n    return (max_sum, max_length)\n```"
  },
  {
    "id":237,
    "response":"```python\ndef cube_sum(n):\n    \"\"\"\n    প্রথম n অদ্ভুত প্রাকৃতিক সংখ্যার ঘনক্ষেত্র সমষ্টি খুঁজে বের করে।\n    \n    অদ্ভুত প্রাকৃতিক সংখ্যা হল যারা সংখ্যার ঘন হয়ে থাকে, যেমন 1, 8, 27, 64, 125, ...\n    এখানে প্রথম n ঘন সংখ্যার ঘনক্ষেত্র সমষ্টি হিসাব করা হয়।\n    \n    Parameters:\n    n (int): প্রথম n ঘন সংখ্যা নির্দেশ করে\n    \n    Returns:\n    int: প্রথম n ঘন সংখ্যার ঘনক্ষেত্র সমষ্টি\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total += i ** 3\n    return total\n```"
  },
  {
    "id":238,
    "response":"```python\ndef min_swaps(s, s2):\n    \"\"\"\n    Find the minimum number of swaps needed to make two binary strings equal.\n    \n    Args:\n        s (str): First binary string\n        s2 (str): Second binary string\n    \n    Returns:\n        int: Minimum number of swaps needed to make both strings equal\n    \"\"\"\n    # If the strings are already equal, no swaps needed\n    if s == s2:\n        return 0\n    \n    # Count the positions where the characters differ\n    diff_positions = []\n    for i in range(len(s)):\n        if s[i] != s2[i]:\n            diff_positions.append(i)\n    \n    # If no differences, strings are already equal\n    if not diff_positions:\n        return 0\n    \n    # For binary strings, we can swap characters to match\n    # The minimum number of swaps needed is half the number of differing positions\n    # because each swap can fix two positions (if we swap a '0' with a '1' at different positions)\n    \n    # However, if the number of differing positions is odd, we cannot make them equal\n    # But since we're dealing with binary strings, we can only make them equal if\n    # the number of differences is even (because each swap changes two positions)\n    \n    # If the number of differences is odd, it's impossible to make them equal\n    # But the problem implies it's always possible, so we assume even differences\n    \n    num_diff = len(diff_positions)\n    \n    # If odd number of differences, it's impossible to make equal\n    if num_diff % 2 == 1:\n        return -1  # or raise an error, depending on requirements\n    \n    # Minimum swaps is half the number of differing positions\n    return num_diff \/\/ 2\n```"
  },
  {
    "id":239,
    "response":"```python\ndef sort_tuple(lst):\n    \"\"\"\n    Sorts a list of tuples based on the first item of each tuple in ascending order.\n    \n    Args:\n        lst (list of tuples): A list where each element is a tuple.\n    \n    Returns:\n        list of tuples: A new list of tuples sorted by the first item of each tuple.\n    \"\"\"\n    return sorted(lst, key=lambda x: x[0])\n```"
  },
  {
    "id":240,
    "response":"```python\ndef Check_Solution(n, n2, n3):\n    \"\"\"\n    Check if three numbers are numerically equal but have opposite signs.\n    \n    Args:\n        n: First number\n        n2: Second number\n        n3: Third number\n        \n    Returns:\n        bool: True if all numbers have the same magnitude but opposite signs (or one is zero),\n              False otherwise.\n    \"\"\"\n    # Check if all have the same absolute value\n    if abs(n) != abs(n2) or abs(n2) != abs(n3):\n        return False\n    \n    # If any is zero, all must be zero (zero has no opposite sign)\n    if n == 0 and n2 == 0 and n3 == 0:\n        return True\n    \n    # Check if signs are opposite (exactly one positive, two negative or vice versa)\n    # But since we have three numbers, opposite signs means not all same sign\n    signs = [n >= 0, n2 >= 0, n3 >= 0]\n    positive_count = sum(signs)\n    \n    # For opposite signs in a group of three, we need exactly one positive and two negative\n    # or exactly two positive and one negative\n    return positive_count != 3 and positive_count != 0\n```"
  },
  {
    "id":241,
    "response":"```python\ndef get_inv_count(lst, n):\n    \"\"\"\n    Count the number of inversions in the given list.\n    An inversion is a pair (i, j) such that i < j and lst[i] > lst[j].\n    \n    Args:\n        lst: List of integers\n        n: Length of the list\n    \n    Returns:\n        Integer representing the number of inversions\n    \"\"\"\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lst[i] > lst[j]:\n                inv_count += 1\n    return inv_count\n```"
  },
  {
    "id":242,
    "response":"```python\ndef get_odd_occurence(lst, n):\n    \"\"\"\n    Find the number that occurs odd number of times in the list.\n    \n    Args:\n        lst: List of integers\n        n: Length of the list (optional, for validation)\n    \n    Returns:\n        The number that occurs odd number of times, or None if no such number exists\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in lst:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Find the number with odd occurrence\n    for num, count in count_dict.items():\n        if count % 2 == 1:\n            return num\n    \n    return None  # No number occurs odd number of times\n```"
  },
  {
    "id":243,
    "response":"```python\nimport heapq\n\ndef nth_super_ugly_number(n, lst):\n    \"\"\"\n    Find the nth super ugly number using a min-heap approach.\n    \n    Args:\n        n (int): The position of the super ugly number to find (1-indexed).\n        lst (list): A list of prime factors (or base numbers) to generate super ugly numbers.\n    \n    Returns:\n        int: The nth super ugly number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # Initialize the heap with the first super ugly number (1)\n    heap = [1]\n    # Use a set to keep track of numbers we've already seen\n    seen = {1}\n    \n    # Generate the nth super ugly number\n    for _ in range(n - 1):\n        # Pop the smallest number from the heap\n        current = heapq.heappop(heap)\n        \n        # Generate new candidates by multiplying current with each prime factor\n        for factor in lst:\n            next_val = current * factor\n            if next_val not in seen:\n                seen.add(next_val)\n                heapq.heappush(heap, next_val)\n    \n    # The last popped value is the nth super ugly number\n    return heapq.heappop(heap)\n```"
  },
  {
    "id":244,
    "response":"```python\ndef get_kth_element(arr, k):\n    \"\"\"\n    একটি অ্যারেতে kth উপাদান খুঁজে পায়।\n    \n    Parameters:\n    arr (list): অ্যারে\n    k (int): kth উপাদানের পজিশন (0 থেকে শুরু)\n    \n    Returns:\n    int\/float\/str: kth উপাদান যদি অস্তিত্বে থাকে, অন্যথায় রিটার্ন করে না\n    \"\"\"\n    if k < 0 or k >= len(arr):\n        return None\n    return arr[k]\n```"
  },
  {
    "id":245,
    "response":"```python\ndef find_Digits(n):\n    \"\"\"\n    Calculate the number of digits in the factorial of n.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The number of digits in n!\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    # Calculate factorial\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    \n    # Count digits\n    if factorial == 0:\n        return 1\n    return len(str(factorial))\n```"
  },
  {
    "id":246,
    "response":"```python\ndef find_platform(lst, lst2, n):\n    \"\"\"\n    Find the minimum number of platforms required at a railway or bus station\n    to accommodate all trains or buses that arrive and depart within a given time frame.\n    \n    Args:\n        lst: List of arrival times (int or float)\n        lst2: List of departure times (int or float)\n        n: Number of time slots or a parameter (if used for specific logic)\n    \n    Returns:\n        int: Minimum number of platforms required\n    \"\"\"\n    # Sort arrival and departure times\n    arrivals = sorted(lst)\n    departures = sorted(lst2)\n    \n    platforms = 0\n    max_platforms = 0\n    i, j = 0, 0  # pointers for arrivals and departures\n    \n    while i < len(arrivals) and j < len(departures):\n        if arrivals[i] <= departures[j]:\n            # Train arrives, need one more platform\n            platforms += 1\n            i += 1\n        else:\n            # Train departs, one platform freed\n            platforms -= 1\n            j += 1\n        \n        # Update maximum platforms needed\n        max_platforms = max(max_platforms, platforms)\n    \n    return max_platforms\n```"
  },
  {
    "id":247,
    "response":"```python\ndef lcopy(lst):\n    \"\"\"\n    একটি সিঙ্গেলটন টিপল থেকে একটি তালিকা কপি করে ফেরত দেয়।\n    \n    Parameters:\n    lst: একটি তালিকা (list)\n    \n    Returns:\n    তালিকার একটি কপি\n    \"\"\"\n    return lst.copy()\n```"
  },
  {
    "id":248,
    "response":"```python\ndef area_trapezium(n, n2, n3):\n    \"\"\"\n    ট্র্যাপিসিয়ামের ক্ষেত্রফল বের করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    n: ট্র্যাপিসিয়ামের দুটি সমান্তরাল পাশের দৈর্ঘ্য (উচ্চতা নয়)\n    n2: ট্র্যাপিসিয়ামের দুটি সমান্তরাল পাশের দৈর্ঘ্য (উচ্চতা নয়)\n    n3: ট্র্যাপিসিয়ামের উচ্চতা\n    \n    ফলাফল:\n    ট্র্যাপিসিয়ামের ক্ষেত্রফল (সেকেন্ড স্পেস)\n    \"\"\"\n    return 0.5 * (n + n2) * n3\n```"
  },
  {
    "id":249,
    "response":"```python\ndef sum_of_divisors_of_digits(n):\n    \"\"\"\n    Calculate the sum of all divisors of each digit in the given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: Sum of divisors of all digits in n\n    \"\"\"\n    total = 0\n    digits = str(n)\n    \n    for digit_char in digits:\n        digit = int(digit_char)\n        if digit != 0:\n            # Find all divisors of the digit\n            divisors = []\n            for i in range(1, digit + 1):\n                if digit % i == 0:\n                    divisors.append(i)\n            total += sum(divisors)\n    \n    return total\n```"
  },
  {
    "id":250,
    "response":"```python\ndef is_triangleexists(n, n2, n3):\n    \"\"\"\n    Check if three given sides can form a positive area triangle.\n    \n    A triangle can be formed if and only if the sum of any two sides is greater than the third side.\n    This is known as the triangle inequality theorem.\n    \n    Args:\n        n (float): First side length\n        n2 (float): Second side length  \n        n3 (float): Third side length\n    \n    Returns:\n        bool: True if a triangle with positive area can be formed, False otherwise\n    \"\"\"\n    # Check if all sides are positive (positive area requirement)\n    if n <= 0 or n2 <= 0 or n3 <= 0:\n        return False\n    \n    # Triangle inequality theorem: sum of any two sides must be greater than the third\n    return (n + n2 > n3) and (n + n3 > n2) and (n2 + n3 > n)\n```"
  },
  {
    "id":251,
    "response":"```python\ndef sum_of_inverse_divisors(n, n2):\n    \"\"\"\n    Calculate the sum of inverse divisors of n up to n2.\n    \n    Args:\n        n: The number to find divisors for\n        n2: The upper limit for divisors (inclusive)\n    \n    Returns:\n        The sum of inverse divisors of n that are <= n2\n    \"\"\"\n    total = 0\n    # Find all divisors of n that are <= n2\n    for i in range(1, min(n, n2) + 1):\n        if n % i == 0:\n            total += 1 \/ i\n    return total\n```"
  },
  {
    "id":252,
    "response":"```python\ndef remove_negs(lst):\n    \"\"\"\n    একটি তালিকা থেকে নেতিবাচক সংখ্যা অপসারণ করে এবং শুধুমাত্র নেতিবাচক সংখ্যা বাদ দেয়।\n    \n    Args:\n        lst: একটি সংখ্যা বিশিষ্ট তালিকা\n        \n    Returns:\n        নেতিবাচক সংখ্যা বাদ দেওয়া তালিকা\n    \"\"\"\n    return [x for x in lst if x >= 0]\n```"
  },
  {
    "id":253,
    "response":"```python\ndef sum_of_odd_factors(n):\n    \"\"\"\n    Calculate the sum of all odd factors of a given number n.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: Sum of all odd factors of n\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    total_sum = 0\n    i = 1\n    \n    # Check all odd numbers from 1 to sqrt(n)\n    while i * i <= n:\n        if n % i == 0:\n            # i is a factor\n            if i % 2 == 1:  # i is odd\n                total_sum += i\n            \n            # Check the corresponding factor (n \/\/ i)\n            corresponding_factor = n \/\/ i\n            if corresponding_factor != i and corresponding_factor % 2 == 1:  # corresponding_factor is odd\n                total_sum += corresponding_factor\n        i += 2  # Only check odd numbers\n    \n    return total_sum\n```"
  },
  {
    "id":254,
    "response":"```python\ndef raw_heap(lst):\n    \"\"\"\n    Convert a list into a heap using the heapify algorithm.\n    This function modifies the input list in-place to satisfy the heap property.\n    For a min-heap, parent[i] <= children[i] (left and right).\n    \n    Args:\n        lst: A list of comparable elements to be converted into a heap.\n    \n    Returns:\n        The same list modified to be a heap.\n    \"\"\"\n    n = len(lst)\n    \n    # Start from the last non-leaf node and heapify down\n    for i in range(n \/\/ 2 - 1, -1, -1):\n        _heapify_down(lst, i, n)\n    \n    return lst\n\ndef _heapify_down(lst, i, n):\n    \"\"\"\n    Maintain the heap property by moving the element at index i down.\n    \n    Args:\n        lst: The list to heapify.\n        i: The index of the current node.\n        n: The size of the heap.\n    \"\"\"\n    smallest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    \n    # Check if left child exists and is smaller\n    if left < n and lst[left] < lst[smallest]:\n        smallest = left\n    \n    # Check if right child exists and is smaller\n    if right < n and lst[right] < lst[smallest]:\n        smallest = right\n    \n    # If the smallest is not the current node, swap and continue heapifying\n    if smallest != i:\n        lst[i], lst[smallest] = lst[smallest], lst[i]\n        _heapify_down(lst, smallest, n)\n```"
  },
  {
    "id":255,
    "response":"```python\ndef check_even_parity(n):\n    \"\"\"\n    Check if a number has even parity (number of 1s in its binary representation is even).\n    \n    Args:\n        n (int): The integer to check for even parity.\n    \n    Returns:\n        bool: True if the number has even parity, False otherwise.\n    \"\"\"\n    # Count the number of 1s in the binary representation\n    ones_count = bin(n).count('1')\n    \n    # Return True if the count is even, False if odd\n    return ones_count % 2 == 0\n```"
  },
  {
    "id":256,
    "response":"```python\ndef find_Min_Swaps(lst, n):\n    \"\"\"\n    Find the minimum number of swaps required to sort a binary array.\n    \n    Args:\n        lst: List of integers containing only 0s and 1s\n        n: Length of the array\n    \n    Returns:\n        Minimum number of swaps required to sort the array (all 0s followed by all 1s)\n    \"\"\"\n    # Count the number of 0s and 1s\n    zeros = lst.count(0)\n    ones = n - zeros\n    \n    # In a sorted binary array, all 0s come first, then all 1s\n    # The minimum swaps needed is the number of 0s that are in the right half\n    # or equivalently, the number of 1s that are in the left half\n    \n    # Count how many 1s are in the first 'zeros' positions (wrong place)\n    swaps = 0\n    for i in range(zeros):\n        if lst[i] == 1:\n            swaps += 1\n    \n    return swaps\n```"
  },
  {
    "id":257,
    "response":"```python\ndef listify_list(lst):\n    \"\"\"\n    প্রদত্ত স্ট্রিংগুলির তালিকা পৃথকভাবে তালিকাভুক্ত করে ফেরত দেয়।\n    \n    Args:\n        lst (list): স্ট্রিংগুলির তালিকা\n        \n    Returns:\n        list: প্রতিটি স্ট্রিংকে তালিকাভুক্ত করে ফেরত দেয়\n    \"\"\"\n    return lst\n```"
  },
  {
    "id":258,
    "response":"```python\ndef count_list(lst):\n    \"\"\"\n    Count the occurrences of each element in a list and return a list of tuples.\n    Each tuple contains (element, count).\n    \n    Args:\n        lst: Input list\n        \n    Returns:\n        List of tuples (element, count)\n    \"\"\"\n    count_dict = {}\n    for item in lst:\n        count_dict[item] = count_dict.get(item, 0) + 1\n    \n    return [(item, count) for item, count in count_dict.items()]\n```"
  },
  {
    "id":259,
    "response":"```python\ndef sub_lists(lst):\n    \"\"\"\n    Generate all possible sublists from a given list.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A list of lists, where each inner list is a sublist of the original list\n    \"\"\"\n    result = []\n    \n    # Generate all possible sublists using bit manipulation\n    n = len(lst)\n    for i in range(1 << n):  # 2^n possible subsets (including empty set)\n        sublist = []\n        for j in range(n):\n            if i & (1 << j):  # if j-th bit is set\n                sublist.append(lst[j])\n        if sublist:  # only include non-empty sublists\n            result.append(sublist)\n    \n    return result\n```"
  },
  {
    "id":260,
    "response":"```python\ndef check_alphanumeric(s):\n    \"\"\"\n    Check if a string ends with only alphanumeric characters.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string ends with only alphanumeric characters, False otherwise.\n    \"\"\"\n    if not s:\n        return False\n    \n    # Get the last character and check if it's alphanumeric\n    last_char = s[-1]\n    return last_char.isalnum()\n```"
  },
  {
    "id":261,
    "response":"```python\ndef anagram_lambda(lst, s):\n    \"\"\"\n    Find all strings in the list that are anagrams of the given string s.\n    Uses a lambda function to check anagram condition.\n    \n    Args:\n        lst: List of strings to search in\n        s: String to find anagrams of\n    \n    Returns:\n        List of strings that are anagrams of s\n    \"\"\"\n    # Lambda function to check if two strings are anagrams\n    is_anagram = lambda x, y: sorted(x.lower()) == sorted(y.lower())\n    \n    # Filter the list to find all strings that are anagrams of s\n    return [item for item in lst if is_anagram(item, s)]\n```"
  },
  {
    "id":262,
    "response":"```python\ndef n_common_words(s, n):\n    \"\"\"\n    Find the n most common words in a string.\n    \n    Args:\n        s (str): Input string containing words separated by whitespace.\n        n (int): Number of most common words to return.\n    \n    Returns:\n        list: List of tuples (word, frequency) containing the n most common words.\n    \"\"\"\n    if not s or n <= 0:\n        return []\n    \n    # Convert string to lowercase and split into words\n    words = s.lower().split()\n    \n    # Remove punctuation from words\n    import string\n    words = [''.join(char for char in word if char not in string.punctuation) for word in words]\n    \n    # Filter out empty strings\n    words = [word for word in words if word]\n    \n    # Count word frequencies\n    word_count = {}\n    for word in words:\n        word_count[word] = word_count.get(word, 0) + 1\n    \n    # Sort by frequency in descending order and get top n\n    sorted_words = sorted(word_count.items(), key=lambda x: x[1], reverse=True)\n    \n    return sorted_words[:n]\n```"
  },
  {
    "id":263,
    "response":"```python\ndef find_longest_conseq_subseq(lst, n):\n    \"\"\"\n    Find the length of the longest consecutive subsequence in the list.\n    \n    Args:\n        lst: List of integers\n        n: Length of the list (optional, for safety)\n    \n    Returns:\n        int: Length of the longest consecutive subsequence\n    \"\"\"\n    if not lst:\n        return 0\n    \n    # Convert list to set for O(1) lookup\n    num_set = set(lst)\n    \n    max_length = 0\n    \n    # For each number in the list, check if it's the start of a sequence\n    for num in num_set:\n        # Only start a sequence if num - 1 is not in the set (meaning num is the start)\n        if num - 1 not in num_set:\n            current_num = num\n            current_length = 1\n            \n            # Extend the sequence as long as consecutive numbers exist\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_length += 1\n            \n            # Update max length if current sequence is longer\n            max_length = max(max_length, current_length)\n    \n    return max_length\n```"
  },
  {
    "id":264,
    "response":"```python\ndef palindrome_lambda(lst):\n    \"\"\"\n    ল্যাম্বদা ফাংশন ব্যবহার করে স্ট্রিংগুলির একটি প্রদত্ত তালিকায় প্যালিনড্রোমগুলি খুঁজে পেয়ে ফেরত দেয়।\n    \n    Args:\n        lst: স্ট্রিং গুলির তালিকা\n        \n    Returns:\n        প্যালিনড্রোম স্ট্রিংগুলির তালিকা\n    \"\"\"\n    is_palindrome = lambda s: s.lower() == s.lower()[::-1]\n    return [s for s in lst if is_palindrome(s)]\n```"
  },
  {
    "id":265,
    "response":"```python\ndef ntimes_list(lst, n):\n    \"\"\"Print a list n times.\"\"\"\n    for _ in range(n):\n        print(lst)\n```"
  },
  {
    "id":266,
    "response":"```python\ndef check_monthnumb(month_name):\n    \"\"\"\n    Check if the given month name has 31 days.\n    \n    Args:\n        month_name (str): The name of the month (e.g., \"January\", \"March\")\n    \n    Returns:\n        bool: True if the month has 31 days, False otherwise\n    \"\"\"\n    # Dictionary mapping month names to number of days\n    days_in_month = {\n        \"January\": 31,\n        \"February\": 28,  # 29 in leap year, but we only check for 31\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    \n    # Check if the month name exists in the dictionary and has 31 days\n    return days_in_month.get(month_name.title(), 0) == 31\n```"
  },
  {
    "id":267,
    "response":"```python\ndef min_Num(lst, n):\n    \"\"\"\n    Return the minimum number to add to the list so that the sum becomes divisible by n.\n    \n    Args:\n        lst: List of integers\n        n: Divisor (the target number)\n    \n    Returns:\n        Minimum non-negative integer to add to make the sum divisible by n\n    \"\"\"\n    current_sum = sum(lst)\n    remainder = current_sum % n\n    \n    if remainder == 0:\n        return 0\n    else:\n        return n - remainder\n```"
  },
  {
    "id":268,
    "response":"```python\ndef length_Of_Last_Word(s):\n    \"\"\"\n    Find the length of the last word in a given string.\n    \n    Args:\n        s (str): The input string\n        \n    Returns:\n        int: Length of the last word, or 0 if the string is empty or has no words\n    \"\"\"\n    # Remove leading and trailing whitespaces\n    s = s.strip()\n    \n    # If the string is empty after stripping, return 0\n    if not s:\n        return 0\n    \n    # Split the string by whitespace and get the last word\n    words = s.split()\n    last_word = words[-1]\n    \n    # Return the length of the last word\n    return len(last_word)\n```"
  },
  {
    "id":269,
    "response":"```python\ndef remove_list_range(lst, n, n2):\n    \"\"\"\n    একটি প্রদত্ত তালিকা থেকে প্রদত্ত পরিসরের বাইরে থাকা উপ-তালিকা সরিয়ে ফেলে।\n    \n    Parameters:\n    lst (list): প্রদত্ত তালিকা\n    n (int): পরিসরের শুরুর পয়েন্ট\n    n2 (int): পরিসরের শেষ পয়েন্ট (সংখ্যা সহ সংখ্যা নির্দেশ করে)\n    \n    Returns:\n    list: পরিসরের ভিতরে থাকা উপ-তালিকা\n    \"\"\"\n    return [item for item in lst if n <= item <= n2]\n```"
  },
  {
    "id":270,
    "response":"```python\ndef sum_positivenum(lst):\n    return sum(filter(lambda x: x > 0, lst))\n```"
  },
  {
    "id":271,
    "response":"```python\ndef are_rotations(s, s2):\n    \"\"\"\n    Check if string s2 is a rotation of string s.\n    \n    Args:\n        s (str): The original string\n        s2 (str): The string to check if it's a rotation of s\n        \n    Returns:\n        bool: True if s2 is a rotation of s, False otherwise\n    \"\"\"\n    if len(s) != len(s2):\n        return False\n    \n    # A string is a rotation of another if and only if the second string\n    # appears as a substring in the first string concatenated with itself\n    return s2 in s + s\n```"
  },
  {
    "id":272,
    "response":"```python\ndef check_subset(lst, lst2):\n    \"\"\"\n    Check if the first nested list is a subset of the second nested list.\n    \n    Args:\n        lst: The first nested list (potential subset)\n        lst2: The second nested list (potential superset)\n    \n    Returns:\n        bool: True if lst is a subset of lst2, False otherwise\n    \"\"\"\n    # Convert both lists to sets of tuples to handle nested lists properly\n    set1 = set(tuple(item) for item in lst)\n    set2 = set(tuple(item) for item in lst2)\n    \n    # Check if all elements of set1 are present in set2\n    return set1.issubset(set2)\n```"
  },
  {
    "id":273,
    "response":"```python\ndef fibonacci(n):\n    \"\"\"\n    পুনরাবৃত্তি ব্যবহার করে ফিবোনাক্সি ক্রম সমাধান করে।\n    \n    প্যারামিটার:\n    n (int): ফিবোনাক্সি ক্রমের সংখ্যা নির্দেশ করে।\n    \n    রিটার্ন:\n    int: n-তম ফিবোনাক্সি সংখ্যা।\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for i in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b\n```"
  },
  {
    "id":274,
    "response":"```python\ndef check_Concat(s, s2):\n    \"\"\"\n    Check if string s is the concatenation of string s2 with itself.\n    \n    Args:\n        s (str): The string to check\n        s2 (str): The string to concatenate\n    \n    Returns:\n        bool: True if s is the concatenation of s2 + s2, False otherwise\n    \"\"\"\n    return s == s2 + s2\n```"
  },
  {
    "id":275,
    "response":"```python\ndef min_difference(lst):\n    \"\"\"\n    Find the minimum difference between any two tuples in a list of tuples.\n    \n    Args:\n        lst: A list of tuples.\n    \n    Returns:\n        int: The minimum absolute difference between any two tuples.\n             Returns 0 if the list has fewer than 2 tuples.\n    \"\"\"\n    if len(lst) < 2:\n        return 0\n    \n    min_diff = float('inf')\n    \n    # Compare every pair of tuples\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # Calculate the absolute difference between tuples\n            # Using the sum of absolute differences of corresponding elements\n            diff = sum(abs(a - b) for a, b in zip(lst[i], lst[j]))\n            min_diff = min(min_diff, diff)\n    \n    return min_diff\n```"
  },
  {
    "id":276,
    "response":"```python\ndef lcm(n, n2):\n    \"\"\"\n    দুইটি ধনাত্মক পূর্ণসংখ্যার LCM (Least Common Multiple) খুঁজে বের করে।\n    \n    প্রক্রিয়া: \n    LCM(a, b) = (a * b) \/ GCD(a, b)\n    \n    Parameters:\n    n (int): প্রথম ধনাত্মক পূর্ণসংখ্যা\n    n2 (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা\n    \n    Returns:\n    int: n এবং n2 এর LCM\n    \"\"\"\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    return (n * n2) \/\/ gcd(n, n2)\n```"
  },
  {
    "id":277,
    "response":"```python\ndef sort_string(s):\n    \"\"\"\n    Sorts the characters of the given string in ascending order.\n    \n    Args:\n        s (str): The input string to be sorted.\n    \n    Returns:\n        str: A new string with characters sorted in ascending order.\n    \"\"\"\n    return ''.join(sorted(s))\n```"
  },
  {
    "id":278,
    "response":"```python\ndef check_tuples(tup, k):\n    \"\"\"\n    Check if the given tuple has exactly k elements.\n    \n    Args:\n        tup: The tuple to check\n        k: The number of elements to check against\n    \n    Returns:\n        bool: True if the tuple has exactly k elements, False otherwise\n    \"\"\"\n    return len(tup) == k\n```"
  },
  {
    "id":279,
    "response":"```python\nimport re\n\ndef text_match(s):\n    \"\"\"\n    Check if a string has 'a' followed by some characters and ends with 'b'.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string starts with 'a' followed by any characters and ends with 'b', otherwise False.\n    \"\"\"\n    pattern = r'a.*b$'\n    return bool(re.search(pattern, s))\n```"
  },
  {
    "id":280,
    "response":"```python\ndef Check_Solution(n, n2, n3):\n    \"\"\"\n    বর্গক্ষেত্র সমীকরণের সমাধানের সংখ্যা খুঁজে বের করে।\n    \n    বর্গক্ষেত্র সমীকরণ: ax^2 + bx + c = 0\n    এখানে n, n2, n3 হল যথাক্রমে a, b, c এর মান।\n    \n    ফাংশনটি সমীকরণের সমাধানের সংখ্যা কে রিটার্ন করে:\n    - 2 যদি সমাধান দুটি থাকে (বাস্তব ও বিভিন্ন)\n    - 1 যদি সমাধান একটি থাকে (বাস্তব ও সমান)\n    - 0 যদি সমাধান না থাকে (বাস্তব না থাকে)\n    \n    Parameters:\n    n (float): সমীকরণের সহগ কোয়াড্রেটিক (a)\n    n2 (float): সমীকরণের সহগ লাইনার (b)\n    n3 (float): সমীকরণের সহগ স্থানান্তর (c)\n    \n    Returns:\n    int: বাস্তব সমাধানের সংখ্যা\n    \"\"\"\n    # যদি a = 0 হয় তবে এটি কোয়াড্রেটিক না হবে\n    if n == 0:\n        if n2 == 0:\n            if n3 == 0:\n                return 1  # 0 = 0, অসীম সমাধান\n            else:\n                return 0  # অসম সমীকরণ\n        else:\n            # লাইনার সমীকরণ: bx + c = 0\n            return 1 if n2 != 0 else 0\n    \n    # কোয়াড্রেটিক সমীকরণের জন্য ডিসক্রিমিন্যান্ট\n    discriminant = n2**2 - 4*n*n3\n    \n    if discriminant > 0:\n        return 2  # দুটি বাস্তব ও বিভিন্ন সমাধান\n    elif discriminant == 0:\n        return 1  # একটি বাস্তব সমাধান (দুটি সমান)\n    else:\n        return 0  # বাস্তব সমাধান নেই\n```"
  },
  {
    "id":281,
    "response":"```python\ndef sum_even_odd(lst):\n    \"\"\"\n    প্রদত্ত তালিকার প্রথম সম সংখ্যা এবং প্রথম অদ্ভুত সংখ্যার যোগফল খুঁজে বের করে।\n    \n    সম সংখ্যা: যে সংখ্যা 2 দ্বারা বিভাজ্য।\n    অদ্ভুত সংখ্যা: যে সংখ্যার অঙ্কগুলি সমান হয় না এবং একটি সংখ্যা যার অঙ্কগুলি সমান হয় না এবং সংখ্যাটি একটি অদ্ভুত সংখ্যা হিসেবে গণ্য হয়।\n    \n    প্রথম সম সংখ্যা এবং প্রথম অদ্ভুত সংখ্যা খুঁজে পাওয়া যায়।\n    \n    Parameters:\n    lst (list): সংখ্যা বিশিষ্ট তালিকা।\n    \n    Returns:\n    int: প্রথম সম সংখ্যা এবং প্রথম অদ্ভুত সংখ্যার যোগফল।\n    \"\"\"\n    if not lst:\n        return 0\n    \n    def is_odd_number(n):\n        \"\"\"সংখ্যা অদ্ভুত কিনা চেক করে।\"\"\"\n        s = str(n)\n        return len(set(s)) == len(s)  # অঙ্কগুলি সমান হয় না হলে অদ্ভুত সংখ্যা।\n    \n    # প্রথম সম সংখ্যা খুঁজে বের করা\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0:\n            first_even = num\n            break\n    \n    # প্রথম অদ্ভুত সংখ্যা খুঁজে বের করা\n    for num in lst:\n        if is_odd_number(num):\n            first_odd = num\n            break\n    \n    # যদি কোনো সম সংখ্যা বা অদ্ভুত সংখ্যা না থাকে তবে 0 রিটার্ন করা\n    if first_even is None:\n        first_even = 0\n    if first_odd is None:\n        first_odd = 0\n    \n    return first_even + first_odd\n```"
  },
  {
    "id":282,
    "response":"```python\ndef parallelogram_perimeter(n, n2):\n    \"\"\"\n    সমান্তরালের পরিধি গণনা করে।\n    \n    প্রমাণ: সমান্তরালের পরিধি = 2 * (প্রথম পাশ + দ্বিতীয় পাশ)\n    \n    Parameters:\n    n (float): প্রথম পাশের দৈর্ঘ্য\n    n2 (float): দ্বিতীয় পাশের দৈর্ঘ্য\n    \n    Returns:\n    float: সমান্তরালের পরিধি\n    \"\"\"\n    return 2 * (n + n2)\n```"
  },
  {
    "id":283,
    "response":"```python\ndef div_of_nums(lst, m, n):\n    \"\"\"\n    ল্যাম্বদা ফাংশন ব্যবহার করে সংখ্যার তালিকা থেকে m এবং n দ্বারা বিভাজ্য সংখ্যা খুঁজে বের করে।\n    \n    প্যারামিটার:\n    lst: সংখ্যার তালিকা\n    m: প্রথম বিভাজ্য সংখ্যা\n    n: দ্বিতীয় বিভাজ্য সংখ্যা\n    \n    রিটার্ন:\n    m এবং n দ্বারা বিভাজ্য সংখ্যার তালিকা\n    \"\"\"\n    return list(filter(lambda x: x % m == 0 and x % n == 0, lst))\n```"
  },
  {
    "id":284,
    "response":"```python\ndef all_Bits_Set_In_The_Given_Range(n, n2, n3):\n    \"\"\"\n    Check if all bits of n are set within the range [n2, n3].\n    \n    Args:\n        n: The number whose bits are to be checked.\n        n2: The lower bound of the range (inclusive).\n        n3: The upper bound of the range (inclusive).\n    \n    Returns:\n        True if all bits of n are within the range [n2, n3], False otherwise.\n    \"\"\"\n    # Convert n to its binary representation and remove '0b' prefix\n    binary_n = bin(n)[2:]\n    \n    # Convert n2 and n3 to binary and ensure they have the same length\n    binary_n2 = bin(n2)[2:]\n    binary_n3 = bin(n3)[2:]\n    \n    # Pad the binary strings to the same length\n    max_len = max(len(binary_n), len(binary_n2), len(binary_n3))\n    binary_n = binary_n.zfill(max_len)\n    binary_n2 = binary_n2.zfill(max_len)\n    binary_n3 = binary_n3.zfill(max_len)\n    \n    # Check if all bits of n are within the range [n2, n3]\n    # This means that for each bit position, the bit value of n should be\n    # between the corresponding bits of n2 and n3 (inclusive)\n    \n    for i in range(len(binary_n)):\n        bit_n = int(binary_n[i])\n        bit_n2 = int(binary_n2[i])\n        bit_n3 = int(binary_n3[i])\n        \n        # If the bit of n is outside the range of bits in n2 and n3, return False\n        if bit_n < bit_n2 or bit_n > bit_n3:\n            return False\n    \n    return True\n```"
  },
  {
    "id":285,
    "response":"```python\ndef is_isomorphic(s, s2):\n    \"\"\"\n    Check if two strings are isomorphic.\n    Two strings are isomorphic if there is a one-to-one mapping between their characters.\n    \n    Args:\n        s (str): First string\n        s2 (str): Second string\n    \n    Returns:\n        bool: True if strings are isomorphic, False otherwise\n    \"\"\"\n    if len(s) != len(s2):\n        return False\n    \n    # Maps from character in s to character in s2\n    s_to_s2 = {}\n    # Maps from character in s2 to character in s\n    s2_to_s = {}\n    \n    for i in range(len(s)):\n        char1, char2 = s[i], s2[i]\n        \n        # If char1 is already mapped, check if it maps to the same char2\n        if char1 in s_to_s2:\n            if s_to_s2[char1] != char2:\n                return False\n        else:\n            s_to_s2[char1] = char2\n        \n        # If char2 is already mapped, check if it maps to the same char1\n        if char2 in s2_to_s:\n            if s2_to_s[char2] != char1:\n                return False\n        else:\n            s2_to_s[char2] = char1\n    \n    return True\n```"
  },
  {
    "id":286,
    "response":"```python\ndef sum_num(tup):\n    \"\"\"\n    একটি তালিকার সব সংখ্যা যোগ করে এবং তালিকার দৈর্ঘ্যের সাথে ভাগ করে।\n    \n    প্যারামিটার:\n    tup: একটি সংখ্যা বিশিষ্ট তালিকা (তালিকা বা টাপল)\n    \n    রিটার্ন:\n    সংখ্যা এর গড় (সমষ্টি \/ দৈর্ঘ্য)\n    \"\"\"\n    if not tup:\n        return 0\n    \n    total = sum(tup)\n    length = len(tup)\n    return total \/ length\n```"
  },
  {
    "id":287,
    "response":"```python\ndef is_odd(n):\n    \"\"\"\n    বিটওয়াইস অপারেটর ব্যবহার করে প্রদত্ত সংখ্যাটি অদ্ভুত কিনা তা পরীক্ষা করে।\n    \n    একটি সংখ্যা অদ্ভুত হলে তার সবথেকে ডান বিট (লস্ট বিট) 1 হবে।\n    এটি বিটওয়াইস এ্যান্ড অপারেটর (&) দিয়ে পরীক্ষা করা যায় যখন 1 এর সাথে সংখ্যাটির বিট অপারেট করা হয়।\n    \n    Parameters:\n        n (int): পরীক্ষা করা হবে সংখ্যা\n    \n    Returns:\n        bool: সংখ্যা অদ্ভুত হলে True, নাহলে False\n    \"\"\"\n    return n & 1 == 1\n```"
  },
  {
    "id":288,
    "response":"```python\ndef substract_elements(tup, tup2):\n    \"\"\"\n    দুটি নেস্টেড টুপলের উপাদানগুলি বিয়োগ করে একটি নতুন টুপল রিটার্ন করে।\n    \n    Args:\n        tup: প্রথম নেস্টেড টুপল\n        tup2: দ্বিতীয় নেস্টেড টুপল\n    \n    Returns:\n        উপাদানগুলি বিয়োগের ফলাফল হিসাবে একটি নতুন টুপল\n    \"\"\"\n    result = []\n    for i in range(len(tup)):\n        if len(tup[i]) == len(tup2[i]):\n            # উপাদানগুলি বিয়োগ করা হয়\n            result.append(tuple(a - b for a, b in zip(tup[i], tup2[i])))\n        else:\n            # উপাদানের সংখ্যা মিলে না থাকলে একটি ত্রুটি তৈরি করা হবে\n            raise ValueError(f\"উপাদানের সংখ্যা মিলে না থাকলে: টুপল {i} এর দৈর্ঘ্য {len(tup[i])} এবং {len(tup2[i])}\")\n    return tuple(result)\n```"
  },
  {
    "id":289,
    "response":"```python\ndef reverse_list_lists(lst):\n    \"\"\"\n    Reverse each sublist in a list of lists.\n    \n    Args:\n        lst: A list of lists\n        \n    Returns:\n        A new list where each sublist is reversed\n    \"\"\"\n    return [sublist[::-1] for sublist in lst]\n```"
  },
  {
    "id":290,
    "response":"```python\ndef find_Extra(lst, lst2, n):\n    \"\"\"\n    সাজানো অ্যারেতে উপস্থিত অতিরিক্ত উপাদানগুলির সূচকটি খুঁজে পেয়ে ফেরত দেয়।\n    \n    প্যারামিটার:\n    lst: প্রথম সাজানো অ্যারে\n    lst2: দ্বিতীয় সাজানো অ্যারে\n    n: অ্যারের দৈর্ঘ্য\n    \n    রিটার্ন:\n    অতিরিক্ত উপাদানের সূচক (ইনডেক্স), যদি অতিরিক্ত উপাদান থাকে, অন্যথায় -1\n    \"\"\"\n    # যদি দুটি অ্যারে একই হয় তবে কোনও অতিরিক্ত উপাদান নেই\n    if lst == lst2:\n        return -1\n    \n    # দুটি অ্যারের মধ্যে উপাদানগুলি তুলনা করে অতিরিক্ত উপাদান খুঁজে পাবে\n    for i in range(n):\n        if lst[i] != lst2[i]:\n            return i\n    \n    return -1\n```"
  },
  {
    "id":291,
    "response":"```python\ndef same_length(n, n2):\n    \"\"\"\n    Check if two numbers have the same number of digits.\n    \n    Args:\n        n: First number\n        n2: Second number\n    \n    Returns:\n        bool: True if both numbers have the same number of digits, False otherwise\n    \"\"\"\n    return len(str(abs(n))) == len(str(abs(n2)))\n```"
  },
  {
    "id":292,
    "response":"```python\ndef remove_spaces(s):\n    \"\"\"\n    একটি স্ট্রিংয়ে একাধিক স্পেস অপসারণ করে একটি স্পেস বা কোনও স্পেস না থাকা স্ট্রিং রিটার্ন করে।\n    \n    Args:\n        s (str): স্পেস অপসারণের জন্য দেওয়া স্ট্রিং\n        \n    Returns:\n        str: স্পেস অপসারণ করা স্ট্রিং\n    \"\"\"\n    return ' '.join(s.split())\n```"
  },
  {
    "id":293,
    "response":"```python\ndef extract(lst):\n    \"\"\"\n    Extract the last element from each sublist in a list of lists.\n    \n    Args:\n        lst: A list of lists (sublists)\n    \n    Returns:\n        A list containing the last element from each sublist\n    \"\"\"\n    return [sublist[-1] for sublist in lst]\n```"
  },
  {
    "id":294,
    "response":"```python\ndef float_to_tuple(s):\n    \"\"\"\n    প্রদত্ত স্ট্রিংকে ফ্লোট টাইপের মানগুলি সংযোজন করে একটি টাইপ তৈরি করে।\n    \n    উদাহরণ:\n    float_to_tuple(\"1.5,2.3,4.7\") -> (1.5, 2.3, 4.7)\n    \n    প্যারামিটার:\n    s (str): ফ্লোট মানগুলি কমা দিয়ে স্পেস দিয়ে স্ট্রিং হবে।\n    \n    রিটার্ন:\n    tuple: ফ্লোট মানগুলি যে কোন অর্ডারে সংযোজন করে তৈরি করা হয়।\n    \"\"\"\n    if not s or not isinstance(s, str):\n        return ()\n    \n    # স্ট্রিং থেকে কমা দিয়ে ভাগ করে প্রতিটি স্ট্রিং কে ফ্লোটে রূপান্তর করা\n    parts = s.strip().split(',')\n    result = []\n    \n    for part in parts:\n        part = part.strip()\n        if part:\n            try:\n                result.append(float(part))\n            except ValueError:\n                continue  # কোন ফ্লোট হিসাবে রূপান্তর করা যায় না তবে সেটা স্কিপ করা হবে\n    \n    return tuple(result)\n```"
  },
  {
    "id":295,
    "response":"```python\ndef max_sum_subseq(lst):\n    \"\"\"\n    Find the maximum sum of a contiguous subsequence in the given list.\n    This is known as the maximum subarray problem, solved using Kadane's algorithm.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        The maximum sum of a contiguous subsequence\n    \"\"\"\n    if not lst:\n        return 0\n    \n    max_sum = lst[0]\n    current_sum = lst[0]\n    \n    for num in lst[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```"
  },
  {
    "id":296,
    "response":"```python\ndef sort_list_last(lst):\n    \"\"\"\n    একটি তালিকাকে বর্ধমান ক্রমে সাজায়।\n    \n    এই ফাংশনটি তালিকার শেষ উপাদানগুলির আলাদা করে সাজায়।\n    \n    Args:\n        lst: একটি তালিকা\n        \n    Returns:\n        বর্ধমান ক্রমে সাজানো তালিকা\n    \"\"\"\n    return sorted(lst)\n```"
  },
  {
    "id":297,
    "response":"```python\ndef is_word_present(s, s2):\n    \"\"\"\n    Check if the word s2 is present in the sentence s.\n    \n    Args:\n        s (str): The sentence to search in.\n        s2 (str): The word to search for.\n    \n    Returns:\n        bool: True if s2 is found in s, False otherwise.\n    \"\"\"\n    return s2 in s\n```"
  },
  {
    "id":298,
    "response":"```python\ndef extract_elements(lst, n):\n    \"\"\"\n    একটি নির্দিষ্ট তালিকা থেকে নির্দিষ্ট সংখ্যক উপাদান বের করে এবং একে অপরকে ক্রমাগত অনুসরণ করে।\n    \n    Args:\n        lst: তালিকা\n        n: বের করার জন্য উপাদানের সংখ্যা\n    \n    Returns:\n        প্রথম n টি উপাদানের তালিকা\n    \"\"\"\n    return lst[:n]\n```"
  },
  {
    "id":299,
    "response":"```python\ndef check(lst, n):\n    \"\"\"\n    Check if the array contains only elements that are equal to n.\n    \n    Args:\n        lst: List of elements to check\n        n: The value to check against\n    \n    Returns:\n        bool: True if all elements in the list are equal to n, False otherwise\n    \"\"\"\n    return all(element == n for element in lst)\n```"
  },
  {
    "id":300,
    "response":"```python\ndef match_num(s, num):\n    \"\"\"\n    Check if a string starts with a specific number.\n    \n    Args:\n        s (str): The string to check.\n        num (int): The number to check if the string starts with.\n    \n    Returns:\n        bool: True if the string starts with the number, False otherwise.\n    \"\"\"\n    # Convert the number to string for comparison\n    num_str = str(num)\n    # Check if the string starts with the number string\n    return s.startswith(num_str)\n```"
  },
  {
    "id":301,
    "response":"```python\ndef num_comm_div(n, n2):\n    \"\"\"\n    দুটি সংখ্যার মধ্যে সাধারণ বিভাজক খুঁজে পায়।\n    \n    Parameters:\n    n (int): প্রথম সংখ্যা\n    n2 (int): দ্বিতীয় সংখ্যা\n    \n    Returns:\n    int: সাধারণ বিভাজকের সংখ্যা\n    \"\"\"\n    # দুটি সংখ্যার গুণিতক নির্ণয় করে সাধারণ বিভাজক খুঁজে পায়\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    # সাধারণ বিভাজক সংখ্যা হল গুণিতকের সংখ্যা\n    g = gcd(n, n2)\n    \n    # সাধারণ বিভাজকের সংখ্যা হল গুণিতকের সংখ্যা\n    count = 0\n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            count += 1\n            if i != g \/\/ i:\n                count += 1\n    \n    return count\n```"
  },
  {
    "id":302,
    "response":"```python\ndef find_remainder(n, n2):\n    \"\"\"\n    দুটি সংখ্যার অবশিষ্ট খুঁজে বের করে।\n    \n    প্যারামিটার:\n    n (int): প্রথম সংখ্যা\n    n2 (int): দ্বিতীয় সংখ্যা\n    \n    রিটার্ন:\n    int: n এর প্রতি n2 এর অবশিষ্ট\n    \"\"\"\n    return n % n2\n```"
  },
  {
    "id":303,
    "response":"```python\ndef add_consecutive_nums(lst):\n    \"\"\"\n    প্রদত্ত তালিকার পরপর সংখ্যা যোগ করে একটি নতুন তালিকা তৈরি করে।\n    \n    উদাহরণ:\n    add_consecutive_nums([1, 2, 3, 4, 5]) -> [3, 5, 7, 9]\n    \"\"\"\n    if not lst:\n        return []\n    \n    result = []\n    for i in range(len(lst) - 1):\n        result.append(lst[i] + lst[i + 1])\n    \n    return result\n```"
  },
  {
    "id":304,
    "response":"```python\ndef sum_Of_Series(n):\n    \"\"\"\n    প্রথম n টি প্রাকৃতিক সংখ্যার ঘনক্ষেত্রের যোগফল খুঁজে বের করে।\n    \n    প্রথম n টি প্রাকৃতিক সংখ্যা: 1, 2, 3, ..., n\n    ঘনক্ষেত্র: 1^3, 2^3, 3^3, ..., n^3\n    যোগফল: 1^3 + 2^3 + 3^3 + ... + n^3\n    \n    এই যোগফল হয় (n(n+1)\/2)^2\n    \n    Parameters:\n    n (int): প্রথম n টি প্রাকৃতিক সংখ্যা পর্যন্ত যোগফল বের করা হবে।\n    \n    Returns:\n    int: প্রথম n টি প্রাকৃতিক সংখ্যার ঘনক্ষেত্রের যোগফল।\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # প্রথম n টি প্রাকৃতিক সংখ্যার ঘনক্ষেত্রের যোগফল = (n(n+1)\/2)^2\n    return (n * (n + 1) \/\/ 2) ** 2\n```"
  },
  {
    "id":305,
    "response":"```python\ndef re_order(lst):\n    \"\"\"\n    সব শূন্যকে প্রদত্ত অ্যারের শেষে সরিয়ে দেয়।\n    \n    Args:\n        lst: একটি পূর্ণ সংখ্যা অ্যারে\n        \n    Returns:\n        শূন্যগুলি শেষে রাখা অ্যারে\n    \"\"\"\n    non_zeros = [x for x in lst if x != 0]\n    return non_zeros + [0] * (len(lst) - len(non_zeros))\n```"
  },
  {
    "id":306,
    "response":"```python\ndef permutation_coefficient(n, k):\n    \"\"\"\n    Calculate the permutation coefficient P(n, k) = n! \/ (n-k)!\n    \n    Args:\n        n (int): Total number of items\n        k (int): Number of items to arrange\n    \n    Returns:\n        int: Permutation coefficient P(n, k)\n    \n    Raises:\n        ValueError: If k > n or if n or k is negative\n    \"\"\"\n    if k < 0 or n < 0:\n        raise ValueError(\"n and k must be non-negative\")\n    \n    if k > n:\n        return 0\n    \n    if k == 0 or k == n:\n        return 1\n    \n    # Calculate P(n, k) = n * (n-1) * (n-2) * ... * (n-k+1)\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n    \n    return result\n```"
  },
  {
    "id":307,
    "response":"```python\ndef remove_words(lst, lst2):\n    \"\"\"\n    নির্দিষ্ট তালিকা থেকে নির্দিষ্ট শব্দগুলি অপসারণ করে।\n    \n    প্যারামিটার:\n    lst: শব্দগুলি থাকা তালিকা\n    lst2: অপসারণের জন্য শব্দগুলির তালিকা\n    \n    রিটার্ন:\n    শব্দগুলি অপসারণ করে প্রাপ্ত তালিকা\n    \"\"\"\n    return [word for word in lst if word not in lst2]\n```"
  },
  {
    "id":308,
    "response":"```python\ndef same_order(lst, lst2):\n    \"\"\"\n    Check if two lists have the same elements in the same order.\n    \n    Args:\n        lst: First list to compare\n        lst2: Second list to compare\n    \n    Returns:\n        bool: True if both lists have the same elements in the same order, False otherwise\n    \"\"\"\n    return lst == lst2\n```"
  },
  {
    "id":309,
    "response":"```python\ndef average_odd(n):\n    \"\"\"\n    Calculate the average of all odd numbers from 1 to n (inclusive).\n    \n    Args:\n        n (int): The upper limit (inclusive)\n    \n    Returns:\n        float: The average of all odd numbers from 1 to n\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # Find all odd numbers from 1 to n\n    odd_numbers = [i for i in range(1, n + 1, 2)]\n    \n    # Calculate the average\n    if odd_numbers:\n        return sum(odd_numbers) \/ len(odd_numbers)\n    else:\n        return 0\n```"
  },
  {
    "id":310,
    "response":"```python\ndef no_of_subsequences(lst, k):\n    \"\"\"\n    Find the number of subsequences in the given non-negative array where \n    the product of elements in the subsequence is less than k.\n    \n    Args:\n        lst: List of non-negative integers\n        k: Threshold value (product should be less than k)\n    \n    Returns:\n        Integer count of such subsequences\n    \"\"\"\n    n = len(lst)\n    count = 0\n    \n    # Generate all possible subsequences using bit manipulation\n    for mask in range(1, 1 << n):\n        product = 1\n        valid = True\n        \n        for i in range(n):\n            if mask & (1 << i):\n                product *= lst[i]\n                if product >= k:\n                    valid = False\n                    break\n        \n        if valid:\n            count += 1\n    \n    return count\n```"
  },
  {
    "id":311,
    "response":"```python\ndef find_Min_Sum(n):\n    \"\"\"\n    Find the minimum sum of factors of a given number n.\n    \n    Args:\n        n (int): The given number\n        \n    Returns:\n        int: The minimum sum of factors of n\n    \"\"\"\n    if n == 1:\n        return 1\n    \n    # Find all factors of n\n    factors = []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            factors.append(i)\n            if i != n \/\/ i:\n                factors.append(n \/\/ i)\n        i += 1\n    \n    # Return the sum of all factors\n    return sum(factors)\n```"
  },
  {
    "id":312,
    "response":"```python\ndef count_element_freq(tup):\n    \"\"\"\n    Count the frequency of elements in a nested tuple.\n    \n    Args:\n        tup: A nested tuple (can contain tuples, lists, or other iterables)\n    \n    Returns:\n        A dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq = {}\n    \n    def traverse(element):\n        if isinstance(element, tuple):\n            for item in element:\n                traverse(item)\n        elif isinstance(element, list):\n            for item in element:\n                traverse(item)\n        else:\n            freq[element] = freq.get(element, 0) + 1\n    \n    traverse(tup)\n    return freq\n```"
  },
  {
    "id":313,
    "response":"```python\ndef add_str(tup, s):\n    \"\"\"\n    প্রতিটি উপাদানের পরে দেওয়া স্ট্রিং যোগ করে টিপলকে তালিকায় রূপান্তর করে।\n    \n    উদাহরণ:\n    add_str((1, 2, 3), \"a\") -> [1, 'a', 2, 'a', 3, 'a']\n    \n    প্যারামিটার:\n    tup: টিপল যা রূপান্তর করা হবে\n    s: যোগ করা হবে স্ট্রিং\n    \n    রিটার্ন:\n    তালিকা (list) যেখানে প্রতিটি উপাদানের পরে s যোগ হয়েছে\n    \"\"\"\n    result = []\n    for item in tup:\n        result.append(item)\n        result.append(s)\n    return result\n```"
  },
  {
    "id":314,
    "response":"```python\ndef sum_elements(tup):\n    \"\"\"\n    Calculate the sum of all elements in a tuple.\n    \n    Args:\n        tup: A tuple containing numbers\n        \n    Returns:\n        int or float: The sum of all elements in the tuple\n    \"\"\"\n    return sum(tup)\n```"
  },
  {
    "id":315,
    "response":"```python\ndef modular_sum(lst, m, n, n2):\n    \"\"\"\n    Check if there exists a subset of the list whose sum is divisible by m.\n    \n    Args:\n        lst: List of integers\n        m: Divisor to check divisibility against\n        n: First parameter (not used in current logic)\n        n2: Second parameter (not used in current logic)\n    \n    Returns:\n        True if there exists a subset with sum divisible by m, False otherwise\n    \"\"\"\n    # If m is 0, any sum is divisible by 0 (undefined), so return False\n    if m == 0:\n        return False\n    \n    # Use dynamic programming to check if any subset sum is divisible by m\n    # dp[i] will be True if sum i (mod m) is achievable\n    dp = [False] * m\n    dp[0] = True  # Empty subset has sum 0, which is divisible by m\n    \n    for num in lst:\n        # Traverse backwards to avoid using the same element multiple times\n        new_dp = dp[:]\n        for remainder in range(m):\n            if dp[remainder]:\n                new_remainder = (remainder + num) % m\n                new_dp[new_remainder] = True\n        dp = new_dp\n    \n    # Check if sum 0 (divisible by m) is achievable\n    return dp[0]\n```"
  },
  {
    "id":316,
    "response":"```python\ndef radix_sort(lst):\n    \"\"\"\n    র্যাডিক্স বাছাই ব্যবহার করে একটি তালিকা বাছাই করে।\n    \n    প্যারামিটার:\n    lst: একটি পূর্ণ সংখ্যা তালিকা (non-negative integers)\n    \n    রিটার্ন:\n    বাছাই করা তালিকা\n    \"\"\"\n    if not lst:\n        return lst\n    \n    # সব উপাদানের সর্বোচ্চ অঙ্কের স্থান বের করা\n    max_num = max(lst)\n    max_digits = len(str(max_num))\n    \n    # প্রতিটি অঙ্কের স্থানে বাছাই করা\n    for digit_place in range(max_digits):\n        # বাছাই করার জন্য ব্যবহার করা হবে স্ট্রিং বাছাই\n        buckets = [[] for _ in range(10)]\n        \n        # প্রতিটি উপাদান বিশ্লেষণ করা হবে প্রতি অঙ্কের জন্য\n        for num in lst:\n            # বর্তমান অঙ্কের স্থানের মান বের করা\n            digit = (num \/\/ (10 ** digit_place)) % 10\n            buckets[digit].append(num)\n        \n        # বাছাই করা উপাদানগুলি ফেরত দেওয়া হবে\n        lst = []\n        for bucket in buckets:\n            lst.extend(bucket)\n    \n    return lst\n```"
  },
  {
    "id":317,
    "response":"```python\ndef largest_pos(lst):\n    \"\"\"\n    প্রদত্ত তালিকা থেকে বৃহত্তম ধনাত্মক সংখ্যা খুঁজে পায়।\n    \n    Parameters:\n    lst (list): ধনাত্মক ও নেগেটিভ সংখ্যা বা শূন্য বিশিষ্ট তালিকা।\n    \n    Returns:\n    int or None: বৃহত্তম ধনাত্মক সংখ্যা। যদি কোনো ধনাত্মক সংখ্যা না থাকে তবে None।\n    \"\"\"\n    largest = None\n    for num in lst:\n        if num > 0 and (largest is None or num > largest):\n            largest = num\n    return largest\n```"
  },
  {
    "id":318,
    "response":"```python\ndef sqrt_root(n):\n    \"\"\"\n    একটি পূর্ণসংখ্যার বর্গমূল নির্ণয় করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    n (int): বর্গমূল নির্ণয়ের জন্য পূর্ণসংখ্যা\n    \n    রিটার্ন:\n    int: n এর বর্গমূল (যদি n একটি পূর্ণসংখ্যার বর্গ হয়), অন্যথায় কোন মান ফেরত না দেয়\n    \"\"\"\n    if n < 0:\n        return None\n    \n    if n == 0 or n == 1:\n        return n\n    \n    # বর্গমূল নির্ণয়ের জন্য বিস্তারিত পদ্ধতি (বর্গমূল নির্ণয়ের জন্য বিস্তারিত পদ্ধতি)\n    # এখানে আমরা বর্গমূল নির্ণয়ের জন্য বিস্তারিত পদ্ধতি ব্যবহার করব\n    left, right = 1, n\n    result = 1\n    \n    while left <= right:\n        mid = (left + right) \/\/ 2\n        square = mid * mid\n        \n        if square == n:\n            return mid\n        elif square < n:\n            left = mid + 1\n            result = mid\n        else:\n            right = mid - 1\n    \n    return result\n```"
  },
  {
    "id":319,
    "response":"```python\ndef volume_tetrahedron(n):\n    \"\"\"\n    একটি টেট্রাহেড্রনের আয়তন গণনা করে।\n    \n    প্যারামিটার:\n    n (float): টেট্রাহেড্রনের একটি ফালের দৈর্ঘ্য (সব ফাল সমান)\n    \n    রিটার্ন:\n    float: টেট্রাহেড্রনের আয়তন\n    \"\"\"\n    return (n ** 3) \/ (6 * 3 ** 0.5)\n```"
  },
  {
    "id":320,
    "response":"```python\nimport math\nfrom functools import reduce\n\ndef get_lcm(lst):\n    \"\"\"\n    Calculate the LCM (Least Common Multiple) of all elements in the given list.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        The LCM of all elements in the list\n        \n    Example:\n        get_lcm([12, 18, 24]) returns 72\n    \"\"\"\n    if not lst:\n        return 0\n    \n    def lcm(a, b):\n        return abs(a * b) \/\/ math.gcd(a, b)\n    \n    return reduce(lcm, lst)\n```"
  },
  {
    "id":321,
    "response":"```python\ndef check_isosceles(n, n2, n3):\n    \"\"\"\n    Check if a triangle is isosceles (has at least two equal sides).\n    \n    Args:\n        n, n2, n3: The three side lengths of the triangle.\n    \n    Returns:\n        True if the triangle is isosceles, False otherwise.\n    \"\"\"\n    return n == n2 or n2 == n3 or n == n3\n```"
  },
  {
    "id":322,
    "response":"```python\ndef lbs(lst):\n    \"\"\"\n    Find the length of the longest bitonic subsequence in the given list.\n    \n    A bitonic subsequence is a sequence that first increases (non-decreasing) \n    and then decreases (non-increasing).\n    \n    Args:\n        lst: List of integers\n        \n    Returns:\n        Integer representing the length of the longest bitonic subsequence\n    \"\"\"\n    if not lst:\n        return 0\n    \n    n = len(lst)\n    \n    # Calculate length of longest increasing subsequence ending at each index\n    inc = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if lst[j] < lst[i]:\n                inc[i] = max(inc[i], inc[j] + 1)\n    \n    # Calculate length of longest decreasing subsequence starting at each index\n    dec = [1] * n\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1, n):\n            if lst[j] < lst[i]:\n                dec[i] = max(dec[i], dec[j] + 1)\n    \n    # The length of longest bitonic subsequence is the maximum of (inc[i] + dec[i] - 1)\n    max_length = 0\n    for i in range(n):\n        max_length = max(max_length, inc[i] + dec[i] - 1)\n    \n    return max_length\n```"
  },
  {
    "id":323,
    "response":"```python\ncheck_string = lambda s: len(s) >= 1 and any(c.isupper() for c in s) and any(c.islower() for c in s) and any(c.isdigit() for c in s)\n```"
  },
  {
    "id":324,
    "response":"```python\ndef max_sum_increasing_subsequence(lst, n):\n    \"\"\"\n    Find the maximum sum of an increasing subsequence in the given array.\n    \n    Args:\n        lst: List of integers\n        n: Length of the array\n    \n    Returns:\n        Maximum sum of an increasing subsequence\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    # dp[i] represents the maximum sum of increasing subsequence ending at index i\n    dp = [0] * n\n    dp[0] = lst[0]\n    \n    for i in range(1, n):\n        dp[i] = lst[i]  # At minimum, we can have just the current element\n        \n        # Check all previous elements to find if we can extend an increasing subsequence\n        for j in range(i):\n            if lst[j] < lst[i]:  # Increasing condition\n                dp[i] = max(dp[i], dp[j] + lst[i])\n    \n    # Return the maximum sum among all ending positions\n    return max(dp)\n```"
  },
  {
    "id":325,
    "response":"```python\ndef parallel_lines(line1, line2):\n    \"\"\"\n    Check if two lines are parallel.\n    \n    Args:\n        line1: A tuple (slope, intercept) representing the first line.\n        line2: A tuple (slope, intercept) representing the second line.\n    \n    Returns:\n        bool: True if the lines are parallel, False otherwise.\n    \"\"\"\n    # Two lines are parallel if their slopes are equal\n    slope1, _ = line1\n    slope2, _ = line2\n    \n    return abs(slope1 - slope2) < 1e-9  # Using small epsilon for floating point comparison\n```"
  },
  {
    "id":326,
    "response":"```python\ndef capitalize_first_last_letters(s):\n    \"\"\"\n    Takes a string and capitalizes the first and last letters of each word.\n    Words are separated by whitespace.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: String with first and last letters of each word capitalized\n    \"\"\"\n    if not s:\n        return s\n    \n    words = s.split()\n    result = []\n    \n    for word in words:\n        if len(word) == 1:\n            result.append(word.upper())\n        else:\n            first_letter = word[0].upper()\n            last_letter = word[-1].upper()\n            middle = word[1:-1]\n            result.append(first_letter + middle + last_letter)\n    \n    return ' '.join(result)\n```"
  },
  {
    "id":327,
    "response":"```python\ndef get_pairs_count(lst, n, n2):\n    \"\"\"\n    একটি পূর্ণসংখ্যা অ্যারেতে সমস্ত জোড়া খুঁজে বের করে যার যোগফল n এবং n2 এর সমান।\n    \n    প্যারামিটার:\n    lst: পূর্ণসংখ্যা অ্যারে\n    n: প্রদত্ত সংখ্যা (যোগফলের জন্য)\n    n2: অন্য প্রদত্ত সংখ্যা (যোগফলের জন্য)\n    \n    রিটার্ন:\n    যোগফল সমান হওয়া জোড়াগুলির সংখ্যা\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] + lst[j] == n or lst[i] + lst[j] == n2:\n                count += 1\n    return count\n```"
  },
  {
    "id":328,
    "response":"```python\ndef min_length(lst):\n    \"\"\"\n    সর্বনিম্ম দৈর্ঘ্যের তালিকা খুঁজে বের করে।\n    \n    প্যারামিটার:\n    lst: একটি তালিকা যার মধ্যে তালিকা বা অবজেক্ট থাকতে পারে\n    \n    রিটার্ন:\n    সর্বনিম্ম দৈর্ঘ্যের তালিকার দৈর্ঘ্য যদি তালিকা খালি হয় তবে 0 রিটার্ন করে।\n    \"\"\"\n    if not lst:\n        return 0\n    \n    min_len = len(lst[0])\n    for item in lst:\n        if isinstance(item, (list, tuple)):\n            min_len = min(min_len, len(item))\n    \n    return min_len\n```"
  },
  {
    "id":329,
    "response":"```python\ndef jacobsthal_lucas(n):\n    \"\"\"\n    Calculate the nth Jacobsthal-Lucas number.\n    \n    The Jacobsthal-Lucas numbers are defined by the recurrence relation:\n    J(0) = 2, J(1) = 1, and J(n) = J(n-1) + 2*J(n-2) for n >= 2.\n    \n    Args:\n        n (int): The index of the Jacobsthal-Lucas number to compute.\n    \n    Returns:\n        int: The nth Jacobsthal-Lucas number.\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    a, b = 2, 1\n    for i in range(2, n + 1):\n        a, b = b, a + 2 * b\n    \n    return b\n```"
  },
  {
    "id":330,
    "response":"```python\ndef negative_count(lst):\n    \"\"\"\n    পূর্ণসংখ্যার একটি অ্যারেতে নেতিবাচন সংখ্যার অনুপাত খুঁজে বের করে।\n    \n    প্যারামিটার:\n    lst (list): পূর্ণসংখ্যা অ্যারে\n    \n    রিটার্ন:\n    float: নেতিবাচন সংখ্যার অনুপাত (নেতিবাচন সংখ্যা \/ মোট সংখ্যা)\n    \"\"\"\n    if not lst:\n        return 0.0\n    \n    negative_count = sum(1 for x in lst if x < 0)\n    total_count = len(lst)\n    \n    return negative_count \/ total_count\n```"
  },
  {
    "id":331,
    "response":"```python\ndef min_coins(lst, n, n2):\n    \"\"\"\n    প্রদত্ত মান n এবং n2 কে তৈরি করার জন্য ন্যূনতম সংখ্যক মুদ্রা খুঁজে বের করে।\n    \n    Parameters:\n    lst: মুদ্রা এর মানের তালিকা (যেমন [1, 3, 4])\n    n: প্রথম মান\n    n2: দ্বিতীয় মান\n    \n    Returns:\n    মুদ্রা এর ন্যূনতম সংখ্যা\n    \"\"\"\n    # মুদ্রা এর সংখ্যা নির্ধারণের জন্য কাজ করা হয়\n    # এখানে আমরা মুদ্রা এর সংখ্যা নির্ধারণ করবো যে সেগুলো দিয়ে দুটি মান তৈরি করা যায়\n    # এটি একটি সহজ ক্যাসেট মুদ্রা সমস্যা হিসাবে দেখা যায়\n    # আমরা এখানে মুদ্রা এর সংখ্যা নির্ধারণ করবো যে সেগুলো দিয়ে দুটি মান তৈরি করা যায়\n    \n    # মুদ্রা এর সংখ্যা নির্ধারণের জন্য কাজ করা হয়\n    # এখানে আমরা মুদ্রা এর সংখ্যা নির্ধারণ করবো যে সেগুলো দিয়ে দুটি মান তৈরি করা যায়\n    # এটি একটি সহজ ক্যাসেট মুদ্রা সমস্যা হিসাবে দেখা যায়\n    # আমরা এখানে মুদ্রা এর সংখ্যা নির্ধারণ করবো যে সেগুলো দিয়ে দুটি মান তৈরি করা যায়\n    \n    # মুদ্রা এর সংখ্যা নির্ধারণের জন্য কাজ করা হয়\n    # এখানে আমরা মুদ্রা এর সংখ্যা নির্ধারণ করবো যে সেগুলো দিয়ে দুটি মান তৈরি করা যায়\n    # এটি একটি সহজ ক্যাসেট মুদ্রা সমস্যা হিসাবে দেখা যায়\n    # আমরা এখ"
  },
  {
    "id":332,
    "response":"```python\ndef check_permutation(s, s2):\n    \"\"\"\n    Check if two strings are permutations of each other.\n    \n    Args:\n        s (str): First string\n        s2 (str): Second string\n    \n    Returns:\n        bool: True if the strings are permutations of each other, False otherwise\n    \"\"\"\n    # Remove spaces and convert to lowercase for case-insensitive comparison\n    s_clean = s.replace(\" \", \"\").lower()\n    s2_clean = s2.replace(\" \", \"\").lower()\n    \n    # If lengths are different, they can't be permutations\n    if len(s_clean) != len(s2_clean):\n        return False\n    \n    # Sort the characters and compare\n    return sorted(s_clean) == sorted(s2_clean)\n```"
  },
  {
    "id":333,
    "response":"```python\ndef remove_datatype(tup, param):\n    \"\"\"\n    প্রদত্ত টিউপেল থেকে নির্দিষ্ট ডেটা টাইপ উপাদানগুলি সরিয়ে ফেলে।\n    \n    প্যারামিটার:\n    tup: টিউপেল যার উপাদানগুলি সংশোধন করা হবে\n    param: কোন ডেটা টাইপ সরানো হবে (যেমন: int, str, float, list, dict ইত্যাদি)\n    \n    রিটার্ন:\n    নির্দিষ্ট ডেটা টাইপ সরিয়ে ফেলা টিউপেল\n    \"\"\"\n    import types\n    \n    # ডেটা টাইপ পরিচিতি নির্দেশ করা হয়েছে\n    if param == 'int':\n        return tuple(x for x in tup if not isinstance(x, int))\n    elif param == 'str':\n        return tuple(x for x in tup if not isinstance(x, str))\n    elif param == 'float':\n        return tuple(x for x in tup if not isinstance(x, float))\n    elif param == 'list':\n        return tuple(x for x in tup if not isinstance(x, list))\n    elif param == 'dict':\n        return tuple(x for x in tup if not isinstance(x, dict))\n    elif param == 'tuple':\n        return tuple(x for x in tup if not isinstance(x, tuple))\n    elif param == 'bool':\n        return tuple(x for x in tup if not isinstance(x, bool))\n    elif param == 'None':\n        return tuple(x for x in tup if x is not None)\n    else:\n        # অন্য কোনো ডেটা টাইপ হলে সবগুলি রাখা হবে\n        return tup\n```"
  },
  {
    "id":334,
    "response":"```python\ndef search_literal(s, s2):\n    \"\"\"\n    একটি স্ট্রিংয়ের মধ্যে একটি আক্ষরিক স্ট্রিং অনুসন্ধান করে অবস্থানটি সন্ধান করে।\n    \n    Parameters:\n    s (str): মূল স্ট্রিং\n    s2 (str): অনুসন্ধান করা প্যাটার্ন স্ট্রিং\n    \n    Returns:\n    int: প্যাটার্নটির প্রথম অবস্থান, যদি পাওয়া যায় না তবে -1 রিটার্ন করে\n    \"\"\"\n    index = s.find(s2)\n    return index if index != -1 else -1\n```"
  },
  {
    "id":335,
    "response":"```python\ndef topbottom_surfacearea(n):\n    \"\"\"\n    Calculate the surface area of the top and bottom of a cylinder.\n    \n    Parameters:\n    n (float): The radius of the cylinder's base.\n    \n    Returns:\n    float: The combined surface area of the top and bottom circles.\n    \"\"\"\n    import math\n    return 2 * math.pi * n * n\n```"
  },
  {
    "id":336,
    "response":"```python\ndef nth_items(lst, n):\n    \"\"\"\n    একটি তালিকার n-তম আইটেম নির্বাচন করে।\n    \n    প্যারামিটার:\n    lst: তালিকা\n    n: n-তম আইটেমের স্থান (0 থেকে শুরু)\n    \n    রিটার্ন:\n    n-তম আইটেম, যদি তালিকা n-তম আইটেম থাকে, অন্যথায় থাকে না।\n    \"\"\"\n    if n < 0 or n >= len(lst):\n        return None\n    return lst[n]\n```"
  },
  {
    "id":337,
    "response":"```python\ndef first_repeated_word(s):\n    \"\"\"\n    Find the first repeated word in a given string.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: The first word that appears more than once, or None if no repetition found\n    \"\"\"\n    if not s or not s.strip():\n        return None\n    \n    # Convert string to lowercase and split into words\n    words = s.lower().split()\n    \n    # Remove punctuation from words\n    cleaned_words = []\n    for word in words:\n        cleaned_word = ''.join(char for char in word if char.isalnum())\n        if cleaned_word:  # Only add non-empty words\n            cleaned_words.append(cleaned_word)\n    \n    # Use a set to track seen words\n    seen = set()\n    for word in cleaned_words:\n        if word in seen:\n            return word\n        seen.add(word)\n    \n    return None\n```"
  },
  {
    "id":338,
    "response":"```python\ndef string_list_to_tuple(string_list):\n    \"\"\"\n    প্রদত্ত স্ট্রিং তালিকা কে একটি টিপলে রূপান্তর করে।\n    \n    প্যারামিটার:\n    string_list (list): স্ট্রিং তালিকা\n    \n    রিটার্ন:\n    tuple: স্ট্রিং তালিকার রূপান্তরিত টিপল\n    \"\"\"\n    return tuple(string_list)\n```"
  },
  {
    "id":339,
    "response":"```python\ndef basesnum_coresspondingnum(lst, lst2):\n    \"\"\"\n    মানচিত্র ফাংশন ব্যবহার করে সূচকের সংশ্লিষ্ট সংখ্যার উপর ভিত্তি করে এই সংখ্যার শক্তি ধারণকারী একটি তালিকা তৈরি করে।\n    \n    Parameters:\n    lst (list): সূচকের তালিকা\n    lst2 (list): সংশ্লিষ্ট সংখ্যার তালিকা\n    \n    Returns:\n    list: প্রতিটি সূচকের জন্য সংশ্লিষ্ট সংখ্যার শক্তি ধারণকারী তালিকা\n    \"\"\"\n    result = []\n    for base, num in zip(lst, lst2):\n        if base == 0:\n            result.append(1)  # 0 এর শক্তি সবসময় 1\n        else:\n            result.append(num ** base)\n    return result\n```"
  },
  {
    "id":340,
    "response":"```python\ndef find_Diff(lst, n):\n    \"\"\"\n    Find the difference between the maximum and minimum frequencies in the list.\n    \n    Args:\n        lst: List of elements\n        n: Not used in the function (as per example, but included for consistency)\n    \n    Returns:\n        int: Difference between maximum and minimum frequencies\n    \"\"\"\n    if not lst:\n        return 0\n    \n    # Count frequency of each element\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    \n    # Get max and min frequencies\n    max_freq = max(freq.values())\n    min_freq = min(freq.values())\n    \n    return max_freq - min_freq\n```"
  },
  {
    "id":341,
    "response":"```python\ndef check_abundant(n):\n    \"\"\"\n    Check if a number is abundant.\n    \n    An abundant number is a number for which the sum of its proper divisors \n    (divisors excluding the number itself) is greater than the number.\n    \n    Args:\n        n (int): The number to check\n        \n    Returns:\n        bool: True if the number is abundant, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    # Find all proper divisors and sum them\n    divisor_sum = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisor_sum += i\n            # Add the corresponding divisor (n \/\/ i) if it's different from i\n            if i != n \/\/ i and i != 1:\n                divisor_sum += n \/\/ i\n    \n    # Subtract the number itself to get proper divisors sum\n    proper_divisor_sum = divisor_sum - n\n    \n    return proper_divisor_sum > n\n```"
  },
  {
    "id":342,
    "response":"```python\nimport re\n\ndef fill_spaces(s):\n    \"\"\"\n    Replace spaces, commas, and periods in a string with pipes (|).\n    \n    Args:\n        s (str): Input string to process\n        \n    Returns:\n        str: String with spaces, commas, and periods replaced by pipes\n    \"\"\"\n    return re.sub(r'[ ,.]', '|', s)\n```"
  },
  {
    "id":343,
    "response":"```python\ndef add_two_numbers(n, n2):\n    \"\"\"Add two numbers and print their sum.\"\"\"\n    result = n + n2\n    print(result)\n```"
  },
  {
    "id":344,
    "response":"```python\ndef flatten_tuple(lst):\n    \"\"\"\n    একটি স্ট্রিং এ টিপল তালিকা সমতল করার জন্য একটি ফাংশন।\n    তবে স্ট্রিং এ টিপল তালিকা সমতল করা সম্ভব না, কারণ স্ট্রিং একটি স্ট্রিং হয়।\n    সম্ভব হল একটি লিস্ট বা টিপল সমতল করা।\n    সম্ভব হল একটি লিস্ট বা টিপল সমতল করা।\n    \"\"\"\n    result = []\n    for item in lst:\n        if isinstance(item, (list, tuple)):\n            result.extend(flatten_tuple(item))\n        else:\n            result.append(item)\n    return result\n```"
  },
  {
    "id":345,
    "response":"```python\ndef toggle_F_and_L_bits(n):\n    \"\"\"\n    Toggle the first and last bits of a given number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The number with first and last bits toggled\n    \"\"\"\n    # Handle edge case where n is 0\n    if n == 0:\n        return 1\n    \n    # Find the number of bits in n\n    bit_length = n.bit_length()\n    \n    # Get the last bit (least significant bit)\n    last_bit = n & 1\n    \n    # Get the first bit (most significant bit)\n    first_bit = (n >> (bit_length - 1)) & 1\n    \n    # Toggle the first and last bits\n    # Create a mask to toggle the first and last bits\n    mask = (1 << (bit_length - 1)) | 1\n    \n    # Toggle the first and last bits\n    result = n ^ mask\n    \n    return result\n```"
  },
  {
    "id":346,
    "response":"```python\ndef last_occurence_char(s, s2):\n    \"\"\"\n    একটি স্ট্রিংয়ে দেওয়া অক্ষরের শেষ উপস্থিতি খুঁজে বের করে।\n    \n    প্যারামিটার:\n    s (str): সার্চ করার স্ট্রিং\n    s2 (str): অক্ষর যার শেষ উপস্থিতি খুঁজে বের করা হবে\n    \n    রিটার্ন:\n    int: অক্ষরের শেষ উপস্থিতি যদি অস্তিত্বে থাকে, অন্যথায় -1\n    \"\"\"\n    if s2 not in s:\n        return -1\n    \n    # শেষ উপস্থিতি খুঁজে বের করা\n    return len(s) - s[::-1].index(s2) - 1\n```"
  },
  {
    "id":347,
    "response":"```python\ndef total_hamming_distance(n):\n    \"\"\"\n    Calculate the sum of Hamming distances between all pairs of consecutive integers \n    from 0 to n (inclusive).\n    \n    Note: The problem is interpreted as finding the sum of Hamming distances \n    between each pair (i, i+1) for i from 0 to n-1.\n    \n    Args:\n        n (int): The upper limit (inclusive)\n    \n    Returns:\n        int: Total Hamming distance between consecutive integers from 0 to n\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    total_distance = 0\n    \n    for i in range(n):\n        # Calculate Hamming distance between i and i+1\n        xor_value = i ^ (i + 1)\n        # Count number of 1s in the XOR result\n        hamming_distance = bin(xor_value).count('1')\n        total_distance += hamming_distance\n    \n    return total_distance\n```"
  },
  {
    "id":348,
    "response":"```python\ndef longest_increasing_subsequence(lst):\n    if not lst:\n        return 0\n    \n    n = len(lst)\n    # dp[i] represents the length of the longest increasing subsequence ending at index i\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if lst[j] < lst[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n```"
  },
  {
    "id":349,
    "response":"```python\ndef odd_Num_Sum(n):\n    \"\"\"\n    প্রথম n অদ্ভুত প্রাকৃতিক সংখ্যার পঞ্চম ক্ষমতার যোগফল খুঁজে বের করে।\n    \n    অদ্ভুত প্রাকৃতিক সংখ্যা হল যে সংখ্যা যা বিজোড়।\n    পঞ্চম ক্ষমতা মানে সংখ্যার 5 তম ক্ষমতা (সংখ্যা^5)।\n    \n    Parameters:\n    n (int): প্রথম n টি বিজোড় সংখ্যা নেওয়া হবে।\n    \n    Returns:\n    int: প্রথম n টি বিজোড় সংখ্যার 5 তম ক্ষমতার যোগফল।\n    \"\"\"\n    total = 0\n    for i in range(n):\n        odd_num = 2 * i + 1\n        total += odd_num ** 5\n    return total\n```"
  },
  {
    "id":350,
    "response":"```python\ndef find_Max(lst, n, n2):\n    \"\"\"\n    Find the maximum element in a sorted and rotated array.\n    \n    Args:\n        lst: A sorted and rotated array (list of integers)\n        n: Size of the array\n        n2: (Unused parameter, likely a typo or placeholder)\n    \n    Returns:\n        The maximum element in the array\n    \"\"\"\n    # In a sorted and rotated array, the maximum element is the last element\n    # of the original sorted array before rotation.\n    # Since it's sorted and rotated, the maximum element will be at the position\n    # where the rotation point occurs, which is where lst[i] > lst[i+1].\n    \n    # If the array has only one element, return that element\n    if n == 1:\n        return lst[0]\n    \n    # Find the rotation point where lst[i] > lst[i+1]\n    # The maximum element will be at the index just before this point\n    # or at the end of the array if it's not rotated.\n    \n    left, right = 0, n - 1\n    \n    # If the array is not rotated (already sorted), max is at the end\n    if lst[0] <= lst[n - 1]:\n        return lst[n - 1]\n    \n    # Binary search for the rotation point\n    while left < right:\n        mid = (left + right) \/\/ 2\n        \n        # If mid element is greater than the next element, we found the rotation point\n        if lst[mid] > lst[mid + 1]:\n            return lst[mid + 1]\n        \n        # If the left half is sorted, the maximum is in the right half\n        if lst[left] <= lst[mid]:\n            left = mid + 1\n        else:\n            right = mid\n    \n    # If no rotation point found, max is at the end\n    return lst[n - 1]\n```"
  },
  {
    "id":351,
    "response":"```python\ndef extract_column(lst, n):\n    \"\"\"\n    একটি নেস্টেড তালিকা থেকে একটি নির্দিষ্ট কলাম বের করে ফেরত দেয়।\n    \n    প্যারামিটার:\n    lst: নেস্টেড তালিকা (যেমন: [[a, b, c], [d, e, f], ...])\n    n: কলামের নম্বর (0 থেকে শুরু করে)\n    \n    রিটার্ন:\n    নির্দিষ্ট কলামের সমস্ত মানের একটি তালিকা\n    \"\"\"\n    result = []\n    for row in lst:\n        if len(row) > n:\n            result.append(row[n])\n    return result\n```"
  },
  {
    "id":352,
    "response":"```python\ndef Seq_Linear(lst):\n    \"\"\"\n    একটি প্রদত্ত ক্রমটি রৈখিক কিনা তা পরীক্ষা করে।\n    রৈখিক ক্রম হল যে কোন ক্রমের প্রতিটি পদ পূর্বের পদের সাথে স্থানান্তরের সাথে সম্পর্কিত হয়।\n    এখানে রৈখিক ক্রম হিসাবে বোঝানো হয়েছে যে প্রতিটি পদ পূর্বের পদের সাথে স্থানান্তরের সাথে সম্পর্কিত হয়।\n    তবে এখানে ক্রমটি রৈখিক হওয়ার মানে হল যে প্রতিটি পদ পূর্বের পদের সাথে স্থানান্তরের সাথে সম্পর্কিত হয়।\n    \"\"\"\n    # ক্রমের দৈর্ঘ্য কম হলে রৈখিক হবে\n    if len(lst) <= 1:\n        return True\n    \n    # প্রতিটি পদের পূর্বের পদের সাথে সম্পর্ক চেক করা হয়\n    for i in range(1, len(lst)):\n        if lst[i] != lst[i-1]:\n            return False\n    \n    return True\n```"
  },
  {
    "id":353,
    "response":"```python\ndef tuple_to_float(tup):\n    \"\"\"\n    প্রদত্ত টিউপলকে একটি ফ্লোটিং-পয়েন্ট সংখ্যায় রূপান্তর করে।\n    \n    প্যারামিটার:\n        tup: একটি টিউপল (যেখানে একটি ফ্লোটিং-পয়েন্ট সংখ্যা থাকবে)\n    \n    রিটার্ন:\n        টিউপলের একমাত্র মান হিসাবে ফ্লোটিং-পয়েন্ট সংখ্যা\n    \"\"\"\n    return float(tup[0])\n```"
  },
  {
    "id":354,
    "response":"```python\ndef split(lst):\n    \"\"\"\n    একটি মিশ্র তালিকা থেকে অদ্ভুত সংখ্যা (অর্থাৎ সংখ্যা এবং অসংখ্যা উভয় ধরনের উপস্থিতি থাকলে) খুঁজে পেতে একটি ফাংশন।\n    এখানে অদ্ভুত সংখ্যা হল যে কোন সংখ্যা যা তালিকার অন্য উপাদানগুলির মধ্যে অসামান্য হবে।\n    যদি সংখ্যা এবং অসংখ্যা উভয় থাকে, তবে সংখ্যা গুলি খুঁজে পাবে।\n    \"\"\"\n    if not lst:\n        return []\n    \n    numbers = []\n    strings = []\n    \n    for item in lst:\n        if isinstance(item, (int, float)):\n            numbers.append(item)\n        else:\n            strings.append(item)\n    \n    # যদি সংখ্যা এবং অসংখ্যা উভয়ই থাকে, তবে সংখ্যা গুলি ফেরত দেওয়া হবে\n    if numbers and strings:\n        return numbers\n    elif numbers:\n        return numbers\n    else:\n        return strings\n```"
  },
  {
    "id":355,
    "response":"```python\ndef difference(n):\n    \"\"\"\n    Calculate the difference between the sum of cubes of first n natural numbers\n    and the sum of first n natural numbers.\n    \n    Args:\n        n (int): The number of natural numbers to consider\n        \n    Returns:\n        int: The difference between sum of cubes and sum of numbers\n    \"\"\"\n    # Sum of first n natural numbers: n(n+1)\/2\n    sum_of_numbers = n * (n + 1) \/\/ 2\n    \n    # Sum of cubes of first n natural numbers: [n(n+1)\/2]^2\n    sum_of_cubes = (n * (n + 1) \/\/ 2) ** 2\n    \n    # Return the difference\n    return sum_of_cubes - sum_of_numbers\n```"
  },
  {
    "id":356,
    "response":"```python\ndef find_Odd_Pair(lst, n):\n    \"\"\"\n    Find pairs of numbers in the list where the XOR of the pair equals n.\n    \n    Args:\n        lst: List of integers\n        n: Target XOR value\n    \n    Returns:\n        List of tuples containing pairs (a, b) such that a ^ b == n\n    \"\"\"\n    pairs = []\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] ^ lst[j] == n:\n                pairs.append((lst[i], lst[j]))\n    return pairs\n```"
  },
  {
    "id":357,
    "response":"```python\ndef toggle_string(s):\n    \"\"\"\n    একটি স্ট্রিংয়ের অক্ষরের কেস টগল করে ফেরত দেয়।\n    \n    Args:\n        s (str): কেস টগল করার জন্য দেয়া স্ট্রিং\n        \n    Returns:\n        str: কেস টগল হওয়া স্ট্রিং\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n```"
  },
  {
    "id":358,
    "response":"```python\ndef digit_distance_nums(n, n2):\n    \"\"\"\n    Calculate the digit distance between two integers.\n    Digit distance is the sum of absolute differences between each corresponding digit.\n    \n    Args:\n        n (int): First integer\n        n2 (int): Second integer\n    \n    Returns:\n        int: Sum of absolute differences between corresponding digits\n    \"\"\"\n    # Convert numbers to strings to access individual digits\n    str_n = str(abs(n))\n    str_n2 = str(abs(n2))\n    \n    # Pad the shorter number with zeros on the left\n    max_len = max(len(str_n), len(str_n2))\n    str_n = str_n.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    \n    # Calculate sum of absolute differences of corresponding digits\n    distance = 0\n    for i in range(max_len):\n        distance += abs(int(str_n[i]) - int(str_n2[i]))\n    \n    return distance\n```"
  },
  {
    "id":359,
    "response":"```python\ndef max_sub_array_sum(lst, n):\n    \"\"\"\n    Find the maximum sum of any contiguous subarray within the given array.\n    \n    Args:\n        lst: List of integers\n        n: Length of the array\n    \n    Returns:\n        Integer representing the maximum sum of a contiguous subarray\n    \"\"\"\n    if not lst or n == 0:\n        return 0\n    \n    max_sum = lst[0]\n    current_sum = lst[0]\n    \n    for i in range(1, n):\n        current_sum = max(lst[i], current_sum + lst[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```"
  },
  {
    "id":360,
    "response":"```python\ndef union_elements(tup, tup2):\n    \"\"\"\n    Return the union of elements from two tuples.\n    \n    Args:\n        tup: First tuple\n        tup2: Second tuple\n    \n    Returns:\n        A tuple containing the union of elements from both tuples\n    \"\"\"\n    # Convert tuples to sets to find union, then convert back to tuple\n    return tuple(set(tup) | set(tup2))\n```"
  },
  {
    "id":361,
    "response":"```python\ndef assign_elements(lst):\n    \"\"\"\n    Assign each element to its pair in the given list such that each element\n    is paired with another element from the list, forming pairs.\n    \n    Args:\n        lst: A list of elements (assumed to have even length)\n    \n    Returns:\n        A list of tuples where each tuple contains a pair of elements.\n        If the list has odd length, the last element is paired with None.\n    \n    Example:\n        assign_elements([1, 2, 3, 4]) -> [(1, 2), (3, 4)]\n        assign_elements([1, 2, 3]) -> [(1, 2), (3, None)]\n    \"\"\"\n    if not lst:\n        return []\n    \n    result = []\n    for i in range(0, len(lst), 2):\n        pair = (lst[i], lst[i + 1] if i + 1 < len(lst) else None)\n        result.append(pair)\n    \n    return result\n```"
  },
  {
    "id":362,
    "response":"```python\ndef find_max_length(lst):\n    \"\"\"\n    Find the maximum length among all sublists in a list of lists.\n    \n    Args:\n        lst: A list of lists (sublists)\n    \n    Returns:\n        int: The maximum length of any sublist\n    \"\"\"\n    if not lst:\n        return 0\n    \n    max_length = 0\n    for sublist in lst:\n        max_length = max(max_length, len(sublist))\n    \n    return max_length\n```"
  },
  {
    "id":363,
    "response":"```python\ndef extract_values(s):\n    \"\"\"\n    Extract values from a string that is enclosed in quotes.\n    \n    Args:\n        s (str): Input string containing quoted values\n        \n    Returns:\n        list: List of extracted values (strings) from within quotes\n    \"\"\"\n    values = []\n    i = 0\n    n = len(s)\n    \n    while i < n:\n        # Find opening quote\n        if s[i] in ['\"', \"'\"]:\n            quote = s[i]\n            i += 1\n            value = \"\"\n            while i < n and s[i] != quote:\n                value += s[i]\n                i += 1\n            # Skip the closing quote\n            if i < n and s[i] == quote:\n                i += 1\n            values.append(value)\n        else:\n            i += 1\n    \n    return values\n```"
  },
  {
    "id":364,
    "response":"```python\ndef count_Pairs(lst, n):\n    \"\"\"\n    Count the number of odd pairs in the given list.\n    \n    Args:\n        lst: List of integers\n        n: Not used in the function (as per the example)\n    \n    Returns:\n        int: Number of pairs where both elements are odd\n    \"\"\"\n    # Count odd numbers in the list\n    odd_count = sum(1 for x in lst if x % 2 == 1)\n    \n    # Number of ways to choose 2 odd numbers from odd_count\n    if odd_count < 2:\n        return 0\n    \n    return odd_count * (odd_count - 1) \/\/ 2\n```"
  },
  {
    "id":365,
    "response":"```python\ndef split(s):\n    \"\"\"\n    একটি স্ট্রিংকে অক্ষরে বিভক্ত করে একটি লিস্ট রিটার্ন করে।\n    \n    Args:\n        s (str): বিভক্ত করার জন্য স্ট্রিং\n        \n    Returns:\n        list: অক্ষরগুলির একটি লিস্ট\n    \"\"\"\n    return list(s)\n```"
  },
  {
    "id":366,
    "response":"```python\ndef sum_digits(n):\n    \"\"\"\n    একটি অ-নতিবাচক পূর্ণসংখ্যার যোগফল পেতে ফাংশন লিখেছি।\n    \n    Parameters:\n    n (int): অ-নতিবাচক পূর্ণসংখ্যা\n    \n    Returns:\n    int: সংখ্যার সংখ্যা যোগফল\n    \"\"\"\n    total = 0\n    while n > 0:\n        total += n % 10\n        n \/\/= 10\n    return total\n```"
  },
  {
    "id":367,
    "response":"```python\ndef issort_list(lst):\n    \"\"\"\n    Check if a list is already sorted in ascending order.\n    \n    Args:\n        lst: A list of comparable elements\n        \n    Returns:\n        bool: True if the list is sorted in ascending order, False otherwise\n    \"\"\"\n    if len(lst) <= 1:\n        return True\n    \n    for i in range(1, len(lst)):\n        if lst[i] < lst[i-1]:\n            return False\n    \n    return True\n```"
  },
  {
    "id":368,
    "response":"```python\ndef empty_list(n):\n    \"\"\"Create a list of n empty dictionaries (empty dictionary list).\"\"\"\n    return [{} for _ in range(n)]\n```"
  },
  {
    "id":369,
    "response":"```python\ndef sort_sublists(lst):\n    \"\"\"\n    প্রদত্ত তালিকার প্রতিটি স্ট্রিংয়ের উপ-তালিকা বাছাই করে।\n    \n    Args:\n        lst: একটি তালিকা, যার প্রতিটি উপাদান একটি উপ-তালিকা (list) হবে\n        \n    Returns:\n        প্রতিটি উপ-তালিকা বাছাই করা তালিকা\n    \"\"\"\n    return [sorted(sublist) for sublist in lst]\n```"
  },
  {
    "id":370,
    "response":"```python\ndef remove_words(lst, lst2):\n    \"\"\"\n    একটি প্রদত্ত তালিকা থেকে অন্য একটি তালিকার স্ট্রিংগুলি সরিয়ে ফেলে।\n    \n    Args:\n        lst: শব্দগুলি সরানোর জন্য প্রাথমিক তালিকা\n        lst2: সরানো হবে শব্দগুলির তালিকা\n    \n    Returns:\n        শব্দগুলি সরিয়ে ফেলা তালিকা\n    \"\"\"\n    return [word for word in lst if word not in lst2]\n```"
  },
  {
    "id":371,
    "response":"```python\ndef max_sum_pair_diff_lessthan_K(lst, k):\n    \"\"\"\n    Find the maximum sum of pairs where the absolute difference between elements is less than k.\n    \n    Args:\n        lst: List of integers\n        k: Integer threshold for the difference between elements in a pair\n    \n    Returns:\n        Maximum sum of pairs where |a - b| < k, or -1 if no such pair exists\n    \"\"\"\n    if len(lst) < 2:\n        return -1\n    \n    max_sum = float('-inf')\n    n = len(lst)\n    \n    # Check all pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(lst[i] - lst[j]) < k:\n                max_sum = max(max_sum, lst[i] + lst[j])\n    \n    return max_sum if max_sum != float('-inf') else -1\n```"
  },
  {
    "id":372,
    "response":"```python\ndef two_unique_nums(lst):\n    \"\"\"\n    একটি তালিকা থেকে দুটি ডুপ্লিকেট সংখ্যা অপসারণ করে একটি নির্দিষ্ট সংখ্যক অদ্বিতীয় সংখ্যা রাখে।\n    \n    Parameters:\n    lst (list): তালিকা যেখানে ডুপ্লিকেট সংখ্যা থাকতে পারে\n    \n    Returns:\n    list: ডুপ্লিকেট সংখ্যা অপসারণ করে অদ্বিতীয় সংখ্যা বিশিষ্ট তালিকা\n    \"\"\"\n    return list(set(lst))\n```"
  },
  {
    "id":373,
    "response":"```python\ndef unique_product(lst):\n    \"\"\"\n    Calculate the product of unique numbers in a list.\n    \n    Args:\n        lst: A list of numbers (int or float)\n    \n    Returns:\n        int or float: The product of unique numbers in the list.\n                      If the list is empty, returns 1 (multiplicative identity).\n    \"\"\"\n    if not lst:\n        return 1\n    \n    # Convert list to set to get unique numbers\n    unique_numbers = set(lst)\n    \n    # Calculate the product of unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    \n    return product\n```"
  },
  {
    "id":374,
    "response":"```python\ndef surfacearea_cylinder(radius, height):\n    \"\"\"\n    Calculate the surface area of a cylinder.\n    \n    Parameters:\n    radius (float): The radius of the cylinder's base.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The surface area of the cylinder.\n    \"\"\"\n    import math\n    return 2 * math.pi * radius * (radius + height)\n```"
  },
  {
    "id":375,
    "response":"```python\ndef count_no(n, n2, n3, n4):\n    \"\"\"\n    একটি অনুক্রমের মধ্যে n-তম সংখ্যা খুঁজে বের করে।\n    প্রদত্ত সংখ্যাগুলি অনুক্রমের অংশ হিসাবে ব্যবহার হবে।\n    \n    Parameters:\n    n (int): অনুক্রমের কোন স্থানে সংখ্যা খুঁজবে।\n    n2, n3, n4: অনুক্রমের অংশগুলি।\n    \n    Returns:\n    int: n-তম সংখ্যা।\n    \"\"\"\n    # অনুক্রমের সংখ্যাগুলি সংরক্ষণ করা হয়েছে\n    sequence = [n, n2, n3, n4]\n    \n    # n-তম সংখ্যা খুঁজে বের করা হয়\n    if n <= 0 or n > len(sequence):\n        raise IndexError(\"n এর মান অনুক্রমের সীমার বাইরে।\")\n    \n    return sequence[n - 1]\n```"
  },
  {
    "id":376,
    "response":"```python\ndef is_Sub_Array(lst, lst2, n, n2):\n    \"\"\"\n    Check if lst2 is a subarray of lst.\n    \n    Args:\n        lst: The main list to search in.\n        lst2: The potential subarray to find.\n        n: Length of the main list.\n        n2: Length of the potential subarray.\n    \n    Returns:\n        True if lst2 is a subarray of lst, False otherwise.\n    \"\"\"\n    # If the subarray is longer than the main array, it can't be a subarray\n    if n2 > n:\n        return False\n    \n    # If the subarray is empty, it's considered a subarray of any array\n    if n2 == 0:\n        return True\n    \n    # Check each possible starting position in the main array\n    for i in range(n - n2 + 1):\n        # Check if the subarray matches starting at position i\n        match = True\n        for j in range(n2):\n            if lst[i + j] != lst2[j]:\n                match = False\n                break\n        if match:\n            return True\n    \n    return False\n```"
  },
  {
    "id":377,
    "response":"```python\ndef last_Digit_Factorial(n):\n    \"\"\"\n    প্রদত্ত সংখ্যার ফ্যাক্টরিয়ালের শেষ অঙ্কটি খুঁজে পায়।\n    \n    প্রমাণ: যখন n >= 5, তখন n! এর শেষ অঙ্ক হবে 0 (কারণ 5 এবং 2 এর গুণফল হয় 10)।\n    তাই শুধুমাত্র n < 5 হলে শেষ অঙ্ক নির্ণয় করা হবে।\n    \n    Parameters:\n    n (int): ফ্যাক্টরিয়ালের জন্য প্রদত্ত সংখ্যা\n    \n    Returns:\n    int: ফ্যাক্টরিয়ালের শেষ অঙ্ক\n    \"\"\"\n    if n >= 5:\n        return 0\n    \n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    \n    return factorial % 10\n```"
  },
  {
    "id":378,
    "response":"```python\ndef interleave_lists(lst, lst2, lst3):\n    \"\"\"\n    একই দৈর্ঘ্যের তিনটি তালিকা কে একত্রিত করে একটি নতুন তালিকা তৈরি করে।\n    \n    Args:\n        lst: প্রথম তালিকা\n        lst2: দ্বিতীয় তালিকা\n        lst3: তৃতীয় তালিকা\n    \n    Returns:\n        একটি তালিকা যার মধ্যে তিনটি তালিকার উপাদানগুলি পরস্পর সাথে সংযুক্ত হয়।\n    \n    Example:\n        interleave_lists([1, 2], ['a', 'b'], [True, False]) \n        -> [1, 'a', True, 2, 'b', False]\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        result.append(lst[i])\n        result.append(lst2[i])\n        result.append(lst3[i])\n    return result\n```"
  },
  {
    "id":379,
    "response":"```python\ndef find_dissimilar(tup, tup2):\n    \"\"\"\n    দুটি টুপলের মধ্যে যে উপাদানগুলি প্রেক্ষাপটে ভিন্ন হয়েছে, সেগুলি খুঁজে পাবে।\n    \n    Parameters:\n    tup: প্রথম টুপল\n    tup2: দ্বিতীয় টুপল\n    \n    Returns:\n    ভিন্ন উপাদানগুলির একটি টুপল\n    \"\"\"\n    set1 = set(tup)\n    set2 = set(tup2)\n    dissimilar = set1.symmetric_difference(set2)\n    return tuple(dissimilar)\n```"
  },
  {
    "id":380,
    "response":"```python\ndef extract_even(tup):\n    \"\"\"\n    Extracts all even numbers from a nested mixed tuple.\n    \n    Args:\n        tup: A nested tuple containing integers and other tuples.\n    \n    Returns:\n        A tuple containing all even numbers found in the nested structure.\n    \"\"\"\n    result = []\n    \n    def traverse(item):\n        if isinstance(item, tuple):\n            for element in item:\n                traverse(element)\n        elif isinstance(item, int):\n            if item % 2 == 0:\n                result.append(item)\n    \n    traverse(tup)\n    return tuple(result)\n```"
  },
  {
    "id":381,
    "response":"```python\ndef surface_area(n, n2):\n    \"\"\"\n    Calculate the surface area of a square pyramid.\n    \n    Args:\n        n: length of the base side of the square pyramid\n        n2: height of the square pyramid\n    \n    Returns:\n        The total surface area of the square pyramid\n    \"\"\"\n    # Base area\n    base_area = n * n\n    \n    # Slant height calculation\n    slant_height = (n2**2 + (n\/2)**2)**0.5\n    \n    # Lateral surface area (4 triangular faces)\n    lateral_area = 4 * (0.5 * n * slant_height)\n    \n    # Total surface area\n    total_surface_area = base_area + lateral_area\n    \n    return total_surface_area\n```"
  },
  {
    "id":382,
    "response":"```python\ndef my_dict(dct):\n    \"\"\"\n    Check if a dictionary is empty.\n    \n    Args:\n        dct: The dictionary to check.\n    \n    Returns:\n        bool: True if the dictionary is empty, False otherwise.\n    \"\"\"\n    return len(dct) == 0\n```"
  },
  {
    "id":383,
    "response":"```python\ndef catalan_number(n):\n    \"\"\"\n    Calculate the nth Catalan number.\n    \n    The nth Catalan number is given by the formula:\n    C(n) = (2n)! \/ ((n+1)! * n!)\n    \n    Alternatively, it can be computed using the recurrence relation:\n    C(0) = 1, C(n) = sum(C(i) * C(n-1-i)) for i from 0 to n-1\n    \n    Args:\n        n (int): The index of the Catalan number to compute (non-negative integer)\n    \n    Returns:\n        int: The nth Catalan number\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    # Using the formula: C(n) = (2n)! \/ ((n+1)! * n!)\n    # We can compute this efficiently using the recurrence relation\n    # or by using the direct formula with binomial coefficients\n    \n    # Using the direct formula with binomial coefficient\n    # C(n) = C(2n, n) \/ (n + 1)\n    \n    # Calculate binomial coefficient C(2n, n)\n    def binomial_coefficient(n, r):\n        if r > n or r < 0:\n            return 0\n        if r == 0 or r == n:\n            return 1\n        \n        # Use the multiplicative formula to avoid large factorials\n        result = 1\n        for i in range(min(r, n - r)):\n            result = result * (n - i) \/\/ (i + 1)\n        return result\n    \n    # C(n) = C(2n, n) \/ (n + 1)\n    return binomial_coefficient(2 * n, n) \/\/ (n + 1)\n```"
  },
  {
    "id":384,
    "response":"```python\nimport re\n\ndef find_adverbs(s):\n    \"\"\"\n    রেজেক্স ব্যবহার করে একটি বাক্যে সমস্ত বিশেষণ (adverbs) এবং তাদের অবস্থান খুঁজে পায়।\n    \n    বিশেষণ হল যে কোন শব্দ যা সাধারণত অবস্থানে বা পরিমাণে সম্পর্কিত হয়।\n    এখানে বিশেষণ হিসাবে প্রায় সব এমন শব্দ বিবেচিত হবে যা শেষে একটি অক্ষর বা বিশেষ প্রতীক দিয়ে শেষ হয়।\n    যেমন: খুব, অতি, সব, খুব সহজ, খুব ভালো ইত্যাদি।\n    \n    প্রতিটি বিশেষণের অবস্থান (স্ট্রিং এর কোন পজিশনে) এবং শব্দটি ফেরত দেয়।\n    \n    Parameters:\n        s (str): বাক্য যেখানে বিশেষণ খুঁজে বের করা হবে।\n    \n    Returns:\n        list of tuples: [(adverb, start_index), (adverb, start_index), ...]\n    \"\"\"\n    # বিশেষণ হিসাবে বিবেচিত হবে যে কোন শব্দ যা শেষে 'ly', 'ly', 'ly', 'ly', 'ly' এর মতো প্রতীক দিয়ে শেষ হয়\n    # কিন্তু সাধারণ বিশেষণ হিসাবে ব্যবহার করা হয় যেমন: খুব, অতি, সব, খুব সহজ, খুব ভালো\n    # এখানে আমরা সাধারণ বিশেষণ হিসাবে প্রায় সব শব্দ বিবেচনা করব।\n    \n    # বিশেষণ হিসাবে ব্যবহার করা হয় যেমন: খুব, অতি, সব, খুব, খুব ভালো\n    # আমরা এখানে একটি সাধারণ রেজেক্স ব্যবহার করব।\n    \n    # বিশেষণ হিসাবে ব্যবহার করা হয় যেমন: খুব, অতি, সব, খুব, খুব ভালো\n    # আমরা এখানে একটি সাধারণ রেজেক্স ব্যবহার করব।\n    \n    # বিশেষণ হিসাবে ব্যবহার করা হয়"
  },
  {
    "id":385,
    "response":"```python\ndef expensive_items(lst, n):\n    \"\"\"\n    একটি ডেটাসেট থেকে n ব্যয়বহুল মূল্যের আইটেমগুলি খুঁজে বের করে।\n    \n    Parameters:\n    lst (list): মূল ডেটাসেট, যেখানে প্রতিটি আইটেমের মূল্য থাকবে\n    n (int): ব্যয়বহুল মূল্যের আইটেমের সংখ্যা\n    \n    Returns:\n    list: n ব্যয়বহুল মূল্যের আইটেমগুলির তালিকা\n    \"\"\"\n    if not lst or n <= 0:\n        return []\n    \n    # মূল্যের অনুসারে সাজানো এবং শেষের n টি আইটেম বাদ দেওয়া\n    sorted_items = sorted(lst, reverse=True)\n    return sorted_items[:n]\n```"
  },
  {
    "id":386,
    "response":"```python\ndef split_arr(lst, n, n2):\n    \"\"\"\n    একটি অ্যারেকে বিভক্ত করে এবং প্রথম অংশটি শেষে যোগ করে।\n    \n    Parameters:\n    lst: অ্যারে\n    n: প্রথম অংশের দৈর্ঘ্য\n    n2: দ্বিতীয় অংশের দৈর্ঘ্য (অথবা শেষে যোগ করার অংশ)\n    \n    Returns:\n    প্রথম অংশটি শেষে যোগ করা অ্যারে\n    \"\"\"\n    if n <= 0 or n2 <= 0:\n        return lst\n    \n    # অ্যারেটি বিভক্ত করা\n    first_part = lst[:n]\n    second_part = lst[n:]\n    \n    # প্রথম অংশটি শেষে যোগ করা\n    result = second_part + first_part\n    \n    return result\n```"
  },
  {
    "id":387,
    "response":"```python\ndef list_tuple(lst):\n    \"\"\"\n    একটি তালিকাকে একটি টিপলে রূপান্তর করে।\n    \n    প্যারামিটার:\n    lst (list): রূপান্তর করার জন্য তালিকা।\n    \n    রিটার্ন:\n    tuple: তালিকার রূপান্তরিত টিপল।\n    \"\"\"\n    return tuple(lst)\n```"
  },
  {
    "id":388,
    "response":"```python\ndef big_diff(lst):\n    \"\"\"\n    একটি প্রদত্ত অ্যারেতে বৃহত্তম এবং ক্ষুদ্রতম মানের মধ্যে পার্থক্য খুঁজে পায়।\n    \n    প্যারামিটার:\n    lst (list): পূর্ণসংখ্যা অ্যারে\n    \n    রিটার্ন:\n    int: বৃহত্তম এবং ক্ষুদ্রতম মানের পার্থক্য\n    \"\"\"\n    if not lst:\n        return 0\n    \n    return max(lst) - min(lst)\n```"
  },
  {
    "id":389,
    "response":"```python\ndef perfect_squares(n, n2):\n    \"\"\"\n    দুটি প্রদত্ত সংখ্যার মধ্যে পারফেক্ট স্কোয়ার (perfect square) খুঁজে বের করে।\n    \n    পারফেক্ট স্কোয়ার: যে সংখ্যা কোনো পূর্ণ সংখ্যার বর্গ হয়।\n    \n    Parameters:\n    n (int): প্রথম সংখ্যা\n    n2 (int): দ্বিতীয় সংখ্যা (n2 >= n হওয়া উচিত)\n    \n    Returns:\n    list: দুটি সংখ্যার মধ্যে থাকা পারফেক্ট স্কোয়ারগুলির একটি তালিকা\n    \"\"\"\n    perfect_squares_list = []\n    \n    # দুটি সংখ্যার মধ্যে সব সংখ্যা চেক করা হবে\n    start = n\n    end = n2\n    \n    # প্রতিটি সংখ্যা চেক করা হবে যে এটি কোনো পূর্ণ সংখ্যার বর্গ হয় কিনা\n    for num in range(start, end + 1):\n        # সংখ্যাটির বর্গমূল নেওয়া হয়\n        sqrt_num = int(num ** 0.5)\n        # যদি বর্গমূল একটি পূর্ণ সংখ্যা হয়, তবে এটি পারফেক্ট স্কোয়ার\n        if sqrt_num * sqrt_num == num:\n            perfect_squares_list.append(num)\n    \n    return perfect_squares_list\n```"
  },
  {
    "id":390,
    "response":"```python\ndef polar_rect(r, theta):\n    \"\"\"\n    পোলার কোঅর্ডিনেট (r, theta) কে আয়তক্ষেত্রাকার কোঅর্ডিনেট (x, y) রূপান্তর করে।\n    \n    প্যারামিটার:\n    r: দূরত্ব (radius)\n    theta: কোণ (রেডিয়ান বা ডিগ্রি হতে রেডিয়ানে রূপান্তর করা হবে)\n    \n    রিটার্ন:\n    x, y: আয়তক্ষেত্রাকার কোঅর্ডিনেট\n    \"\"\"\n    import math\n    \n    # যদি theta ডিগ্রি হয়, তবে রেডিয়ানে রূপান্তর করা হবে\n    if isinstance(theta, int) or isinstance(theta, float):\n        theta_rad = math.radians(theta)\n    else:\n        theta_rad = theta\n    \n    x = r * math.cos(theta_rad)\n    y = r * math.sin(theta_rad)\n    \n    return x, y\n```"
  },
  {
    "id":391,
    "response":"```python\ndef swap_list(lst):\n    \"\"\"\n    একটি তালিকার প্রথম এবং শেষ উপাদান বিনিময় করে।\n    \n    প্রমাণ:\n    swap_list([1, 2, 3, 4]) -> [4, 2, 3, 1]\n    swap_list(['a', 'b', 'c']) -> ['c', 'b', 'a']\n    swap_list([1]) -> [1] (একটি উপাদানের তালিকা হলে কিছু হয় না)\n    \n    প্যারামিটার:\n    lst (list): তালিকা যার প্রথম এবং শেষ উপাদান বিনিময় করা হবে।\n    \n    রিটার্ন:\n    list: প্রথম এবং শেষ উপাদান বিনিময় করা তালিকা।\n    \"\"\"\n    if len(lst) <= 1:\n        return lst[:]\n    \n    # প্রথম এবং শেষ উপাদান বিনিময় করা\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst[:]\n```"
  },
  {
    "id":392,
    "response":"```python\ndef sum_of_product(n):\n    \"\"\"\n    Calculate the sum of binomial coefficients (also known as the sum of the coefficients \n    in the expansion of (1 + 1)^n, which equals 2^n).\n    \n    Args:\n        n (int): The power of the binomial expansion (e.g., (a + b)^n)\n    \n    Returns:\n        int: The sum of all binomial coefficients, which is 2^n\n    \"\"\"\n    return 2 ** n\n```"
  },
  {
    "id":393,
    "response":"```python\ndef removezero_ip(s):\n    \"\"\"\n    একটি আইপি ঠিকানা থেকে শীর্ষস্থানীয় শূন্যগুলি সরিয়ে ফেলে।\n    \n    Args:\n        s (str): আইপি ঠিকানা যেখানে শূন্যগুলি থাকতে পারে (যেমন: \"192.168.001.002\")\n    \n    Returns:\n        str: শূন্যগুলি সরিয়ে ফেলা আইপি ঠিকানা (যেমন: \"192.168.1.2\")\n    \"\"\"\n    if not s:\n        return s\n    \n    parts = s.split('.')\n    cleaned_parts = []\n    \n    for part in parts:\n        # শূন্যগুলি সরিয়ে ফেলে এবং শূন্য হলে তা হবে শূন্য হবে\n        cleaned = part.lstrip('0')\n        if cleaned == '':\n            cleaned = '0'\n        cleaned_parts.append(cleaned)\n    \n    return '.'.join(cleaned_parts)\n```"
  },
  {
    "id":394,
    "response":"```python\ndef diff_even_odd(lst):\n    \"\"\"\n    Find the difference between the first even number and the first odd number in a list.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        int: Difference between first even and first odd number, or None if not found\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0:\n            if first_even is None:\n                first_even = num\n        else:\n            if first_odd is None:\n                first_odd = num\n    \n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return None\n```"
  },
  {
    "id":395,
    "response":"```python\ndef min_swaps(s, s2):\n    \"\"\"\n    Calculate the minimum number of swaps needed to convert binary string s to s2.\n    \n    Args:\n        s (str): Original binary string\n        s2 (str): Target binary string\n    \n    Returns:\n        int: Minimum number of swaps required\n    \n    Note:\n        This function assumes that swapping means changing a bit from 0 to 1 or 1 to 0.\n        The minimum swaps is equal to the number of positions where s and s2 differ.\n        Since each swap can fix two differing positions (by swapping a 0 and 1), \n        the minimum swaps is actually half the number of differing positions.\n        However, if the number of differing positions is odd, we need to round up.\n    \"\"\"\n    # Count the number of positions where the strings differ\n    diff_count = sum(1 for i in range(len(s)) if s[i] != s2[i])\n    \n    # Each swap can fix at most 2 differences\n    # So minimum swaps is ceil(diff_count \/ 2)\n    return (diff_count + 1) \/\/ 2\n```"
  },
  {
    "id":396,
    "response":"```python\ndef tuple_size(tup):\n    \"\"\"\n    প্রদত্ত টিপলের আকার (সংখ্যা অর্থে উপস্থিত অবজেক্টের সংখ্যা) খুঁজে বের করে।\n    \n    প্যারামিটার:\n    tup: কোন টিপল\n    \n    রিটার্ন:\n    টিপলের আকার (সংখ্যা)\n    \"\"\"\n    return len(tup)\n```"
  },
  {
    "id":397,
    "response":"```python\ndef find_kth(lst, lst2, k):\n    \"\"\"\n    Find the k-th element from two sorted arrays.\n    \n    Args:\n        lst: First sorted list\n        lst2: Second sorted list\n        k: The k-th position (1-indexed) to find\n    \n    Returns:\n        The k-th element in the merged sorted sequence\n    \"\"\"\n    # Ensure k is positive\n    if k <= 0:\n        raise ValueError(\"k must be a positive integer\")\n    \n    # Merge the two sorted arrays using two pointers\n    i, j = 0, 0\n    count = 0\n    \n    while i < len(lst) and j < len(lst2):\n        if lst[i] <= lst2[j]:\n            count += 1\n            if count == k:\n                return lst[i]\n            i += 1\n        else:\n            count += 1\n            if count == k:\n                return lst2[j]\n            j += 1\n    \n    # If we've reached the end of one array, get the remaining elements\n    while i < len(lst):\n        count += 1\n        if count == k:\n            return lst[i]\n        i += 1\n    \n    while j < len(lst2):\n        count += 1\n        if count == k:\n            return lst2[j]\n        j += 1\n    \n    return None  # Should never reach here if k is valid\n```"
  },
  {
    "id":398,
    "response":"```python\ndef armstrong_number(n):\n    \"\"\"\n    Check if a given number is an Armstrong number.\n    \n    An Armstrong number (also known as a narcissistic number) is a number \n    that is equal to the sum of its own digits each raised to the power of \n    the total number of digits.\n    \n    Args:\n        n (int): The number to check\n        \n    Returns:\n        bool: True if the number is an Armstrong number, False otherwise\n    \"\"\"\n    # Convert number to string to easily access digits\n    str_n = str(n)\n    num_digits = len(str_n)\n    \n    # Calculate sum of each digit raised to the power of number of digits\n    digit_sum = sum(int(digit) ** num_digits for digit in str_n)\n    \n    # Check if the sum equals the original number\n    return digit_sum == n\n```"
  },
  {
    "id":399,
    "response":"```python\ndef sum_average(n):\n    \"\"\"\n    Calculate the sum and average of the first n natural numbers.\n    \n    Args:\n        n (int): The number of natural numbers to consider (1, 2, 3, ..., n)\n    \n    Returns:\n        tuple: (sum, average)\n    \"\"\"\n    if n <= 0:\n        return 0, 0\n    \n    # Sum of first n natural numbers: n * (n + 1) \/ 2\n    total_sum = n * (n + 1) \/\/ 2\n    \n    # Average = sum \/ n\n    average = total_sum \/ n\n    \n    return total_sum, average\n```"
  },
  {
    "id":400,
    "response":"```python\ndef is_Even(n):\n    \"\"\"\n    বিটওয়াইস অপারেটর ব্যবহার করে প্রদত্ত সংখ্যাটি জোড়া কিনা তা পরীক্ষা করে।\n    \n    প্রদত্ত সংখ্যার শেষ বিট যদি 0 হয় তবে সংখ্যাটি জোড়।\n    শেষ বিট 1 হলে সংখ্যাটি বিজোড়।\n    \n    প্যারামিটার:\n        n (int): পরীক্ষা করার সংখ্যা\n    \n    রিটার্ন:\n        bool: যদি সংখ্যা জোড় হয় তবে True, নাহলে False\n    \"\"\"\n    return (n & 1) == 0\n```"
  }
]